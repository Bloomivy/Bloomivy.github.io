<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>类加载机制</title>
    <link href="/2025/02/05/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2025/02/05/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p>类加载过程：加载-&gt;连接-&gt;初始化。<br>连接过程又可分为三步：验证-&gt;准备-&gt;解析。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li><p>通过全类名获取定义此类的二进制字节流。</p></li><li><p>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</p></li><li><p>在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口。</p></li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><p>验证阶段也不是必须要执行的阶段。验证阶段主要由四个检验阶段组成：</p><ul><li>文件格式验证（Class 文件格式检查）</li><li>元数据验证（字节码语义检查）</li><li>字节码验证（程序语义检查）</li><li>符号引用验证（类的正确性检查）</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</p><p>这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 static 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化阶段是执行初始化方法 <clinit> ()方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</clinit></p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类加载器的主要作用就是加载 Java 类的字节码（ .class 文件）到 JVM 中（在内存中生成一个代表该类的 Class 对象）。 </p><h2 id="类加载器的种类"><a href="#类加载器的种类" class="headerlink" title="类加载器的种类"></a>类加载器的种类</h2><ol><li><p>启动类加载器，负责加载 JVM 的核心类库，如 rt.jar 和其他核心库位于<code>JAVA_HOME/jre/lib</code>目录下的类。</p></li><li><p>扩展类加载器，负责加载<code>JAVA_HOME/jre/lib/ext</code>目录下，或者由系统属性<code>java.ext.dirs</code>指定位置的类库，由<code>sun.misc.Launcher$ExtClassLoader</code> 实现。</p></li><li><p>应用程序类加载器，负责加载<br>classpath的类库，由<code>sun.misc.Launcher$AppClassLoader</code>实现。<br>我们编写的任何类都是由应用程序类加载器加载的，除非显式使用自定义<br>类加载器。</p></li><li><p>用户自定义类加载器，通常用于加载网络上的类、执行热部署（动态<br>加载和替换应用程序的组件），或者为了安全考虑，从不同的源加载类。</p></li></ol><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>一个类从被加载到虚拟机内存中开始，到从内存中卸载，整个生命周期需要经过七个阶段：加载 、验证、准备、解析、初始化、使用和卸载。相比于类加载机制多了使用和卸载。</p><h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p>双亲委派模型要求类加载器在加载类时，先委托父加载器尝试加载，只有父加载器无法加载时，子加载器才会加载。</p><p>这个过程会一直向上递归，也就是说，从子加载器到父加载器，再到更上层的加载器，一直到最顶层的启动类加载器。</p><p>启动类加载器会尝试加载这个类。如果它能够加载这个类，就直接返回；如果它不能加载这个类，就会将加载任务返回给委托它的子加载器。</p><p>子加载器尝试加载这个类。如果子加载器也无法加载这个类，它就会继续向下传递这个加载任务，依此类推。</p><p>直到某个加载器能够加载这个类，或者所有加载器都无法加载这个类，最终抛出<code>ClassNotFoundException</code>。</p><p>扩展：JVM 判定两个 Java 类是否相同的具体规则：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p><h2 id="双亲委派模型的优点"><a href="#双亲委派模型的优点" class="headerlink" title="双亲委派模型的优点"></a>双亲委派模型的优点</h2><p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载，也保证了 Java 的核心 API 不被篡改。如<code>java.lang.*</code>只能由 <code>Bootstrap ClassLoader</code> 加载，防止被篡改。</p><h2 id="如何破坏双亲委派"><a href="#如何破坏双亲委派" class="headerlink" title="如何破坏双亲委派"></a>如何破坏双亲委派</h2><p>重写 ClassLoader 的 <code>loadClass()</code> 方法。<br>如果不想打破双亲委派模型，就重写ClassLoader 类中的 <code>findClass()</code>方法，那些无法被父类加载器加载的类最终会通过这个方法被加载。</p><h2 id="破坏双亲委派模型的典型例子"><a href="#破坏双亲委派模型的典型例子" class="headerlink" title="破坏双亲委派模型的典型例子"></a>破坏双亲委派模型的典型例子</h2><ul><li>第一种：SPI 机制加载 JDBC 驱动。</li><li>第二种：热部署框架。</li></ul><h3 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h3><p>SPI 是 Java 的一种扩展机制，用于加载和注册第三方类库，常见于 JDBC、JNDI 等框架。</p><p>双亲委派模型会优先让父类加载器加载类，而 SPI 需要动态加载子类加载器中的实现。<br>根据双亲委派模型，<code>java.sql.Driver</code>类应该由父加载器加载，但父类加载器无法加载由子类加载器定义的驱动类，如 MySQL 的<code>com.mysql.cj.jdbc.Driver</code>。那么只能使用 SPI 机制通过 <code>META-INF/services</code> 文件指定服务提供者的实现类。</p><h3 id="Tomcat-的类加载机制"><a href="#Tomcat-的类加载机制" class="headerlink" title="Tomcat 的类加载机制"></a>Tomcat 的类加载机制</h3><p>Tomcat 基于双亲委派模型进行了一些扩展，主要的类加载器有：</p><ul><li><p>Bootstrap ClassLoader：加载 Java 的核心类库；</p></li><li><p>Catalina ClassLoader：加载 Tomcat 的核心类库；</p></li><li><p>Shared ClassLoader：加载共享类库，允许多个 Web 应用共享某些类库；</p></li><li><p>WebApp ClassLoader：加载 Web 应用程序的类库，支持多应用隔离和优先加载应用自定义的类库（破坏了双亲委派模型）。</p></li></ul><h1 id="解释执行与编译执行的区别？"><a href="#解释执行与编译执行的区别？" class="headerlink" title="解释执行与编译执行的区别？"></a>解释执行与编译执行的区别？</h1><ul><li>解释：将源代码逐行转换为机器码。</li><li>编译：将源代码一次性转换为机器码。</li></ul><p>一个是逐行，一个是一次性，再来说说解释执行和编译执行的区别：</p><ul><li>解释执行：程序运行时，将源代码逐行转换为机器码，然后执行。</li><li>编译执行：程序运行前，将源代码一次性转换为机器码，然后执行。</li></ul><p>Java 一般被称为“解释型语言”，因为 Java 代码在执行前，需要先将源代码编译成字节码，然后在运行时，再由 JVM 的解释器“逐行”将字节码转换为机器码，然后执行。这也是 Java 被诟病“慢”的主要原因。</p><p>但 JIT 的出现打破了这种刻板印象，JVM 会将热点代码（即运行频率高的代码）编译后放入CodeCache，当下次执行再遇到这段代码时，会从<br>CodeCache 中直接读取机器码，然后执行。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM调优</title>
    <link href="/2025/02/05/JVM%E8%B0%83%E4%BC%98/"/>
    <url>/2025/02/05/JVM%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h1 id="性能监测的命令行工具"><a href="#性能监测的命令行工具" class="headerlink" title="性能监测的命令行工具"></a>性能监测的命令行工具</h1><p>操作系统层面：top、vmstat、iostat、netstat 等命令，可以监控系统整体的资源使用情况，比如说内存、CPU、IO 使用情况、网络使用情况。</p><p>JDK 自带的命令行工具层面，jps、jstat、jinfo、jmap、jhat、jstack、jcmd 等，可以查看 JVM 运行时信息、内存使用情况、堆栈信息等。</p><h2 id="jmap-使用"><a href="#jmap-使用" class="headerlink" title="jmap 使用"></a>jmap 使用</h2><p>使用 <code>jmap -heap &lt;pid&gt;</code> 查看堆内存摘要，包括新生代、老年代、元空间等。</p><p>使用 <code>jmap -histo &lt;pid&gt;</code> 查看对象分布。</p><p>生成堆转储文件：<code>jmap -dump:format=b file=&lt;path&gt;&lt;pid&gt;</code>。</p><h1 id="可视化的性能监控工具"><a href="#可视化的性能监控工具" class="headerlink" title="可视化的性能监控工具"></a>可视化的性能监控工具</h1><p>JConsole：JDK 自带的监控工具，可以用来监视 Java 应用程序的运行状态，包括内存使用、线程状态、类加载、GC 等。</p><p>VisualVM：一个基于 NetBeans 的可视化工具，在很长一段时间内，VisualVM 都是 Oracle 官方主推的故障处理工具。集成了多个 JDK 命令行工<br>具的功能，非常友好。</p><p>Java Mission Control：JMC 最初是 JRockit VM 中的诊断工具，但在Oracle JDK7 Update 40 以后，就绑定到了 HotSpot VM 中。不过后来又被<br>Oracle 开源出来作为了一个单独的产品。</p><p>arthas：阿里巴巴开源的 Java 诊断工具，主要用于线上的应用诊断；支持在不停机的情况下进行诊断；可以提供包括JVM信息查看、监控、Trace 命令、反编译等功能。</p><h1 id="CPU-高占用排查？"><a href="#CPU-高占用排查？" class="headerlink" title="CPU 高占用排查？"></a>CPU 高占用排查？</h1><p>首先，使用 top 命令查看 CPU 占用情况，找到占用 CPU 较高的进程 ID。</p><p>接着，使用 jstack 命令查看对应进程的线程堆栈信息。<br><code>jstack -l &lt;pid&gt; &gt; thread-dump.txt</code></p><p>这个命令会将所有线程的堆栈信息输出到 thread-dump.txt 文件中。</p><p>然后再使用 top 命令查看进程中线程的占用情况，找到占用 CPU 较高的线程 ID。<br><code>top -H -p &lt;pid&gt;</code></p><p>接着在 jstack 的输出中搜索这个十六进制的线程 ID，找到对应的堆栈信息。</p><h1 id="内存飙高问题排查？"><a href="#内存飙高问题排查？" class="headerlink" title="内存飙高问题排查？"></a>内存飙高问题排查？</h1><p>内存飚高一般是因为创建了大量的 Java 对象导致的，如果持续飙高则说明垃圾回收跟不上对象创建的速度，或者内存泄漏导致对象无法回收。</p><p>第一，先观察垃圾回收的情况，可以通过 <code>jstat -gc PID 1000</code> 查看GC 次数和时间。<br>或者使用 <code>jmap -histo PID | head -20</code> 查看堆内存占用空间最大的前 20 个对象类型。</p><p>第二步，通过 jmap 命令 dump 出堆内存信息。</p><p>第三步，使用可视化工具分析 dump 文件，比如说 VisualVM，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定<br>位具体问题。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GC机制与常见垃圾回收器</title>
    <link href="/2025/02/05/GC%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <url>/2025/02/05/GC%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="堆空间的基本结构"><a href="#堆空间的基本结构" class="headerlink" title="堆空间的基本结构"></a>堆空间的基本结构</h1><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存。</p><h1 id="对象分配与回收基本原则"><a href="#对象分配与回收基本原则" class="headerlink" title="对象分配与回收基本原则"></a>对象分配与回收基本原则</h1><p>对象优先在 Eden 区分配<br>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><p>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 分配担保机制 把新生代的对象提前转移到老年代中去，老年代上的空间足够存allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。</p><p>大对象直接进入老年代</p><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。</p><p>长期存活的对象将进入老年代</p><p>大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h1 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h1><p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p><h1 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</p><p>所谓对象之间的相互引用问题，假如对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p>这也是 G1、CMS 等主流垃圾收集器使用的主要算法。</p><h3 id="哪些对象可以作为-GC-Roots"><a href="#哪些对象可以作为-GC-Roots" class="headerlink" title="哪些对象可以作为 GC Roots"></a>哪些对象可以作为 GC Roots</h3><p>所谓的GC Roots，就是一组必须活跃的引用，它们是程序运行时的起点，是一切引用链的源头。在 Java 中，GC Roots 包括以下几种：</p><ul><li>虚拟机栈中的引用（方法的参数、局部变量等）</li><li>本地方法栈中 JNI 的引用</li><li>类静态变量</li><li>运行时常量池中的常量（String 或 Class 类型）</li></ul><h4 id="本地方法栈中-JNI-的引用？"><a href="#本地方法栈中-JNI-的引用？" class="headerlink" title="本地方法栈中 JNI 的引用？"></a>本地方法栈中 JNI 的引用？</h4><p>Java 通过 JNI 提供了一种机制，允许 Java 代码调用本地代码（通常是 C 或C++ 编写的代码）。</p><p>当调用 Java 方法时，虚拟机会创建一个栈帧并压入虚拟机栈，而当它调用本地方法时，虚拟机会通过动态链接直接调用指定的本地方法。</p><p>JNI 引用是在 Java 本地接口代码中创建的引用，这些引用可以指向 Java 堆中的对象。它在本地方法执行期间保持 Java 对象活跃，可以被认为是 GC Roots。</p><p>一旦 JNI 方法执行完毕，除非这个引用是全局的，否则它指向的对象将会被作为垃圾回收掉（假设没有其他地方再引用这个对象）。</p><h4 id="对象可以被回收，就代表一定会被回收吗？"><a href="#对象可以被回收，就代表一定会被回收吗？" class="headerlink" title="对象可以被回收，就代表一定会被回收吗？"></a>对象可以被回收，就代表一定会被回收吗？</h4><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><p>垃圾收集算法主要有三种，分别是标记-清除算法、标记-复制算法和标记-整理算法。</p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>标记-清除算法分为两个阶段：</p><ul><li>标记：标记所有需要回收的对象</li><li>清除：回收所有被标记的对象</li></ul><p>优点是实现简单，缺点是回收过程中会产生内存碎片。</p><h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>标记-复制算法可以解决标记-清除算法的内存碎片问题，因为它将内存空间划分为两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后清理掉这一块。</p><p>缺点是浪费了一半的内存空间；不适合老年代：如果存活对象数量比较大，复制性能会变得很差。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记-整理算法是标记-清除复制算法的升级版，它不再划分内存空间，而是将存活的对象向内存的一端移动，然后清理边界以外的内存。</p><p>缺点是移动对象的成本比较高。适合老年代这种GC频率比较低的场景。</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>分代收集算法是目前主流的垃圾收集算法，它根据对象存活周期的不同将内存划分为几块，一般分为新生代和老年代。</p><p>新生代用复制算法，因为大部分对象生命周期短。老年代用标记-整理算法，因为对象存活率较高。</p><h3 id="提问：-为什么使用分代收集算法？"><a href="#提问：-为什么使用分代收集算法？" class="headerlink" title="提问： 为什么使用分代收集算法？"></a>提问： 为什么使用分代收集算法？</h3><p>分代收集算法的核心思想是根据对象的生命周期优化垃圾回收。</p><p>新生代的对象生命周期短，使用复制算法可以快速回收。老年代的对象生命周期长，使用标记-整理算法可以减少移动对象的成本。</p><h3 id="提问：-标记复制的标记过程和复制过程会不会停顿？"><a href="#提问：-标记复制的标记过程和复制过程会不会停顿？" class="headerlink" title="提问： 标记复制的标记过程和复制过程会不会停顿？"></a>提问： 标记复制的标记过程和复制过程会不会停顿？</h3><p>在标记-复制算法 中，标记阶段和复制阶段都会触发STW。</p><ul><li>标记阶段停顿是为了保证对象的引用关系不被修改。</li><li>复制阶段停顿是防止对象在复制过程中被修改。</li></ul><h3 id="提问：-Minor-GC、Major-GC、Mixed-GC、Full-GC-都是什么意思？"><a href="#提问：-Minor-GC、Major-GC、Mixed-GC、Full-GC-都是什么意思？" class="headerlink" title="提问： Minor GC、Major GC、Mixed GC、Full GC 都是什么意思？"></a>提问： Minor GC、Major GC、Mixed GC、Full GC 都是什么意思？</h3><ul><li><p>Minor GC 也称为 Young GC，是指发生在年轻代的垃圾收集。年轻代包含Eden 区以及两个Survivor 区。如果 Eden 区没有足够的空间时，就会触发 Young GC 来清理新生代。</p></li><li><p>Major GC 也称为 Old GC，主要指的是发生在老年代的垃圾收集。是 CMS的特有行为。</p></li><li><p>Mixed GC 是 G1 垃圾收集器特有的一种 GC 类型，它在一次 GC 中同时清理年轻代和部分老年代。</p></li><li><p>Full GC 是最彻底的垃圾收集，涉及整个 Java 堆和方法区。它是最耗时的GC，通常在 JVM 压力很大时发生。在进行 Young GC 的时候，如果发现老年代可用的连续内存空间 &lt; 新生代历次 Young GC 后升入老年代的对象总和的平均大小，说明本次 Young GC后升入老年代的对象大小，可能超过了老年代当前可用的内存空间，就会触发 Full GC。<br>执行 Young GC 后老年代没有足够的内存空间存放转入的对象，会立即触发一次 Full GC。Full GC 会从 GC Root 出发，标记所有可达对象。新生代使用复制算法，清空 Eden 区。老年代使用标记-整理算法，回收对象并消除碎片。停顿时间较长，会影响系统响应性能。</p></li></ul><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><p>JVM的垃圾收集器主要分为两大类：分代收集器和分区收集器，分代收集器的代表是 CMS，分区收集器的代表是 G1 和 ZGC。</p><h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><p>Serial 收集器是最基础、历史最悠久的收集器。<br>如同它的名字（串行），它是一个单线程工作的收集器，使用一个处理器或一条收集线程去完成垃圾收集工作。并且进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束——这就是所谓的“Stop The World”。</p><h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p><h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><p>ParNew 收集器实质上是 Serial 收集器的多线程并行版本，使用多条线程进行垃圾收集。</p><h2 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h2><p>Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，基于标记-整理算法实现，使用多条 GC 线程在 STW 期间同时进行垃圾回收。</p><h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h2><p>Parallel Scavenge 收集器是一款新生代收集器，基于标记-复制算法实现，也能够并行收集。</p><p>和 ParNew 有些类似，但 Parallel Scavenge 主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是 CPU 用于运行用户代码的时间和总消耗时间的比值，比值越大，说明垃圾收集的占比越小。</p><p>这是 JDK1.8 默认收集器。JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old。</p><h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><p>CMS 是一种低延迟的垃圾收集器，采用标记-清除算法，分为初始标记、并发标记、重新标记和并发清除四个阶段，优点是垃圾回收线程和应用线程同时运行，停顿时间短，适合延迟敏感的应用，但容易产生内存碎片，可能触发 Full GC。</p><ul><li><p>初始标记： 短暂停顿，标记直接与 root 相连的对象（根对象）；</p></li><li><p>并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p></li><li><p>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p></li><li><p>并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</p></li></ul><p>remark 阶段通常会结合三色标记法来执行，确保在并发标记期间所有存活对象都被正确标记。目的是修正并发标记阶段中可能遗漏的对象引用变化。</p><h2 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h2><p>G1 是一种面向大内存、高吞吐场景的垃圾收集器，它将堆划分为多个小的 Region，通过标记-整理算法，避免了内存碎片问题。优点是停顿时间可控，适合大堆场景，但调优较复杂。</p><p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。</p><ul><li><p>初始标记： 短暂停顿（Stop-The-World，STW），标记从 GC Roots 可直接引用的对象，即标记所有直接可达的活跃对象</p></li><li><p>并发标记：与应用并发运行，标记所有可达对象。 这一阶段可能持续较长时间，取决于堆的大小和对象的数量。</p></li><li><p>最终标记： 短暂停顿（STW），处理并发标记阶段结束后残留的少量未处理的引用变更。</p></li><li><p>筛选回收：根据标记结果，选择回收价值高的区域，复制存活对象到新区域，回收旧区域内存。这一阶段包含一个或多个停顿（STW），具体取决于回收的复杂度。</p></li></ul><p>从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。</p><h2 id="ZGC-收集器"><a href="#ZGC-收集器" class="headerlink" title="ZGC 收集器"></a>ZGC 收集器</h2><p>ZGC 是 JDK 11 时引入的一款低延迟的垃圾收集器，与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。ZGC 可以将暂停时间控制在几毫秒以内，且暂停时间不受堆内存大小的影响，出现 Stop The World 的情况会更少，但代价是牺牲了一些吞吐量。ZGC 最大支持 16TB 的堆内存。</p><p>它通过并发标记和重定位来避免大部分    Stop-The-World 停顿，主要依赖指针染色来管理对象状态。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象内存问题</title>
    <link href="/2025/02/05/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <url>/2025/02/05/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>对象的内存布局是由 Java 虚拟机规范定义的，但具体的实现细节各有不<br>同，如 HotSpot 和 OpenJ9 就不一样。</p><p>就拿我们常用的 HotSpot 来说吧。<br>对象在内存中包括三部分：对象头、实例数据和对齐填充。</p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>对象头是对象存储在内存中的元信息，包含了Mark Word、类型指针等信<br>息。<br>Mark Word 存储了对象的运行时状态信息，包括锁、哈希值、GC 标记<br>等。在 64 位操作系统下占 8 个字节，32 位操作系统下占 4 个字节。<br>类型指针指向对象所属类的元数据，也就是 Class 对象，用来支持多态、<br>方法调用等功能。<br>除此之外，如果对象是数组类型，还会有一个额外的数组长度字段。占 4<br>个字节。</p><p>类型指针会被压缩吗？<br>类型指针可能会被压缩，以节省内存空间。比如说在开启压缩指针的情况下<br>占 4 个字节，否则占 8 个字节。在 JDK 8 中，压缩指针默认是开启的。</p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>实例数据是对象实际的字段值，也就是成员变量的值，按照字段在类中声<br>明的顺序存储。JVM 会对这些数据进行对齐&#x2F;重排，以提高内存访问速度。</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>由于 JVM 的内存模型要求对象的起始地址是 8 字节对齐（64 位 JVM<br>中），因此对象的总大小必须是 8 字节的倍数。<br>如果对象头和实例数据的总长度不是 8 的倍数，JVM 会通过填充额外的<br>字节来对齐。</p><p>CPU 进行内存访问时，一次寻址的指针大小是 8 字节，正好是 L1 缓存<br>行的大小。如果不进行内存对齐，则可能出现跨缓存行访问，导致额外的缓<br>存行加载，CPU 的访问效率就会降低。</p><h3 id="提问：-new-Object-对象的内存大小？"><a href="#提问：-new-Object-对象的内存大小？" class="headerlink" title="提问： new Object() 对象的内存大小？"></a>提问： new Object() 对象的内存大小？</h3><p>一般来说，目前的操作系统都是 64 位的，并且 JDK 8 中的压缩指针是默<br>认开启的，因此在 64 位的 JVM 上，new Object()的大小是 16 字节（12<br>字节的对象头 + 4 字节的对齐填充）。</p><p>对象头的大小是固定的，在 32 位 JVM 上是 8 字节，在 64 位 JVM 上是<br>16 字节；如果开启了压缩指针，就是 12 字节。<br>实例数据的大小取决于对象的成员变量和它们的类型。对于new<br>Object()来说，由于默认没有成员变量，因此我们可以认为此时的实例数<br>据大小是 0。</p><p>文章推荐阅读：<a href="%22https://www.cnblogs.com/dijia478/p/14677243.html%22">Object o &#x3D; new Object()占多少个字节？</a></p><h1 id="JVM访问对象的方法？"><a href="#JVM访问对象的方法？" class="headerlink" title="JVM访问对象的方法？"></a>JVM访问对象的方法？</h1><p>主流的方式有两种：句柄和直接指针。HotSpot 虚拟机主要使用直接指针来进行对象访问。</p><p>句柄是通过一个中间的句柄表来定位对象的，而直接指针则是通过引用直接指向对象的内存地址。优点是，对象被移动时只需要修改句柄表中的指针，而不需要修改对象引用本身。</p><p>在直接指针访问中，引用直接存储对象的内存地址；对象的实例数据和类型信息都存储在堆中固定的内存区域。优点是访问速度更快，因为少了一次句柄的寻址操作。缺点是如果对象在内存中移动，引用需要更新为新的地址。</p><h1 id="对象的四种引用？"><a href="#对象的四种引用？" class="headerlink" title="对象的四种引用？"></a>对象的四种引用？</h1><ol><li><p>强引用<br>强引用是 Java 中最常见的引用类型。使用 new 关键字赋值的引用就是强引用，只要强引用关联着对象，垃圾收集器就不会回收这部分对象，即使内存不足。</p></li><li><p>软引用</p></li></ol><p>软引用于描述一些非必须对象，通过 <code>SoftReference</code> 类实现。软引用的对<br>象在内存不足时会被回收。</p><ol start="3"><li>弱引用</li></ol><p>弱引用用于描述一些短生命周期的非必须对象，如<br><code>ThreadLocal</code>中的<code>Entry</code>，就是通<code>WeakReference</code> 类实现的。弱引用的对象会在下一次垃圾回收时会被回收，不论内存是否充足。</p><ol start="4"><li>虚引用</li></ol><p>虚引用主要用来跟踪对象被垃圾回收的过程，通过 <code>PhantomReference</code> 类实<br>现。虚引用的对象在任何时候都可能被回收。</p><h1 id="对象一定分配在堆中吗？"><a href="#对象一定分配在堆中吗？" class="headerlink" title="对象一定分配在堆中吗？"></a>对象一定分配在堆中吗？</h1><p>不一定。<br>默认情况下，Java 对象是在堆中分配的，但 JVM 会进行逃逸分析，来判断对象的生命周期是否只在方法内部，如果是的话，这个对象可以在栈上分配。</p><h2 id="什么是逃逸分析？"><a href="#什么是逃逸分析？" class="headerlink" title="什么是逃逸分析？"></a>什么是逃逸分析？</h2><p>逃逸分析是一种 JVM 优化技术，用来分析对象的作用域和生命周期，判断对象是否逃逸出方法或线程。<br>可以通过分析对象的引用流向，判断对象是否被方法返回、赋值到全局变量、传递到其他线程等，来确定对象是否逃逸。如果对象没有逃逸，就可以进行栈上分配、同步消除、标量替换等优化，以提高程序的性能。</p><h2 id="逃逸具体是指什么？"><a href="#逃逸具体是指什么？" class="headerlink" title="逃逸具体是指什么？"></a>逃逸具体是指什么？</h2><p>根据对象逃逸的范围，可以分为方法逃逸和线程逃逸。</p><p>当对象被方法外部的代码引用，生命周期超出了方法的范围，那么对象就必须分配在堆中，由垃圾收集器管理。</p><h2 id="逃逸分析会带来什么好处？"><a href="#逃逸分析会带来什么好处？" class="headerlink" title="逃逸分析会带来什么好处？"></a>逃逸分析会带来什么好处？</h2><p>主要有三个。</p><p>第一，如果确定一个对象不会逃逸，那么就可以考虑栈上分配，对象占用的内存随着栈帧出栈后销毁，这样一来，垃圾收集的压力就降低很多。</p><p>第二，线程同步需要加锁，加锁就要占用系统资源，如果逃逸分析能够确定一个对象不会逃逸出线程，那么这个对象就不用加锁，从而减少线程同步<br>的开销。</p><p>第三，如果对象的字段在方法中独立使用，JVM<br>可以将对象分解为标量变量，避免对象分配。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM内存结构</title>
    <link href="/2025/02/05/JVM%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/02/05/JVM%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM-的结构体系"><a href="#JVM-的结构体系" class="headerlink" title="JVM 的结构体系"></a>JVM 的结构体系</h1><p>JVM 可以大致划分为 类加载器、运行时数据区、执行引擎</p><ul><li><p>类加载器负责负责从文件系统、网络或其他来源加载 Class 文件，将<br>Class 文件中的二进制数据读入到内存当中。</p></li><li><p>运行时数据区，JVM 在执行 Java 程序时，需要在内存中分配空间来处<br>理各种数据，这些内存区域按照 Java 虚拟机规范可以划分为方法区、堆、<br>虚拟机栈、程序计数器和本地方法栈。</p></li><li><p>执行引擎负责执行字节码。它包括一个虚拟处理<br>器、即时编译器 JIT 和垃圾回收器。</p></li></ul><h1 id="JVM-运行时数据区详细内容"><a href="#JVM-运行时数据区详细内容" class="headerlink" title="JVM 运行时数据区详细内容"></a>JVM 运行时数据区详细内容</h1><p>线程私有的部分：虚拟机栈、程序计数器、本地方法栈</p><p>线程共享的部分：方法区、堆、直接内存(非运行时数据区的一部分)</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器也被称为 PC 寄存器，是一块较小的内存空间。它可以看作是当<br>前线程所执行的字节码行号指示器。</p><p>⚠️ 注意：程序计数器是唯一一个不会出现 OutOfMemoryError<br>的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。</p><p>除了一些 Native 方法调用是通过本地方法栈实现的，其他所<br>有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域<br>比如程序计数器配合）。</p><p>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、<br>动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的<br>数据结构，只支持出栈和入栈两种操作。</p><p>局部变量表主要存放了编译期可知的各种数据类型、对象引用。</p><h3 id="提问：一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变"><a href="#提问：一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变" class="headerlink" title="提问：一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变"></a>提问：一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变</h3><p>量？</p><ul><li><p>对于静态方法，由于不需要访问实例对象 this，因此在局部变量表中不会有<br>任何变量。</p></li><li><p>对于非静态方法，即使是一个完全空的方法，局部变量表中也会有一个用<br>于存储 this 引用的变量。this 引用指向当前实例对象，在方法调用时被隐式<br>传入。</p></li></ul><p>操作数栈 主要作为方法调用的中转站使用，用于存放方法执行过程中产<br>生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</p><p>动态链接 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池<br>里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，<br>需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。<br>动态链接的作用就是为了将符号引用转换为调用方法的直接引用，<br>这个过程也被称为 动态连接 。</p><p>程序运行中栈可能出现的两种错误：<br><code>StackOverFlowError</code>： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈<br>的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。<br><code>OutOfMemoryError</code>： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，<br>则抛出<code>OutOfMemoryError</code>异常。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与虚拟机栈相似，区别在于虚拟机栈是为 JVM 执行 Java 编写的<br>方法服务的，而本地方法栈是为 Java 调用本地 native 方法服务的，通常由<br>C&#x2F;C++ 编写。在本地方法栈中，主要存放了 native 方法的局部变量、动态链接和方法出<br>口等信息。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。也会出现<br><code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是 JVM 中最大的一块内存区域，被所有线程共享，在 JVM 启动时创建，<br>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。<br>从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，<br>所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。<br>进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p>堆这里最容易出现的就是 <code>OutOfMemoryError</code> 错误，并且出现这种错误之后的表现形式还会有几种，<br>比如：<br><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code>：当 JVM 花太多时间执行垃圾回收并且<br>只能回收很少的堆空间时，就会发生此错误。</p><p><code>java.lang.OutOfMemoryError: Java heap space</code> :假如在创建新的对象时, 堆内存中的空间不足以存放<br>新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-Xmx参数配置，若没有特别配置，将会使用默认值。)</p><h3 id="提问：-堆和栈的区别是什么？"><a href="#提问：-堆和栈的区别是什么？" class="headerlink" title="提问： 堆和栈的区别是什么？"></a>提问： 堆和栈的区别是什么？</h3><p>堆属于线程共享的内存区域，几乎所有 new 出来的对象都会堆上分配，生命<br>周期不由单个方法调用所决定，可以在方法调用结束后继续存在，直到不再<br>被任何变量引用，最后被垃圾收集器回收。</p><p>栈属于线程私有的内存区域，主要存储局部变量、方法参数、对象引用<br>等，通常随着方法调用的结束而自动释放，不需要垃圾收集器处理。</p><h3 id="提问：-堆内存是如何分配的？"><a href="#提问：-堆内存是如何分配的？" class="headerlink" title="提问： 堆内存是如何分配的？"></a>提问： 堆内存是如何分配的？</h3><p>在堆中为对象分配内存时，主要使用两种策略：指针碰撞和空闲列表。</p><p>指针碰撞适用于管理简单、碎片化较少的内存区域，如年轻代；而空闲列<br>表适用于内存碎片化较严重或对象大小差异较大的场景如老年代。</p><ul><li>什么是指针碰撞？</li></ul><p>假设堆内存是一个连续的空间，分为两个部分，一部分是已经被使用的内<br>存，另一部分是未被使用的内存。<br>在分配内存时，Java 虚拟机会维护一个指针，指向下一个可用的内存地<br>址，每次分配内存时，只需要将指针向后移动一段距离，如果没有发生碰<br>撞，就将这段内存分配给对象实例。</p><ul><li>什么是空闲列表？</li></ul><p>JVM 维护一个列表，记录堆中所有未占用的内存块，每个内存块都记录有<br>大小和地址信息。<br>当有新的对象请求内存时，JVM 会遍历空闲列表，寻找足够大的空间来<br>存放新对象。<br>分配后，如果选中的内存块未被完全利用，剩余的部分会作为一个新的内<br>存块加入到空闲列表中</p><h3 id="提问：-new对象时，堆会发生内存抢占吗？-JVM如何解决堆内存分配竞争问题？"><a href="#提问：-new对象时，堆会发生内存抢占吗？-JVM如何解决堆内存分配竞争问题？" class="headerlink" title="提问： new对象时，堆会发生内存抢占吗？ JVM如何解决堆内存分配竞争问题？"></a>提问： new对象时，堆会发生内存抢占吗？ JVM如何解决堆内存分配竞争问题？</h3><p>new 对象时，指针会向右移动一个对象大小的距离，假如一个线程 A 正在<br>给字符串对象 s 分配内存，另外一个线程 B 同时为 ArrayList 对象 l 分配内<br>存，两个线程就发生了抢占。</p><p>为了解决堆内存分配的竞争问题，JVM 为每个线程保留了一小块内存空<br>间，被称为 TLAB，也就是线程本地分配缓冲区，用于存放该线程分配的对<br>象。<br>当线程需要分配对象时，直接从 TLAB 中分配。只有当 TLAB 用尽或对<br>象太大需要直接在堆中分配时，才会使用全局分配指针。</p><h3 id="提问：-内存溢出与内存泄漏的关系？"><a href="#提问：-内存溢出与内存泄漏的关系？" class="headerlink" title="提问： 内存溢出与内存泄漏的关系？"></a>提问： 内存溢出与内存泄漏的关系？</h3><p>内存溢出，俗称 OOM，是指当程序请求分配内存时，由于没有足够的内存空间，从而抛出 <code>OutOfMemoryError</code>。</p><p>内存泄漏是指程序在使用完内存后，未能及时释放，导致占用的内存无法再被使用。随着时间的推移，内存泄漏会导致可用内存逐渐减少，最终导致内存溢出。</p><p>内存泄漏的可能原因：</p><ul><li><p>静态的集合中添加的对象越来越多，但却没有及时清理；静态变量的生命周期与应用程序相同，如果静态变量持有对象的引用，这些对象将无法被 GC 回收。</p></li><li><p>单例模式下对象持有的外部引用无法及时释放；单例对象在整个应用程序的生命周期中存活，如果单例对象持有其他对象的引用，这些对象将无法被回收。</p></li><li><p>数据库、IO、Socket 等连接资源没有及时关闭；</p></li><li><p>ThreadLocal 的引用未被清理，线程退出后仍然持有对象引用；在线程执行完后，要调用 ThreadLocal 的 remove 方法进行清理。</p></li></ul><h3 id="提问：-内存泄漏处理："><a href="#提问：-内存泄漏处理：" class="headerlink" title="提问： 内存泄漏处理："></a>提问： 内存泄漏处理：</h3><p>可视化的监控工具 VisualVM，配合 JDK 自带的 jstack 等命令行工具进行了排查。</p><p>第一步，使用 jps -l 查看运行的 Java 进程 ID。</p><p>第二步，使用top -p [pid] 查看进程使用 CPU 和内存占用情况。</p><p>第三步，使用 top -Hp [pid] 查看进程下的所有线程占用 CPU 和内存情况。</p><p>第四步，抓取线程栈：jstack -F 29452 &gt; 29452.txt，可以多抓几次做个对比。看看有没有线程死锁、死循环或长时间等待这些问题。</p><p>第五步，可以使用jstat -gcutil [pid] 5000 10 每隔 5 秒输出 GC信息，输出 10 次，查看 YGC 和 Full GC 次数。通常会出现 YGC 不增加或增加缓慢，而 Full GC 增加很快。或使用 jstat -gccause [pid] 5000 输出 GC 摘要信息。或使用 jmap -heap [pid] 查看堆的摘要信息，关注老年代内存使用是否达到阀值，若达到阀值就会执行 Full GC。如果发现 Full GC 次数太多，就很大概率存在内存泄漏了。</p><p>第六步，生成 dump 文件，然后借助可视化工具分析哪个对象非常多，基本就能定位到问题根源了。<br>执行命令 jmap -dump:format&#x3D;b,file&#x3D;heap.hprof 10025 会输出进程 10025 的堆快照信息，保存到文件 heap.hprof 中。</p><p>第七步，使用图形化工具分析，如 JDK 自带的 VisualVM，从菜单 &gt; 文件 &gt; 装入 dump 文件。</p><h3 id="提问：内存溢出处理："><a href="#提问：内存溢出处理：" class="headerlink" title="提问：内存溢出处理："></a>提问：内存溢出处理：</h3><p>通过导出堆转储文件进行分析发现的。</p><p>首先使用 jmap 命令手动生成 Heap Dump 文件：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">jmap -dump:<span class="hljs-keyword">format</span>=b,<span class="hljs-keyword">file</span>=heap.hprof &lt;<span class="hljs-keyword">pid</span>&gt;<br></code></pre></td></tr></table></figure><p>然后使用 MAT、JProfiler 等工具进行分析，查看内存中的对象占用情况。<br>一般来说：<br>如果生产环境的内存还有很多空余，可以适当增大堆内存大小来解决，例如 -Xmx4g 参数。或者检查代码中是否存在内存泄漏，如未关闭的资源、长生命周期的对象等。<br>之后，在本地进行压力测试，模拟高负载情况下的内存表现，确保修改有效，且没有引入新的问题。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域并不真实存在，是各个线程共享的内存区域。<br>用于存储已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码缓存<br>等。</p><p>运行时常量池<br>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。<br>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，<br>当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p><p>字符串常量池<br>字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，<br>主要目的是为了避免字符串的重复创建。<br>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<br><code>StringTable</code> 可以简单理解为一个固定大小的<code>HashTable</code> ，容量为 <code>StringTableSize</code><br>（可以通过 <code>-XX:StringTableSize</code> 参数来设置），<br>保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。<br>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动到了 Java 堆中。</p><h3 id="提问：-方法区和永久代以及元空间是什么关系呢？"><a href="#提问：-方法区和永久代以及元空间是什么关系呢？" class="headerlink" title="提问： 方法区和永久代以及元空间是什么关系呢？"></a>提问： 方法区和永久代以及元空间是什么关系呢？</h3><p>方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，<br>这里的类就可以看作是永久代和元空间，接口可以看作是方法区，<br>也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。<br>并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p><h3 id="提问：-为什么要将永久代替换为元空间？"><a href="#提问：-为什么要将永久代替换为元空间？" class="headerlink" title="提问： 为什么要将永久代替换为元空间？"></a>提问： 为什么要将永久代替换为元空间？</h3><ul><li><p>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整（也就是受到 JVM 内存的限制），<br>而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p></li><li><p>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了,<br>而由系统的实际可用空间来控制，这样能加载的类就更多了。</p></li><li><p>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西,<br>合并之后就没有必要额外的设置这么一个永久代的地方了。</p></li><li><p>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p></li></ul><h3 id="提问：-变量存在-堆栈-的哪些区域？"><a href="#提问：-变量存在-堆栈-的哪些区域？" class="headerlink" title="提问： 变量存在 堆栈 的哪些区域？"></a>提问： 变量存在 堆栈 的哪些区域？</h3><ul><li><p>对于局部变量，它存储在当前方法栈帧中的局部变量表中。当方法执行完<br>毕，栈帧被回收，局部变量也会被释放。</p></li><li><p>对于静态变量来说，它存储在 Java 虚拟机规范中的方法区中，在 Java 7<br>中是永久代，在 Java8 及以后 是元空间。</p></li></ul><h3 id="提问：-对象创建至销毁的流程？"><a href="#提问：-对象创建至销毁的流程？" class="headerlink" title="提问： 对象创建至销毁的流程？"></a>提问： 对象创建至销毁的流程？</h3><p>使用 new 关键字创建一个对象时，JVM 首先会检查 new 指令的参数<br>是否能在常量池中定位到类的符号引用，然后检查这个符号引用代表的类是<br>否已被加载、解析和初始化。如果没有，就先执行类加载。</p><p>如果已经加载，JVM 会为对象分配内存完成初始化，比如数值类型的成<br>员变量初始值是 0，布尔类型是 false，对象类型是 null。</p><p>接下来会设置对象头，里面包含了对象是哪个类的实例、对象的哈希码、<br>对象的 GC 分代年龄等信息。</p><p>最后，JVM 会执行构造方法 <init> 完成赋值操作，将成员变量赋值为<br>预期的值，比如 int age &#x3D; 18，这样一个对象就创建完成了。</init></p><p>当对象不再被任何引用指向时，就会变成垃圾。垃圾收集器会通过可达性分<br>析算法判断对象是否存活，如果对象不可达，就会被回收。</p><p>垃圾收集器通过标记清除、标记复制、标记整理等算法来回收内存，将对<br>象占用的内存空间释放出来。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2025/02/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2025/02/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Logstash安装与使用</title>
    <link href="/2025/02/02/Logstash%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/02/02/Logstash%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Logstash"><a href="#什么是-Logstash" class="headerlink" title="什么是 Logstash?"></a>什么是 Logstash?</h1><p>Logstash 是一种开源的服务器端数据处理管道，能够从多个来源采集数据，转换数据，然后将数据发送到您喜欢的 “存储库” ，如 Elasticsearch 中</p><h1 id="下载与安装-Logstash"><a href="#下载与安装-Logstash" class="headerlink" title="下载与安装 Logstash"></a>下载与安装 Logstash</h1><p>访问 Logstash 官网历史版本下载链接：<a href="https://www.elastic.co/downloads/past-releases">https://www.elastic.co/downloads/past-releases</a></p><ol><li><p>选择 Logstash;</p></li><li><p>选择适当版本（需要与 es 版本保持一致，防止兼容性问题）；</p></li><li><p>点击 Download 下载压缩包；</p></li><li><p>下载完成后，解压到指定位置</p></li></ol><h2 id="安装-logstash-input-jdbc"><a href="#安装-logstash-input-jdbc" class="headerlink" title="安装 logstash-input-jdbc"></a>安装 logstash-input-jdbc</h2><p>logstash-input-jdbc 是 Logstash 的一个插件，它允许用户通过 JDBC (Java Database Connectivity) 从关系型数据库中读取数据，并将这些数据作为事件输入到 Logstash 中。这个插件非常适合用于从数据库中提取日志信息、监控数据或其他类型的数据，并将其导入到 Elasticsearch 或其他目标系统中进行进一步处理或分析。</p><p>打开命令行工具，执行 cd 命令，进入到 Logstash 安装目录的 &#x2F;bin 文件夹下，执行如下命令来安装 logstash-input-jdbc 插件：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">.\logstash-<span class="hljs-keyword">plugin</span> install logstash-<span class="hljs-keyword">input</span>-jdbc<br></code></pre></td></tr></table></figure><p>若提示 <code>Installation successful</code> 信息，说明插件安装成功了：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202105833195.png"></p><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch 分词器</title>
    <link href="/2025/02/02/Elasticsearch%20%E5%88%86%E8%AF%8D%E5%99%A8/"/>
    <url>/2025/02/02/Elasticsearch%20%E5%88%86%E8%AF%8D%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>倒排索引（Inverted Index）是 Elasticsearch 全文搜索能力的基础，也是搜索引擎普遍采用的一种高效数据结构。通过倒排索引，Elasticsearch 可以快速定位包含某个关键词的文档，极大地提升搜索性能。</p><h1 id="什么是倒排索引？"><a href="#什么是倒排索引？" class="headerlink" title="什么是倒排索引？"></a>什么是倒排索引？</h1><p>倒排索引是从关键词到文档的映射。它与传统的正排索引不同，正排索引存储的是文档及其内容，而倒排索引反其道而行之，存储的是每个关键词以及包含这些关键词的文档信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202102259381.jpg"></p><p>假设我们有以下文档，分别对应一条中文句子：</p><p>文档 1: Elasticsearch 是分布式引擎</p><p>文档 2: 分布式系统的核心是搜索</p><p>文档 3: 搜索引擎的未来是智能化</p><p>倒排索引将这些文档转化为如下形式：</p><table><thead><tr><th>关键词</th><th>文档 ID</th></tr></thead><tbody><tr><td>elasticsearch</td><td>1</td></tr><tr><td>分布式</td><td>1, 2</td></tr><tr><td>系统</td><td>2</td></tr><tr><td>核心</td><td>2</td></tr><tr><td>搜索</td><td>2, 3</td></tr><tr><td>引擎</td><td>1, 3</td></tr><tr><td>智能化</td><td>3</td></tr></tbody></table><h1 id="倒排索引的构建过程"><a href="#倒排索引的构建过程" class="headerlink" title="倒排索引的构建过程"></a>倒排索引的构建过程</h1><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202102610166.jpg"></p><ol><li>分词（Tokenization）<br>分词是将文本内容拆分为独立的单词或短语，例如：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">原语句：Elasticsearch是分布式引擎<br><br>分词结果：<span class="hljs-selector-attr">[Elasticsearch, 是, 分布式, 引擎]</span><br></code></pre></td></tr></table></figure><ol start="2"><li>归一化（Normalization）<br>归一化是对分词结果进行标准化处理，包括：</li></ol><ul><li><p>转小写：将所有大写字母转为小写。例如 <code>Elasticsearch → elasticsearch</code>。</p></li><li><p>去除停用词：删除一些对查询结果影响不大的词，如 “的“ “是” 等等。</p></li><li><p>词干提取：将词汇归为基本形式，如 <code>running → run</code>。</p></li></ul><ol start="3"><li>创建倒排索引<br>根据分词结果，为每个词项建立一个到文档的映射关系。最终生成的倒排索引可以看作如下结构，然后存储起来：</li></ol><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;Elasticsearch&quot;</span>: [<span class="hljs-number">1</span>],<br>  <span class="hljs-string">&quot;分布式&quot;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>  <span class="hljs-string">&quot;引擎&quot;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>],<br>  <span class="hljs-string">&quot;搜索&quot;</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="用户发起搜索"><a href="#用户发起搜索" class="headerlink" title="用户发起搜索"></a>用户发起搜索</h1><p>当用户发起搜索时，Elasticsearch 会通过以下步骤来执行查询：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202103013579.jpg"></p><ol><li><p>解析查询条件：将查询关键词解析为分词结果。例如，用户搜索 <code>分布式搜索</code>，将被解析为 <code>[分布式, 搜索]</code>。</p></li><li><p>查找倒排索引：依次查找这些词项在倒排索引中的文档列表。例如：</p><ul><li><code>分布式</code> → [1, 2]</li><li><code>搜索</code> → [2, 3]</li></ul></li><li><p>合并结果：根据查询类型（如 AND、OR）合并文档列表，若不指定，默认为 OR 查询：</p><ul><li><p>若为 AND 查询（需要同时包含两个分词）：返回两个列表的交集 [2]。</p></li><li><p>若为 OR 查询（包含任意一个）：返回两个列表的并集 [1, 2, 3]。</p></li></ul></li><li><p>排序结果：Elasticsearch 根据相关性评分（如 TF-IDF）对结果进行排序，并返回给用户。</p></li></ol><h1 id="Elasticsearch-分词器"><a href="#Elasticsearch-分词器" class="headerlink" title="Elasticsearch 分词器"></a>Elasticsearch 分词器</h1><p>分词器 是 Elasticsearch 中用于处理文本的核心组件，它将输入的文本分解为一个个词项（terms），以便进行倒排索引和搜索匹配。分词器决定了文本如何存储和搜索，直接影响到查询的准确性和性能。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202103113249.jpg"></p><p>在 Elasticsearch 中，分词器 实际上是一个三步组合的过程，用于将文本数据标准化和分词。它通常由以下三个组件组成：</p><ol><li><p>字符过滤（Character Filters） 在分词之前，对原始文本进行预处理，例如删除 HTML 标签或替换特定字符。</p></li><li><p>分词（Tokenizer） 将文本拆分为一系列的词项（tokens），例如按照空格或标点符号切分。</p></li><li><p>词项过滤（Token Filters） 对分词结果进行处理，例如转小写、去停用词、词干提取等。</p></li></ol><h2 id="常见的内置分词器"><a href="#常见的内置分词器" class="headerlink" title="常见的内置分词器"></a>常见的内置分词器</h2><p>Elasticsearch 提供了多种内置分析器，满足不同语言和场景的需求：</p><ol><li><p>standard 分词器（默认分词器）</p><ul><li><p>特点：支持多语言，将文本按标准分词规则切分。</p></li><li><p>示例： 输入文本：<code>Elasticsearch is powerful.</code> 分词结果：<code>[&quot;elasticsearch&quot;, &quot;is&quot;, &quot;powerful&quot;]</code></p></li></ul></li><li><p>simple 分词器</p><ul><li><p>特点：仅按非字母字符切分（符号被过滤），且将所有词项转为小写。</p></li><li><p>示例： 输入文本：<code>Text123 data!</code> 分词结果：<code>[&quot;text&quot;, &quot;data&quot;]</code></p></li></ul></li><li><p>whitespace 分词器</p><ul><li><p>特点：仅以空格分词，不做额外处理。</p></li><li><p>示例： 输入文本：<code>The quick brown fox</code> 分词结果：<code>[&quot;The&quot;, &quot;quick&quot;, &quot;brown&quot;, &quot;fox&quot;]</code></p></li></ul></li><li><p>keyword 分词器</p><ul><li><p>特点：将整个输入作为单个词项，不做任何分词。</p></li><li><p>示例： 输入文本：<code>user_name:quanxiaoha</code> 分词结果：<code>[&quot;user_name:quanxiaoha&quot;]</code></p></li></ul></li><li><p>stop 分词器</p><ul><li><p>特点：在 standard 分析器基础上，去掉常见的停用词（如 “is”、”the”）。</p></li><li><p>示例： 输入文本：<code>The quick brown fox</code> 分词结果：<code>[&quot;quick&quot;, &quot;brown&quot;, &quot;fox&quot;]</code></p></li></ul></li></ol><h1 id="Elasticsearch-安装-ik-中文分词器插件"><a href="#Elasticsearch-安装-ik-中文分词器插件" class="headerlink" title="Elasticsearch 安装 ik 中文分词器插件"></a>Elasticsearch 安装 ik 中文分词器插件</h1><p>IK 分词器是一个专门为中文设计的分词插件，支持细粒度分词和智能分词，广泛应用于中文搜索场景。</p><h2 id="什么是-IK-中文分词器？"><a href="#什么是-IK-中文分词器？" class="headerlink" title="什么是 IK 中文分词器？"></a>什么是 IK 中文分词器？</h2><p>IK 分词器（IK Analyzer）是基于 Apache Lucene 的中文分词插件，专为 Elasticsearch 提供支持。它能够根据词典和语义规则，将中文句子拆分为一个个可供索引和搜索的词条。</p><p>IK 分词器的特点</p><ul><li><p>支持细粒度分词和智能分词：细粒度分词会将文本拆分成尽可能小的词条，而智能分词更注重语义完整性。</p></li><li><p>自定义扩展词典：支持用户根据业务需求扩展分词词典。</p></li><li><p>动态调整：可以通过重新加载词典，动态更新分词规则。</p></li></ul><p>应用场景</p><ul><li><p>全文检索：如博客、新闻、知识库等中文内容的全文搜索。</p></li><li><p>电商搜索：处理商品名称、描述的精准搜索。</p></li><li><p>数据挖掘：如舆情分析、文本分类等。</p></li></ul><h2 id="安装-ik-插件"><a href="#安装-ik-插件" class="headerlink" title="安装 ik 插件"></a>安装 ik 插件</h2><p>执行如下命令，进入的 es7 容器的内部：<br><code>docker exec -it es7 /bin/sh</code></p><p>执行 <code>ls</code> 命令，可以看到当前目录正是 Elasticsearch 的根目录：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202103659635.png"></p><p>接着，执行如下命令来安装 ik 中文分词插件：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bin</span>/elasticsearch-plugin install https://get.infini.cloud/elasticsearch/analysis-ik/<span class="hljs-number">7</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202103804526.png"></p><h2 id="复制容器内部文件"><a href="#复制容器内部文件" class="headerlink" title="复制容器内部文件"></a>复制容器内部文件</h2><p>安装完成后，执行如下命令，退出容器：<br><code>exit</code></p><p>执行 docker cp 命令，将已安装的 ik 插件相关文件，复制到宿主机中，防止丢失：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp es7:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>plugins/analysis-ik F:\Docker\elasticsearch\plugins<br>docker cp es7:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>config/analysis-ik F:\Docker\elasticsearch\config<br></code></pre></td></tr></table></figure><h2 id="重启-es-容器"><a href="#重启-es-容器" class="headerlink" title="重启 es 容器"></a>重启 es 容器</h2><p>执行如下命令，重启容器，以应用 ik 中文分词器插件：<br><code>docker restart es7</code></p><p>查看容器内部日志，若提示 loaded plugin [analysis-ik] 信息，说明 ik 插件已经被应用。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kibana安装与使用</title>
    <link href="/2025/02/02/Kibana%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/02/02/Kibana%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Kibana-简介"><a href="#Kibana-简介" class="headerlink" title="Kibana 简介"></a>Kibana 简介</h1><p>Kibana 是一款强大的开源工具，用于可视化和分析 Elasticsearch 中存储的数据。</p><p>其优势如下：</p><ol><li><p>强大的数据可视化能力：</p><ul><li><p>Kibana 提供了多种图表类型，如柱状图、折线图、饼图等，可以直观地展示 Elasticsearch 中的数据。</p></li><li><p>用户可以根据自己的需求创建自定义的仪表板，将多个视图组合在一起，以获得全面的数据概览。</p></li></ul></li><li><p>灵活的数据探索：</p><ul><li><p>通过 Discover 功能，用户可以直接查询 Elasticsearch 索引中的数据，并实时查看结果。</p></li><li><p>支持复杂的搜索查询语句，使用户能够深入挖掘数据，发现隐藏的趋势和模式。</p></li></ul></li><li><p>集成开发环境 (Dev Tools)：</p><ul><li><p>Dev Tools 模块提供了一个内置的控制台，用户可以通过它直接执行 Elasticsearch API 请求，进行索引管理、文档检索等操作。</p></li><li><p>对于开发者来说，这是一个非常有用的工具，可以用来调试查询、测试配置或进行快速的数据验证。</p></li></ul></li><li><p>安全性和管理功能：</p><ul><li><p>Kibana 支持用户管理和权限控制，确保只有授权的用户才能访问特定的数据或功能。</p></li><li><p>可以与 X-Pack 安全特性结合使用，提供更高级的安全选项，比如 SSO（单点登录）、加密通信等。</p></li></ul></li><li><p>易于使用：</p><ul><li><p>Kibana 的用户界面设计简洁明了，即使是初学者也能快速上手。</p></li><li><p>提供了详细的文档和社区支持，帮助用户解决使用过程中遇到的问题。</p></li></ul></li><li><p>可扩展性：</p><ul><li><p>Kibana 支持插件系统，允许用户安装第三方插件来扩展其功能。</p></li><li><p>开发者还可以自己编写插件，满足特定的需求。</p></li></ul></li></ol><h1 id="Kibana-安装"><a href="#Kibana-安装" class="headerlink" title="Kibana 安装"></a>Kibana 安装</h1><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>打开命令行工具，执行如下命令，下载 Kibana 镜像：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull kibana:<span class="hljs-number">7</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>注： Kibana版本应与Elasticsearch保持一致。</p><p>镜像下载完成后，可使用 <code>docker images</code> 命令来确认一下是否下载成功。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202095952287.png"></p><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>接着，执行如下命令，运行一个 Kibana 容器：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --name kibana -p <span class="hljs-number">5601</span>:<span class="hljs-number">5601</span> kibana:<span class="hljs-number">7</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="准备挂载文件夹"><a href="#准备挂载文件夹" class="headerlink" title="准备挂载文件夹"></a>准备挂载文件夹</h2><p>Kibana 容器跑起来后，在 F:\Docker 文件夹下，创建一个 &#x2F;kibana 文件夹，用于统一放置 Kibana 挂载相关的文件。</p><p>执行如下命令，将 Kibana 容器中的配置文件夹，复制到宿主机的 F:\Docker 文件夹下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp kibana:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/kibana/</span>config F:\Docker\kibana<br></code></pre></td></tr></table></figure><h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><p>编辑 kibana.yml 配置文件，修改内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server.name:</span> <span class="hljs-string">kibana</span><br><span class="hljs-attr">server.host:</span> <span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-attr">elasticsearch.hosts:</span> [ <span class="hljs-string">&quot;http://172.17.0.1:9200&quot;</span> ] <span class="hljs-comment"># 修改为宿主机 IP 地址</span><br><span class="hljs-attr">xpack.monitoring.ui.container.elasticsearch.enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">i18n.locale:</span> <span class="hljs-string">&quot;zh-CN&quot;</span> <span class="hljs-comment"># 设置使用中文</span><br></code></pre></td></tr></table></figure><p>主要修改两处：</p><ul><li><p><code>elasticsearch.hosts</code> : 因为 Kibana 需要连接 es， 这里将 IP 地址修改为 <code>172.17.0</code>.1 , 方便访问到宿主机的 9200 端口；</p></li><li><p>添加 <code>i18n.locale: &quot;zh-CN&quot;</code> 配置，以将 Kibana 设置为中文模式；</p></li></ul><h2 id="运行一个新的容器"><a href="#运行一个新的容器" class="headerlink" title="运行一个新的容器"></a>运行一个新的容器</h2><p>执行如下命令，强制将当前正在运行中 Kibana 容器删除掉：<br><code>docker rm -f kibana</code></p><p>重新跑一个新的 Kibana 容器，这次需挂载上宿主机中的配置文件：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --name kibana -p <span class="hljs-number">5601</span>:<span class="hljs-number">5601</span> -v F:\Docker\kibana\config:/usr/share/kibana/config kibana:<span class="hljs-number">7</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>容器运行成功后，可执行如下命令，查看 Kibana 的运行日志：<br><code>docker logs -f kibana</code></p><p>若如下图所示，日志中提示 <code>Server running at http://0:5601</code> ，说明 Kibana 成功跑起来了：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202101414645.png"></p><h2 id="访问控制台"><a href="#访问控制台" class="headerlink" title="访问控制台"></a>访问控制台</h2><p>浏览器访问地址 localhost:5601 ，即可登录 Kibana 控制台。</p><p>依次点击 Discover | 索引管理， 即可查看索引相关信息。</p><h2 id="Dev-tools"><a href="#Dev-tools" class="headerlink" title="Dev tools"></a>Dev tools</h2><p>Dev Tools 是 Kibana 内置的一个强大工具，它为用户提供了一个方便的界面来与 Elasticsearch 进行交互。主要特点包括：</p><ul><li><p>命令行界面：提供了一个类似命令行的界面，用户可以在这里输入 Elasticsearch 的 RESTful API 调用，执行各种操作，如查询数据、创建索引、更新设置等。</p></li><li><p>历史记录：保存了用户的查询历史，方便用户回顾之前的请求或重用某些查询。</p></li><li><p>语法高亮和自动完成：支持 JSON 语法高亮显示，以及对 API 方法和参数的自动完成提示，提高了编码效率。</p></li><li><p>响应格式化：返回的 JSON 响应会自动格式化，便于阅读和理解。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202100744496.png"></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Canal搭建与使用</title>
    <link href="/2025/02/02/Canal%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/02/02/Canal%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Canal-简介"><a href="#Canal-简介" class="headerlink" title="Canal 简介"></a>Canal 简介</h1><p>Canal [kə’næl]，译意为水道&#x2F;管道&#x2F;沟渠，是阿里巴巴开源的一个 MySQL 数据库增量订阅和消费中间件，将自己伪装成 MySQL 的从库，获取 MySQL 的 binlog（二进制日志）数据，从而实现对数据库变更的实时监听。</p><p>官方地址：<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a> 。</p><ul><li><p>实现思路</p><ul><li><p>Canal 通过解析数据库的 binlog 日志 捕获数据变更。</p></li><li><p>将变更数据实时同步到下游服务，如更新 Elasticsearch 索引。</p></li></ul></li><li><p>优点</p><ol><li><p>零侵入：</p><ul><li><p>不需要修改业务服务逻辑，无需在代码中额外发送消息。</p></li><li><p>直接从 binlog 获取数据变更，减少对业务代码的侵入性。</p></li></ul></li><li><p>一致性强：</p><ul><li>Canal 直接从数据库日志解析数据变更，与数据库主数据完全一致。</li></ul></li><li><p>低耦合：</p><ul><li>不依赖业务服务的实现，与数据库交互即可实现同步。</li></ul></li><li><p>实时性高：</p><ul><li>通过解析 binlog，变更数据可以实时同步到搜索服务。</li></ul></li></ol></li><li><p>缺点</p><ol><li><p>运维成本高：</p><ul><li><p>Canal 需要独立部署，并且对高并发的 binlog 解析有较高的硬件要求。</p></li><li><p>Canal 本身也需要高可用方案（如集群模式）。</p></li></ul></li><li><p>功能有限：</p><ul><li><p>Canal 只能捕获数据库变更（新增、修改、删除），难以处理复杂的业务逻辑（如某些需要额外字段加工的消息）。</p></li><li><p>如果业务中对数据的更新不是直接写入数据库，而是通过缓存（如 Redis），Canal 无法捕获。</p></li></ul></li><li><p>数据处理复杂性：</p><ul><li><p>Canal 只能获取到原始数据变更，需要额外开发逻辑将 binlog 数据转换为 Elasticsearch 所需的格式。</p></li><li><p>多表关联、字段映射等逻辑可能增加实现复杂性。</p></li></ul></li><li><p>数据库依赖：</p><ul><li>Canal 强依赖数据库的 binlog 格式（如 MySQL Binlog），对某些数据库（如 NoSQL 或非 MySQL 系统）支持有限。</li></ul></li></ol></li></ul><h1 id="Canal-通过-Docker-安装"><a href="#Canal-通过-Docker-安装" class="headerlink" title="Canal 通过 Docker 安装"></a>Canal 通过 Docker 安装</h1><ol><li>下载镜像</li></ol><p><code>docker pull elasticsearch:7.3.0</code></p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202091034519.png"></p><p>执行 <code>docker images</code> 查看镜像是否挂载成功：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202091227296.png"></p><ol start="2"><li>准备挂载文件夹</li></ol><p>接着，在 F:\Docker 文件夹下创建 &#x2F;elasticsearch 文件夹，用于等会跑 es 容器时，将容器内部需要持久化的相关文件夹挂载出来：</p><ol start="3"><li>运行 Docker 容器</li></ol><p>命令行运行如下命令，先跑一个 Elasticsearch 7.3.0 版本的 Docker 容器：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --name es7 -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> -p <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span> -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> -e ES_JAVA_OPTS=<span class="hljs-string">&quot;-Xms1024m -Xmx1024m&quot;</span> elasticsearch:<span class="hljs-number">7</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>命令各项参数的含义：</p><ul><li><p><code>docker run</code> ：启动一个新的容器。</p></li><li><p><code>-d</code> ：表示以 后台运行（detached mode）。</p></li><li><p><code>--name es7</code> ： 给这个容器指定一个名字为 <code>es7</code>，方便后续管理和识别。</p></li><li><p><code>-p 9200:9200 -p 9300:9300</code>：端口映射，将容器内的端口暴露到主机上：</p><ul><li><p><code>9200:9200</code>：将容器内的 9200 端口（Elasticsearch 的 REST API 接口）映射到主机的 9200 端口，供外部使用。</p></li><li><p><code>9300:9300</code>：将容器内的 9300 端口（Elasticsearch 的内部通信端口，用于节点间通信）映射到主机的 9300 端口。</p></li></ul></li><li><p><code>-e &quot;discovery.type=single-node&quot;</code>：通过环境变量设置 Elasticsearch 以 单节点模式 运行：</p><ul><li><p>作用：避免集群模式下的主节点选举。</p></li><li><p>场景：适用于开发、测试环境，不需要集群功能。</p></li></ul></li><li><p><code>-e ES_JAVA_OPTS=&quot;-Xms1024m -Xmx1024m&quot;</code>：设置 JVM 内存参数：</p><ul><li><p>-<code>Xms1024m</code>：设置 JVM 的初始堆内存为 1024MB。</p></li><li><p><code>-Xmx1024m</code>：设置 JVM 的最大堆内存为 1024MB。</p></li><li><p>作用：确保 Elasticsearch 启动时使用 1GB 固定堆内存（建议与物理内存配置匹配，以提高性能）。</p></li></ul></li><li><p><code>elasticsearch:7.3.0</code>：指定使用的 Docker 镜像为 <code>elasticsearch:7.3.0</code>。</p></li></ul><p>运行 <code>docker ps</code> 命令，确认 Elasticsearch 7.x 容器是否运行成功：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202091654131.png"></p><ol start="4"><li>复制需要挂载的文件夹</li></ol><p>执行如下命令，将 es 容器内部的相关文件夹，复制到宿主机的 F:\Docker\elasticsearch 文件夹下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp es7:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>config F:\Docker\elasticsearch<br>docker cp es7:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>data F:\Docker\elasticsearch<br>docker cp es7:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>plugins F:\Docker\elasticsearch<br></code></pre></td></tr></table></figure><p>解释一下这几个文件夹的作用：</p><ul><li><p><code>/config</code> : Elasticsearch 的默认配置文件，便于后续修改配置，如 elasticsearch.yml、jvm.options 等；</p></li><li><p><code>/data</code> : Elasticsearch 的索引、文档等数据;</p></li><li><p><code>/plugins</code> : Elasticsearch 相关插件；</p></li></ul><ol start="5"><li>修改配置</li></ol><p>编辑刚刚复制出来的 <code>/config</code> 中的 <code>elasticsearch.yml</code> 配置文件，修改如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cluster.name:</span> <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-attr">network.host:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><span class="hljs-comment"># 跨域相关</span><br><span class="hljs-attr">http.cors.allow-origin:</span> <span class="hljs-string">&quot;*&quot;</span><br><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">http.cors.allow-headers:</span> <span class="hljs-string">Authorization,X-Requested-With,Content-Length,Content-Type</span><br></code></pre></td></tr></table></figure><ul><li><p>修改了集群名称 <code>cluster.name</code> 为 <code>xxx</code>;</p></li><li><p>添加了跨域相关配置；</p></li></ul><ol start="6"><li>重新启动容器</li></ol><p>执行如下命令，将正在运行中的 <code>es</code> 容器强制删除掉：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> es7<br></code></pre></td></tr></table></figure><p>重新跑一个新的 <code>es</code> 容器，注意，这次命令中需要添加挂载文件夹参数，用于将数据、配置、插件都挂载出来，防止容器停止&#x2F;删除后，相关数据丢失的问题：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -d --name es7 -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> -p <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span> -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> -e ES_JAVA_OPTS=<span class="hljs-string">&quot;-Xms1024m -Xmx1024m&quot;</span> -v F:\Docker\elasticsearch\config:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>config -v F:\Docker\elasticsearch\data:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>data -v F:\Docker\elasticsearch\plugins:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>plugins -v F:\Docker\elasticsearch\logs:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>logs elasticsearch:<span class="hljs-number">7.3</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202092258180.png"></p><ol start="7"><li>确认容器是否运行成功</li></ol><p>浏览器访问地址：<a href="http://localhost:9200/">http://localhost:9200/</a> ，若如下图所示，返回了 <code>es</code> 相关信息，说明本地单节点的 <code>es</code> 环境就搭建好了:</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202092331257.png"></p><h1 id="安装-elasticsearch-head-可视化工具"><a href="#安装-elasticsearch-head-可视化工具" class="headerlink" title="安装 elasticsearch-head 可视化工具"></a>安装 elasticsearch-head 可视化工具</h1><p><code>elasticsearch-head</code> 是一个开源的 Web 前端工具，用于 管理和可视化 Elasticsearch 集群。它提供了用户友好的界面，让用户能够直观地查看集群状态、管理索引、运行查询等操作。</p><p>官方地址：<a href="https://github.com/mobz/elasticsearch-head">https://github.com/mobz/elasticsearch-head</a> 。</p><ol><li>下载 head 镜像</li></ol><p>我们将通过 Docker 把 <code>elasticsearch-head</code> 工具跑起来，执行如下命令，以下载镜像：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull mobz/elasticsearch-head:<span class="hljs-number">5</span>-alpine<br></code></pre></td></tr></table></figure><ol start="2"><li>运行 head 容器</li></ol><p>执行如下命令，运行 <code>elasticsearch-head</code> 容器：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --name es-head -p <span class="hljs-number">9100</span>:<span class="hljs-number">9100</span> mobz/elasticsearch-head:<span class="hljs-number">5</span>-alpine<br></code></pre></td></tr></table></figure><ol start="3"><li>访问 head 控制台</li></ol><p><code>elasticsearch-head</code> 容器运行成功后，浏览器访问地址：<a href="http://localhost:9100/">http://localhost:9100/</a> ，即可访问控制台，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202092539401.png"></p><ul><li><p>①：点击连接按钮，若提示集群健康值为 green, 则表示 elasticsearch-head 连接 es 集群正常；</p></li><li><p>②：在集群概览中，可查看当前正在运行的集群节点数，当前是一个节点；</p></li><li><p>③：点击查看集群节点信息，如图所示，可以看到 cluster.name 集群名称确实是我们定义的 xiaohashu-cluster ；</p></li></ul><h1 id="Elasticsearch-核心概念介绍"><a href="#Elasticsearch-核心概念介绍" class="headerlink" title="Elasticsearch 核心概念介绍"></a>Elasticsearch 核心概念介绍</h1><h2 id="什么是-Elasticsearch？"><a href="#什么是-Elasticsearch？" class="headerlink" title="什么是 Elasticsearch？"></a>什么是 Elasticsearch？</h2><p>Elasticsearch 是一个开源的分布式搜索和分析引擎，能够对海量数据进行快速的存储、搜索和分析。它基于 Apache Lucene 构建，为全文搜索、结构化搜索和数据分析提供了一种高效且易于使用的解决方案。</p><p>其特性如下：</p><ul><li><p>分布式架构：Elasticsearch 天生支持分布式，可以轻松扩展至数百个节点。</p></li><li><p>实时搜索：能够对新增数据快速进行搜索和查询。</p></li><li><p>全文检索：支持强大的全文搜索功能，包括模糊匹配、分词、高亮显示等。</p></li><li><p>RESTful API：提供易于使用的 HTTP 接口，方便与其他系统集成。</p></li><li><p>高度可定制：支持自定义分词器、查询语法和分析器，适应各种复杂业务需求。</p></li><li><p>开放与可扩展性：插件化设计，允许根据需求扩展功能。</p></li></ul><h2 id="Elasticsearch-核心概念"><a href="#Elasticsearch-核心概念" class="headerlink" title="Elasticsearch 核心概念"></a>Elasticsearch 核心概念</h2><ul><li><p>Index（索引）：索引是 Elasticsearch 的数据存储单位，类似于关系型数据库中的 “Table（表）”。</p></li><li><p>Document（文档）：文档是 Elasticsearch 中的最小数据单位，类似于关系型数据库中的 “Row（行）”。</p></li><li><p>Field（字段）：字段是文档的属性，类似于关系型数据库中的 “Column（列）”。</p></li><li><p>Type（类型）：在 Elasticsearch 7.x 版本后，Type 的概念被逐渐废弃，统一默认值为 _doc, 以简化架构设计。</p></li><li><p>Cluster（集群）：Elasticsearch 的集群由一个或多个节点组成，共同提供存储、搜索和分析服务。</p></li><li><p>Node（节点）: 集群中的每个实例被称为节点，每个节点可以存储部分数据并参与集群的计算任务。</p></li><li><p>Shard（分片）和 Replica（副本）：</p></li><li><p>Shard（分片）： 索引被分为多个分片，每个分片可以独立存储和查询。</p></li><li><p>Replica（副本）： 分片的副本，用于提高查询效率和容错能力。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250202092834838.jpg"></p><h2 id="Elasticsearch-的应用场景"><a href="#Elasticsearch-的应用场景" class="headerlink" title="Elasticsearch 的应用场景"></a>Elasticsearch 的应用场景</h2><ul><li><p>日志和事件数据分析 : 与 Logstash、Kibana 组成 ELK Stack，用于收集、存储、分析日志数据，实现实时监控和告警。</p></li><li><p>全文搜索 : 支持复杂的文本搜索功能，可用于搜索引擎、文档管理系统等场景。</p></li><li><p>推荐系统 : 通过聚合分析和个性化查询，为电商、内容平台等提供推荐服务。</p></li><li><p>数据分析与 BI : 可对结构化和非结构化数据进行复杂聚合分析，适用于数据报表和业务决策。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xxl-job使用</title>
    <link href="/2025/02/01/xxl-job%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/02/01/xxl-job%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>XXL-JOB是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。 现已开放源代码并接入多家公司线上产品线，开箱即用。官方地址为：<a href="https://www.xuxueli.com/xxl-job/">https://www.xuxueli.com/xxl-job/</a> 。</p><p>特性：</p><ul><li><p>1、简单：支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手；</p></li><li><p>2、动态：支持动态修改任务状态、启动&#x2F;停止任务，以及终止运行中任务，即时生效；</p></li><li><p>3、调度中心HA（中心式）：调度采用中心式设计，“调度中心”自研调度组件并支持集群部署，可保证调度中心HA；</p></li><li><p>4、执行器HA（分布式）：任务分布式执行，任务”执行器”支持集群部署，可保证任务执行HA；</p></li><li><p>5、注册中心: 执行器会周期性自动注册任务, 调度中心将会自动发现注册的任务并触发执行。同时，也支持手动录入执行器地址；</p></li><li><p>6、弹性扩容缩容：一旦有新执行器机器上线或者下线，下次调度时将会重新分配任务；</p></li><li><p>7、触发策略：提供丰富的任务触发策略，包括：Cron触发、固定间隔触发、固定延时触发、API（事件）触发、人工触发、父子任务触发；</p></li><li><p>8、调度过期策略：调度中心错过调度时间的补偿处理策略，包括：忽略、立即补偿触发一次等；</p></li><li><p>9、阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行（默认）、丢弃后续调度、覆盖之前调度；</p></li><li><p>10、任务超时控制：支持自定义任务超时时间，任务运行超时将会主动中断任务；</p></li><li><p>11、任务失败重试：支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；其中分片任务支持分片粒度的失败重试；</p></li><li><p>12、任务失败告警；默认提供邮件方式失败告警，同时预留扩展接口，可方便的扩展短信、钉钉等告警方式；</p></li><li><p>13、路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等；</p></li><li><p>14、分片广播任务：执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发集群中所有执行器执行一次任务，可根据分片参数开发分片任务；</p></li><li><p>15、动态分片：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。</p></li><li><p>16、故障转移：任务路由策略选择”故障转移”情况下，如果执行器集群中某一台机器故障，将会自动Failover切换到一台正常的执行器发送调度请求。</p></li><li><p>17、任务进度监控：支持实时监控任务进度；</p></li><li><p>18、Rolling实时日志：支持在线查看调度结果，并且支持以Rolling方式实时查看执行器输出的完整的执行日志；</p></li><li><p>19、GLUE：提供Web IDE，支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程。支持30个版本的历史版本回溯。</p></li><li><p>20、脚本任务：支持以GLUE模式开发和运行脚本任务，包括Shell、Python、NodeJS、PHP、PowerShell等类型脚本;</p></li><li><p>21、命令行任务：原生提供通用命令行任务Handler（Bean任务，”CommandJobHandler”）；业务方只需要提供命令行即可；</p></li><li><p>22、任务依赖：支持配置子任务依赖，当父任务执行结束且执行成功后将会主动触发一次子任务的执行, 多个子任务用逗号分隔；</p></li><li><p>23、一致性：“调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行；</p></li><li><p>24、自定义任务参数：支持在线配置调度任务入参，即时生效；</p></li><li><p>25、调度线程池：调度系统多线程触发调度运行，确保调度精确执行，不被堵塞；</p></li><li><p>26、数据加密：调度中心和执行器之间的通讯进行数据加密，提升调度信息安全性；</p></li><li><p>27、邮件报警：任务失败时支持邮件报警，支持配置多邮件地址群发报警邮件；</p></li><li><p>28、推送maven中央仓库: 将会把最新稳定版推送到maven中央仓库, 方便用户接入和使用;</p></li><li><p>29、运行报表：支持实时查看运行数据，如任务数量、调度次数、执行器数量等；以及调度报表，如调度日期分布图，调度成功分布图等；</p></li><li><p>30、全异步：任务调度流程全异步化设计实现，如异步调度、异步运行、异步回调等，有效对密集调度进行流量削峰，理论上支持任意时长任务的运行；</p></li><li><p>31、跨语言：调度中心与执行器提供语言无关的 RESTful API 服务，第三方任意语言可据此对接调度中心或者实现执行器。除此之外，还提供了 “多任务模式”和“httpJobHandler”等其他跨语言方案；</p></li><li><p>32、国际化：调度中心支持国际化设置，提供中文、英文两种可选语言，默认为中文；</p></li><li><p>33、容器化：提供官方docker镜像，并实时更新推送dockerhub，进一步实现产品开箱即用；</p></li><li><p>34、线程池隔离：调度线程池进行隔离拆分，慢任务自动降级进入”Slow”线程池，避免耗尽调度线程，提高系统稳定性；</p></li><li><p>35、用户管理：支持在线管理系统用户，存在管理员、普通用户两种角色；</p></li><li><p>36、权限控制：执行器维度进行权限控制，管理员拥有全量权限，普通用户需要分配执行器权限后才允许相关操作；</p></li></ul><h1 id="下载源码："><a href="#下载源码：" class="headerlink" title="下载源码："></a>下载源码：</h1><p>访问地址：<a href="https://github.com/xuxueli/xxl-job/releases">https://github.com/xuxueli/xxl-job/releases</a> ，下载 XXL-JOB 最新稳定版源码。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250201145553883.png"></p><p>源码下载完成后，解压，进入根目录：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250201145717105.png"></p><ul><li><p>&#x2F;doc : 存放相关文档，以及数据库初始化脚本；</p></li><li><p>&#x2F;xxl-job-admin : Admin 管理后台模块；</p></li><li><p>&#x2F;xxl-job-core : 平台核心层模块；</p></li><li><p>&#x2F;xxl-job-executor-samples : 相关使用示例代码；</p></li></ul><h1 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h1><p>使用 IDEA 打开 XXL-JOB 项目，找到 &#x2F;doc&#x2F;db&#x2F; 文件夹下的 tables_xxl_job.sql 脚本，复制全部 SQL:<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250201145908113.png"></p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>数据库初始化完毕后，编辑 <code>/xxl-job-admin</code> 模块中的 <code>application.properties</code> 配置文件，修改如下两处：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250201150221110.jpg"></p><p>① ：默认的端口号可能与当前项目服务端口有冲突，自行修改端口；</p><p>② : 修改数据库连接、用户名、密码；</p><h2 id="启动-XXL-JOB"><a href="#启动-XXL-JOB" class="headerlink" title="启动 XXL-JOB"></a>启动 XXL-JOB</h2><p>运行 <code>XxlJobAdminApplication</code> 启动类，若控制台提示信息如下，说明项目运行成功：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250201150402142.png"></p><h2 id="管理后台"><a href="#管理后台" class="headerlink" title="管理后台"></a>管理后台</h2><p>XXL-JOB 运行成功后，浏览器访问地址：<a href="http://localhost:7777/xxl-job-admin/">http://localhost:7777/xxl-job-admin/</a> ， 即可进入到管理后台中，如下图所示，至此本地的 XXL-JOB 就搭建完成了：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250201150608251.png"></p><h2 id="Spring-Boot-3-x-整合-XXL-JOB"><a href="#Spring-Boot-3-x-整合-XXL-JOB" class="headerlink" title="Spring Boot 3.x 整合 XXL-JOB"></a>Spring Boot 3.x 整合 XXL-JOB</h2><h3 id="添加执行器"><a href="#添加执行器" class="headerlink" title="添加执行器"></a>添加执行器</h3><p>打开 XXL-JOB 管理后台，进入执行器管理菜单中， 默认已经添加了一个执行器，直接点击编辑：<br>TIP: 执行器的意思就是 —— 定时任务的执行者，即数据对齐服务。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250201150750325.png"></p><p>① ：设置执行器唯一标识，这里我修改为了 xxl-job-executor-xiaohashu；<br>② ：执行器名称；<br>③ ： 注册方式勾选自动注册，则无需手动填写执行器机器地址；</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>准备将数据对齐服务注册到 XXL-JOB 中。编辑最外层的 pom.xml 文件，声明 xxl-job 依赖以及版本号，注意，建议和实际搭建 XXL-JOB 的版本保持一致</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- XXL-JOB 分布式定时任务调度 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuxueli<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xxl-job-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">xxl-job.version</span>&gt;</span>2.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">xxl-job.version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h3><p>依赖添加完毕后，编辑 <code>application-dev.yml</code> 配置文件，添加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">xxl:</span><br>  <span class="hljs-attr">job:</span><br>    <span class="hljs-attr">adminAddresses:</span> <span class="hljs-string">http://127.0.0.1:7777/xxl-job-admin</span> <span class="hljs-comment"># xxl-job 调度中心部署根地址，如调度中心集群部署存在多个地址则用逗号分隔</span><br>    <span class="hljs-attr">accessToken:</span> <span class="hljs-string">default_token</span> <span class="hljs-comment"># 需要和 xxl-job 上创建的 token 保持一致</span><br>    <span class="hljs-attr">appName:</span> <span class="hljs-string">xxx</span> <span class="hljs-comment"># 需要和 xxl-job 上创建的执行器名称保持一致</span><br>    <span class="hljs-attr">ip:</span> <span class="hljs-comment"># 执行器 ip, 为空表示自动获取 ip</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">10001</span> <span class="hljs-comment"># 执行器端口号</span><br>    <span class="hljs-attr">logPath:</span> <span class="hljs-string">/data/applogs/xxl-job/jobhandler</span> <span class="hljs-comment"># 执行器日志存放路径</span><br>    <span class="hljs-attr">logRetentionDays:</span> <span class="hljs-number">30</span> <span class="hljs-comment"># 日志保留时间（单位：天）</span><br></code></pre></td></tr></table></figure><p>以上各项配置作用如下：</p><p>adminAddresses : 调度中心部署根地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行”执行器心跳注册”和”任务结果回调”；为空则关闭自动注册；<br>accessToken : 执行器通讯TOKEN [选填]：非空时启用；<br>appName : 执行器 AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册;<br>ip : 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 “执行器注册” 和 “调度中心请求并触发任务”；<br>port : 执行器端口号 [选填]：小于等于0则自动获取；单机部署多个执行器时，注意要配置不同执行器端口；<br>logPath : 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；<br>logRetentionDays : 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；</p><p>创建 &#x2F;config 包，并创建下图标注的两个配置类：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250201151324414.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: xxl-job 配置读取</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = XxlJobProperties.PREFIX)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XxlJobProperties</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxl.job&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> String adminAddresses;<br><br>    <span class="hljs-keyword">private</span> String accessToken;<br><br>    <span class="hljs-keyword">private</span> String appName;<br><br>    <span class="hljs-keyword">private</span> String ip;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br><br>    <span class="hljs-keyword">private</span> String logPath;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">logRetentionDays</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> com.xxl.job.core.executor.impl.XxlJobSpringExecutor;<br><span class="hljs-keyword">import</span> jakarta.annotation.Resource;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: xxl-job 配置类</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XxlJobConfig</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> XxlJobProperties xxlJobProperties;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化执行器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> XxlJobSpringExecutor <span class="hljs-title function_">xxlJobExecutor</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);<br>        <span class="hljs-type">XxlJobSpringExecutor</span> <span class="hljs-variable">xxlJobSpringExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XxlJobSpringExecutor</span>();<br>        xxlJobSpringExecutor.setAdminAddresses(xxlJobProperties.getAdminAddresses());<br>        xxlJobSpringExecutor.setAppname(xxlJobProperties.getAppName());<br>        xxlJobSpringExecutor.setIp(xxlJobProperties.getIp());<br>        xxlJobSpringExecutor.setPort(xxlJobProperties.getPort());<br>        xxlJobSpringExecutor.setAccessToken(xxlJobProperties.getAccessToken());<br>        xxlJobSpringExecutor.setLogPath(xxlJobProperties.getLogPath());<br>        xxlJobSpringExecutor.setLogRetentionDays(xxlJobProperties.getLogRetentionDays());<br>        <span class="hljs-keyword">return</span> xxlJobSpringExecutor;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>配置完成后，重启服务，若控制台提示 xxl-job remoting server start success 信息，说明执行器注册到 XXL-JOB 成功：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250201151415661.png"></p><p>进入到 XXL-JOB 管理后台中，在执行器管理菜单中，可以看到当前在线的执行器数量，点击查看，还可以看到执行器的 IP 地址与端口号：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250201151606525.png"></p><p>创建定时任务<br>执行器已经注册成功了，接下来，准备创建定时任务。打开管理后台中任务管理菜单，可以看到默认创建了一个任务，编辑它：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250201151642559.png"></p><p>相关配置项作用如下：</p><ul><li><p>基础配置：</p><ul><li><p>执行器：选择前面刚刚创建的小哈书执行器；</p></li><li><p>任务描述：填写任务的职责描述，方便后续维护，我这里描述修改为了创建日增量表任务；</p></li><li><p>负责人：任务的负责人；</p></li><li><p>报警邮件：任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔；</p></li></ul></li><li><p>调度配置：</p><ul><li><p>调度类型：</p><ul><li><p>无：该类型不会主动触发调度；</p></li><li><p>CRON：该类型将会通过CRON，触发任务调度；</p></li><li><p>固定速度：该类型将会以固定速度，触发任务调度；按照固定的间隔时间，周期性触发；</p></li></ul></li><li><p>CRON：触发任务执行的Cron表达式，我这里测试填写的是 0&#x2F;5 * * * * ? , 即每 5s 执行一次任务；</p></li><li><p>固定速度：固定速度的时间间隔，单位为秒；</p></li><li><p>固定延迟：固定延迟的时间间隔，单位为秒；</p></li></ul></li><li><p>任务配置：</p><ul><li><p>运行模式：任务以 JobHandler 方式维护在执行器端；需要结合 “JobHandler” 属性匹配执行器中任务；</p></li><li><p>JobHandler ：对应执行器中开发的任务类方法上 @XxlJob 注解自定义的 value 值；</p></li></ul></li><li><p>高级配置：</p><ul><li><p>路由策略：当执行器集群部署时，提供丰富的路由策略，包括；</p></li><li><p>FIRST（第一个）：固定选择第一个机器；</p></li><li><p>LAST（最后一个）：固定选择最后一个机器；</p></li><li><p>ROUND（轮询）：；</p></li><li><p>RANDOM（随机）：随机选择在线的机器；</p></li><li><p>CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。</p></li><li><p>LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；</p></li><li><p>LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；</p></li><li><p>FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；</p></li><li><p>BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；</p></li><li><p>SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</p></li><li><p>子任务：每个任务都拥有一个唯一的任务ID(任务ID可以从任务列表获取)，当本任务执行结束并且执行成功时，将会触发子任务ID所对应的任务的一次主动调度。</p></li><li><p>调度过期策略：</p><ul><li><p>忽略：调度过期后，忽略过期的任务，从当前时间开始重新计算下次触发时间；</p></li><li><p>立即执行一次：调度过期后，立即执行一次，并从当前时间开始重新计算下次触发时间；</p></li></ul></li><li><p>阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；</p><ul><li><p>单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；</p></li><li><p>丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；</p></li><li><p>覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；</p></li></ul></li><li><p>任务超时时间：支持自定义任务超时时间，任务运行超时将会主动中断任务；</p></li><li><p>失败重试次数：支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；</p></li></ul></li></ul><p>定时任务配置完成后，点击保存按钮。回到服务中，创建 &#x2F;job 包，用于统一存放置定时任务，并创建 CreateTableXxlJob 自动创建表任务类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> com.xxl.job.core.context.XxlJobHelper;<br><span class="hljs-keyword">import</span> com.xxl.job.core.handler.annotation.XxlJob;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateTableXxlJob</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1、简单任务示例（Bean模式）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@XxlJob(&quot;createTableJobHandler&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createTableJobHandler</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        XxlJobHelper.log(<span class="hljs-string">&quot;## 开始初始化明日增量数据表...&quot;</span>);<br><br>        <span class="hljs-comment">// TODO</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>开发步骤如下：</p><ul><li><p>1、任务开发：在 Spring Bean 实例中，开发 Job 方法；</p></li><li><p>2、注解配置：为 Job 方法添加注解 “@XxlJob(value&#x3D;”自定义 jobhandler 名称”, init &#x3D; “JobHandler 初始化方法”, destroy &#x3D; “JobHandler 销毁方法”)”，注解 value 值对应的是调度中心新建任务的 JobHandler 属性的值。</p></li><li><p>3、执行日志：需要通过 “XxlJobHelper.log” 打印执行日志，才能在管理后台中查询到日志信息；</p></li><li><p>4、任务结果：默认任务结果为 “成功” 状态，不需要主动设置；如有诉求，比如设置任务结果为失败，可以通过 “XxlJobHelper.handleFail&#x2F;handleSuccess” 自主设置任务结果；</p></li></ul><p>定时任务创建完成后，重启服务。</p><h3 id="运行定时任务"><a href="#运行定时任务" class="headerlink" title="运行定时任务"></a>运行定时任务</h3><p>回到 XXL-JOB 管理后台中，准备运行定时任务：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250201152527739.png"></p><p>① ： 执行一次，即手动立即触发一次定时任务；<br>② ：启动定时任务，按 Cron 表达式规则来运行定时任务；</p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>定时任务运行成功后，可以看到状态为 RUNNING 状态，表示任务正在运行中，点击查询日志，即可查看任务运行的具体日志：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250201153309888.png"></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典排序算法</title>
    <link href="/2025/01/31/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/31/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>两数之和衍生</title>
    <link href="/2025/01/31/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E8%A1%8D%E7%94%9F/"/>
    <url>/2025/01/31/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E8%A1%8D%E7%94%9F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BloomRedis安装与使用</title>
    <link href="/2025/01/30/BloomRedis%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/01/30/BloomRedis%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是-RedisBloom？"><a href="#什么是-RedisBloom？" class="headerlink" title="什么是 RedisBloom？"></a>什么是 RedisBloom？</h3><p>RedisBloom 是 Redis 的一个模块，它专门用于实现各种概率性数据结构，以节省内存和提升性能，适合在高并发的场景下使用。</p><p>RedisBloom 提供了布隆过滤器 (Bloom Filter)、Count-Min Sketch、布谷鸟过滤器 (Cuckoo Filter)、以及 Top-K 数据结构等。[官方地址](<a href="https://github.com/RedisBloom/RedisBloom">https://github.com/RedisBloom/RedisBloom</a> [官方地址])</p><p>RedisBloom 提供的几种核心数据结构介绍：</p><ul><li><p>布隆过滤器 (Bloom Filter)：布隆过滤器是一种非常高效的概率性数据结构，用于快速判断某个元素是否存在于一个集合中。它的优势在于节省内存、支持高并发操作，适用于需要快速判断“是否存在”且能容忍一定程度误判的场景。</p></li><li><p>Count-Min Sketch：Count-Min Sketch 是一种概率性数据结构，用于统计流式数据中元素的频率。相比于传统的哈希表，它能够以非常少的内存实现近似频率统计。</p></li><li><p>布谷鸟过滤器（Cuckoo Filter） : Cuckoo Filter 是另一种概率性集合，它允许删除元素，并且相较于布隆过滤器在某些场景下提供了更好的性能和灵活性。与布隆过滤器相比，Cuckoo Filter 的误判率通常更低，并且支持元素删除，但是占用内存较高。</p></li><li><p>Top-K：Top-K 数据结构用于跟踪某个集合中出现频率最高的前 K 个元素。它以节省内存的方式进行频率统计，适用于大数据集合。</p></li></ul><h3 id="布隆过滤器的优势"><a href="#布隆过滤器的优势" class="headerlink" title="布隆过滤器的优势"></a>布隆过滤器的优势</h3><ol><li><p>内存效率高:</p><ul><li><p>布隆过滤器相比于哈希表或其他数据结构具有极高的内存效率，尤其在处理大量数据时尤为显著。它通过位数组来表示元素是否存在，而不需要存储元素本身，因此节省了大量空间。</p></li><li><p>通过调整过滤器的参数（如哈希函数数量、位数组大小等），可以在一定范围内控制误判率和内存占用之间的平衡。</p></li></ul></li><li><p>高效的查询速度:</p><ul><li><p>布隆过滤器的查询速度非常快，因为它只需要通过多个哈希函数对元素进行多次哈希计算，然后检查位数组的若干个位置是否为 1，这一过程通常是 O(1) 时间复杂度。</p></li><li><p>在高并发环境中，布隆过滤器能够保持很高的性能，适合对大量数据进行快速判断。</p></li></ul></li><li><p>无锁并发读写:</p><ul><li>布隆过滤器可以在没有锁机制的情况下进行并发读写操作。由于其操作过程仅涉及哈希函数的计算和位数组的更新，不存在复杂的数据竞争问题，因此适合在多线程环境下使用。</li></ul></li><li><p>可灵活调整误判率： 布隆过滤器的误判率是可以通过配置来调整的。通过选择合适的哈希函数数量和位数组大小，可以在内存占用和误判率之间找到最佳平衡点。</p></li></ol><h3 id="布隆过滤器的缺点"><a href="#布隆过滤器的缺点" class="headerlink" title="布隆过滤器的缺点"></a>布隆过滤器的缺点</h3><ol><li><p>存在误判（假阳性）：</p><ul><li><p>布隆过滤器会出现假阳性，即可能会误判一个元素存在于集合中，但实际上它并不在集合中。这是因为不同元素的哈希值可能映射到相同的位置，导致误判。</p></li><li><p>误判率可以通过增加位数组大小和哈希函数数量来降低，但无法完全避免。误判率的大小与布隆过滤器的设计参数相关联。</p></li></ul></li><li><p>不支持删除操作：</p><ul><li><p>一旦某个元素被插入到布隆过滤器中，就无法直接删除该元素。因为删除某个元素会影响其他元素的哈希值映射，可能导致其他元素的查询结果出现错误。因此，布隆过滤器适合那些只增不删的场景。</p></li><li><p>有改进版本如计数布隆过滤器（Counting Bloom Filter），通过计数器来实现删除功能，但内存开销相对增加。</p></li></ul></li><li><p>误判率随数据量增加而上升：</p><ul><li><p>随着插入的元素增多，布隆过滤器的误判率会增加。这是因为哈希映射的位位置会越来越多地被填满，导致更多的哈希冲突。如果要维持较低的误判率，必须预估好数据量，并设置足够大的位数组。</p></li><li><p>如果未能提前规划好数据量，布隆过滤器的性能和准确性会随着数据量的增加而下降。</p></li></ul></li><li><p>不支持获取元素： 布隆过滤器只能判断某个元素是否存在，而无法获取元素的实际值或相关信息。它适合用于快速筛选数据，而不能用于存储或查找具体的数据内容。</p></li></ol><h3 id="布隆过滤器的应用场景"><a href="#布隆过滤器的应用场景" class="headerlink" title="布隆过滤器的应用场景"></a>布隆过滤器的应用场景</h3><ol><li><p>防止缓存穿透：</p><ul><li><p>在分布式缓存系统中（如 Redis 缓存），缓存穿透是指查询大量不存在的 key，导致这些查询绕过缓存，直接打到数据库上，增加数据库负载。通过使用布隆过滤器，将所有可能存在的合法 key 哈希到过滤器中，查询时先判断 key 是否存在。如果布隆过滤器判定不存在，则直接返回空，避免直接访问数据库。</p></li><li><p>应用场景：电商平台、社交平台的用户请求缓存，避免频繁请求不存在的商品、帖子或用户信息。</p></li></ul></li><li><p>大规模反垃圾、黑名单过滤：</p><ul><li><p>布隆过滤器可以用于快速判断一个用户或 IP 是否在黑名单中。通过预先将黑名单数据哈希到布隆过滤器中，可以在接收到请求时快速筛查是否为黑名单用户，进行相应处理。</p></li><li><p>应用场景：反垃圾邮件系统、防火墙、恶意 IP 拦截等。</p></li></ul></li><li><p>爬虫 URL 去重：</p><ul><li><p>在网络爬虫中，爬虫需要不断记录访问过的 URL 以避免重复抓取同一页面。使用布隆过滤器可以有效地去重 URL，尤其是在处理亿级甚至更大规模的数据时。</p></li><li><p>应用场景：搜索引擎爬虫系统，避免重复抓取同一个网站或页面。</p></li></ul></li><li><p>去重系统：</p><ul><li><p>在需要高效去重的场景下，布隆过滤器能够快速判断元素是否已经存在，例如日志系统中去除重复日志、系统中去除重复请求、数据处理中去除重复记录等。</p></li><li><p>应用场景：大数据去重、日志去重等。</p></li></ul></li><li><p>区块链和 P2P 网络：</p><ul><li><p>在区块链和 P2P 网络中，布隆过滤器常用于交易或消息的快速检索。例如，在比特币网络中，布隆过滤器被用于快速查询节点是否包含某些特定交易信息，从而减少网络通信和存储开销。</p></li><li><p>应用场景：区块链交易过滤、P2P 网络节点消息过滤。</p></li></ul></li><li><p>搜索引擎中的关键词匹配：</p><ul><li><p>搜索引擎中的关键词查询可以利用布隆过滤器快速判断关键词是否存在于索引中，减少不必要的磁盘访问。</p></li><li><p>应用场景：关键词匹配、广告系统中的点击去重。</p></li></ul></li></ol><h3 id="安装-RedisBloom模块"><a href="#安装-RedisBloom模块" class="headerlink" title="安装 RedisBloom模块"></a>安装 RedisBloom模块</h3><p>访问官网：<a href="https://github.com/RedisBloom/RedisBloom%EF%BC%8C%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%89%88%E6%9C%AC%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E3%80%82">https://github.com/RedisBloom/RedisBloom，选择合适的版本进行下载安装。</a></p><h2 id="编译RedisBloom源码"><a href="#编译RedisBloom源码" class="headerlink" title="编译RedisBloom源码"></a>编译RedisBloom源码</h2><p>在Linux环境下，执行命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -zxvf RedisBloom-<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">18</span>.tar.gz<br></code></pre></td></tr></table></figure><p>解压完成后，在 <code>/RedisBloom-2.2.18</code> 文件夹中，就可以看到编译好的 <code>redisbloom.so</code> 文件了。</p><h2 id="新建-modules-文件夹"><a href="#新建-modules-文件夹" class="headerlink" title="新建 modules 文件夹"></a>新建 modules 文件夹</h2><p>在 F:\Docker\Redis 目录下创建一个 &#x2F;modules 模块文件夹，如下：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250130163403754.png"></p><p>将编译好的 redisbloom.so 文件放进去。</p><h2 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h2><p>编辑 F:\Docker\Redis\conf 配置文件，搜索关键字 loadmodule ，找到配置加载模块的位置。</p><p>添加配置：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">loadmodule <span class="hljs-regexp">/etc/</span>redis<span class="hljs-regexp">/modules/</span>redisbloom.so<br></code></pre></td></tr></table></figure><h2 id="更新-Redis-容器"><a href="#更新-Redis-容器" class="headerlink" title="更新 Redis 容器"></a>更新 Redis 容器</h2><p>删除原本的Redis容器，执行以下语句创建新容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs BASH">docker run -p 6379:6379 --name redis -v F:\Docker\Redis\conf\redis.conf:/etc/redis/redis.conf -v F:\Docker\Redis\data:/data -v F:\Docker\Redis\modules:/etc/redis/modules -d redis:7.2.3 redis-server /etc/redis/redis.conf --appendonly <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><p>新增命令参数：<code>-v F:\Docker\Redis\modules:/etc/redis/modules</code>，目的是为了将模块存放的文件夹挂载到宿主机中。</p><p>执行完成后，输入以下指令查看是否挂载成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs -f redis<br></code></pre></td></tr></table></figure><p>若有 <code>Module &#39;bf&#39; loaded from /etc/redis/modules/redisbloom.so</code> 提示信息，则表示 RedisBloom 模块加载成功了。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250130163843100.png"></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL建表问题</title>
    <link href="/2025/01/30/MySQL%E5%BB%BA%E8%A1%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2025/01/30/MySQL%E5%BB%BA%E8%A1%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>零拷贝技术</title>
    <link href="/2025/01/30/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/"/>
    <url>/2025/01/30/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要有DMA技术？"><a href="#为什么要有DMA技术？" class="headerlink" title="为什么要有DMA技术？"></a>为什么要有DMA技术？</h1><p>没有DMA技术之前，I&#x2F;O过程：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250130100216921.png"></p><p>什么是 DMA 技术？简单理解就是，在进行 I&#x2F;O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250130100321446.png"></p><p>CPU 不再参与「将数据从磁盘控制器缓冲区搬运到内核空间」的工作，这部分工作全程由 DMA 完成。</p><h1 id="传统的文件传输"><a href="#传统的文件传输" class="headerlink" title="传统的文件传输"></a>传统的文件传输</h1><p>传统 I&#x2F;O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I&#x2F;O 接口从磁盘读取或写入。</p><p>代码通常如下，一般会需要两个系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">read(file, tmp_buf, len);<br>write(socket, temp_buf, len);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250130100552240.png"></p><p>期间共发生了 4 次用户态与内核态的上下文切换，因为发生了两次系统调用，一次是 <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p><p>还发生了 4 次数据拷贝，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的：</p><ul><li><p>第一次拷贝，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</p></li><li><p>第二次拷贝，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</p></li><li><p>第三次拷贝，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</p></li><li><p>第四次拷贝，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</p></li></ul><h2 id="如何优化文件传输性能？"><a href="#如何优化文件传输性能？" class="headerlink" title="如何优化文件传输性能？"></a>如何优化文件传输性能？</h2><p>一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。 </p><p>所以，要想减少上下文切换到次数，就要减少系统调用的次数。</p><p>传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。</p><p>因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此用户的缓冲区是没有必要存在的。</p><h1 id="如何实现零拷贝？"><a href="#如何实现零拷贝？" class="headerlink" title="如何实现零拷贝？"></a>如何实现零拷贝？</h1><p>零拷贝技术实现方法通常有两种：</p><ul><li><p>mmap + write</p></li><li><p>sendfile</p></li></ul><h2 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a>mmap + write</h2><p><code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">buf = mmap(file, len);<br>write(sockfd, buf, len);<br></code></pre></td></tr></table></figure><p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250130101225805.png"></p><ul><li><p>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区； </p></li><li><p>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据； </p></li><li><p>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</p></li></ul><p>我们可以得知，通过使用 <code>mmap()</code> 来代替 <code>read()</code>， 可以减少一次数据拷贝的过程。  </p><p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p><h2 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h2><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 sendfile()，函数形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendfile</span><span class="hljs-params">(<span class="hljs-type">int</span> out_fd, <span class="hljs-type">int</span> in_fd, <span class="hljs-type">off_t</span> *offset, <span class="hljs-type">size_t</span> count)</span>;<br></code></pre></td></tr></table></figure><p>它可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。  </p><p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250130101722809.png"></p><p>如果网卡支持 SG-DMA（The Scatter-Gather Direct Memory Access）技术（和普通的 DMA 有所不同），可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p><p>在Linux系统下执行指令，查看网卡是否支持SG-DMA技术：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">echo</span> -k eth0 | grep scatter-gather<br></code></pre></td></tr></table></figure><p>对于支持网卡支持 SG-DMA 技术的情况下， sendfile() 系统调用的过程发生了点变化，具体过程如下： </p><ul><li><p>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里； </p></li><li><p>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</p></li></ul><p>整个过程只发生了两次数据拷贝：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250130102235263.png"></p><p>这就是所谓的零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</p><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</p><h2 id="使用零拷贝技术的项目"><a href="#使用零拷贝技术的项目" class="headerlink" title="使用零拷贝技术的项目"></a>使用零拷贝技术的项目</h2><p>Kafka 和 Nginx 都有实现零拷贝技术，这将大大提高文件传输的性能。  </p><p>零拷贝技术是基于 PageCache 的，PageCache 会缓存最近访问的数据，提升了访问缓存数据的性能，同时，为了解决机械硬盘寻址慢的问题，它还协助 I&#x2F;O 调度算法实现了 IO 合并与预读，这也是顺序读比随机读性能好的原因。这些优势，进一步提升了零拷贝的性能。  </p><p>需要注意的是，零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送。  </p><p>另外，当传输大文件时，不能使用零拷贝，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，并且大文件的缓存命中率不高，这时就需要使用「异步 IO + 直接 IO 」的方式。  </p><p>在 Nginx 里，可以通过配置，设定一个文件大小阈值，针对大文件使用异步 IO 和直接 IO，而对小文件使用零拷贝。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO模型</title>
    <link href="/2025/01/30/IO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/01/30/IO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="最基本的-Socket-模型"><a href="#最基本的-Socket-模型" class="headerlink" title="最基本的 Socket 模型"></a>最基本的 Socket 模型</h1><p>客户端与服务器间通信，必须使用Socket编程，创建Socket时，可以指定网络层使用IPV4或者IPV6，传输层使用UDP还是TCP。</p><p>服务器端的Socket编程过程：</p><p>服务端首先调用 <code>socket()</code> 函数，创建网络协议为 IPv4，以及传输协议为 TCP 的 Socket ，接着调用 <code>bind()</code> 函数，给这个 Socket 绑定一个 IP 地址和端口。</p><ul><li><p>绑定端口的目的：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到我们的应用程序，然后把数据传递给我们。 </p></li><li><p>绑定 IP 地址的目的：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给我们。</p></li></ul><p>绑定完 IP 地址和端口后，就可以调用 <code>listen()</code> 函数进行监听，此时对应 TCP 状态图中的 <code>listen</code>，如果我们要判定服务器中一个网络程序有没有启动，可以通过 <code>netstat</code> 命令查看对应的端口号是否有被监听。 </p><p>服务端进入了监听状态后，通过调用 <code>accept()</code> 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。</p><p>客户端在创建好 Socket 后，调用 <code>connect()</code> 函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号， TCP 三次握手开始。</p><p>TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列： </p><ul><li><p>一个是「还没完全建立」连接的队列，称为 TCP 半连接队列，这个队列都是没有完成三次握手的连接，此时服务端处于 <code>syn_rcvd</code> 的状态； </p></li><li><p>一个是「已经建立」连接的队列，称为 TCP 全连接队列，这个队列都是完成了三次握手的连接，此时服务端处于 <code>established</code> 状态；</p></li></ul><p>当 TCP 全连接队列不为空后，服务端的 <code>accept()</code> 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。 </p><p>注意，监听的 Socket 和真正用来传数据的 Socket 是两个： </p><ul><li>一个叫作监听 Socket； </li><li>一个叫作已连接 Socket；</li></ul><p>连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 <code>read()</code> 和 <code>write()</code> 函数来读写数据。 至此， TCP 协议的 Socket 程序的调用过程就结束了。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250130092238363.png"></p><h1 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h1><p>BIO（Blocking IO） 是最传统的IO模型，也称为同步阻塞IO。它实现的是同步阻塞模型，即服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理。如果这个连接不做任何事情会造成不必要的线程开销，并且线程在进行IO操作期间是被阻塞的，无法进行其他任务。在高并发环境下，BIO的性能较差，因为它需要为每个连接创建一个线程，而且线程切换开销较大，不过可以通过线程池机制改善。BIO适合一些简单的、低频的、短连接的通信场景，例如HTTP请求。</p><p>优缺点<br>优点：</p><ul><li><p>简单易用： BIO模型的编程方式相对简单，易于理解和使用。</p></li><li><p>可靠性高： 由于阻塞特性，IO操作的结果是可靠的。</p></li></ul><p>缺点：</p><ul><li><p>阻塞等待： 当一个IO操作被阻塞时，线程会一直等待，无法执行其他任务，导致资源浪费。</p></li><li><p>并发能力有限： 每个连接都需要一个独立的线程，当连接数增加时，线程数量也会增加，造成资源消耗和性能下降。<br>由于I&#x2F;O操作是同步的，客户端的连接需要等待服务器响应，会降低系统的整体性能。</p></li></ul><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>NIO是Java 1.4引入的新IO模型，也称为同步非阻塞IO，它提供了一种基于事件驱动的方式来处理I&#x2F;O操作。</p><p>相比于传统的BIO模型，NIO采用了Channel、Buffer和Selector等组件，线程可以对某个IO事件进行监听，并继续执行其他任务，不需要阻塞等待。当IO事件就绪时，线程会得到通知，然后可以进行相应的操作，实现了非阻塞式的高伸缩性网络通信。在NIO模型中，数据总是从Channel读入Buffer，或者从Buffer写入Channel，这种模式提高了IO效率，并且可以充分利用系统资源。</p><p>NIO主要由三部分组成：选择器（Selector）、缓冲区（Buffer）和通道（Channel）。Channel是一个可以进行数据读写的对象，所有的数据都通过Buffer来处理，这种方式避免了直接将字节写入通道中，而是将数据写入包含一个或者多个字节的缓冲区。在多线程模式下，一个线程可以处理多个请求，这是通过将客户端的连接请求注册到多路复用器上，然后由多路复用器轮询到连接有I&#x2F;O请求时进行处理。</p><p>对于NIO，如果从特性来看，它是非阻塞式IO，N是Non-Blocking的意思；如果从技术角度，NIO对于BIO来说是一个新技术，N的意思是New的意思。所以NIO也常常被称作Non-Blocking I&#x2F;O或New I&#x2F;O。</p><p>NIO适用于连接数目多且连接比较短（轻操作）的架构，例如聊天服务器、弹幕系统、服务器间通讯等。它通过引入非阻塞通道的概念，提高了系统的伸缩性和并发性能。同时，NIO的使用也简化了程序编写，提高了开发效率。</p><p>优缺点<br>优点：</p><ul><li><p>高并发性： 使用选择器（Selector）和通道（Channel）的NIO模型可以在单个线程上处理多个连接，提供更高的并发性能。</p></li><li><p>节省资源： 相对于BIO，NIO需要更少的线程来处理相同数量的连接，节省了系统资源。</p></li><li><p>灵活性： NIO提供了多种类型的Channel和Buffer，可以根据需要选择适合的类型。NIO允许开发人员自定义协议、编解码器等组件，从而提高系统的灵活性和可扩展性。</p></li><li><p>高性能： NIO采用了基于通道和缓冲区的方式来读写数据，这种方式比传统的流模式更高效。可以减少数据拷贝次数，提高数据处理效率。</p></li><li><p>内存管理：NIO允许用户手动管理缓冲区的内存分配和回收，避免了传统I&#x2F;O模型中的内存泄漏问题。</p></li></ul><p>缺点：</p><ul><li><p>编程复杂： 相对于BIO，NIO的编程方式更加复杂，需要理解选择器和缓冲区等概念，也需要考虑多线程处理和同步问题。</p></li><li><p>可靠性较低： NIO模型中，一个连接的读写操作是非阻塞的，无法保证IO操作的结果是可靠的，可能会出现部分读写或者错误的数据。</p></li></ul><h1 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h1><p>Java AIO（Asynchronous I&#x2F;O）是Java提供的异步非阻塞IO编程模型，从Java 7版本开始支持，AIO又称NIO 2.0。</p><p>相比于NIO模型，AIO模型更进一步地实现了异步非阻塞IO，提高了系统的并发性能和伸缩性。在NIO模型中，虽然可以通过多路复用器处理多个连接请求，但仍需要在每个连接上进行读写操作，这仍然存在一定的阻塞。而在AIO模型中，所有的IO操作都是异步的，不会阻塞任何线程，可以更好地利用系统资源。</p><p>AIO模型有以下特性：</p><ul><li><p>异步能力：AIO模型的最大特性是异步能力，对于socket和I&#x2F;O操作都有效。读写操作都是异步的，完成后会自动调用回调函数。</p></li><li><p>回调函数：在AIO模型中，当一个异步操作完成后，会通知相关线程进行后续处理，这种处理方式称为“回调”。回调函数可以由开发者自行定义，用于处理异步操作的结果。</p></li><li><p>非阻塞：AIO模型实现了完全的异步非阻塞IO，不会阻塞任何线程，可以更好地利用系统资源。</p></li><li><p>高性能：由于AIO模型的异步能力和非阻塞特性，它可以更好地处理高并发、高伸缩性的网络通信场景，进一步提高系统的性能和效率。</p></li><li><p>操作系统支持：AIO模型需要操作系统的支持，因此在不同的操作系统上可能会有不同的表现。在Linux内核2.6版本之后增加了对真正异步IO的实现。</p></li></ul><p>优缺点<br>优点：</p><ul><li><p>非阻塞：AIO的主要优点是它是非阻塞的。这意味着在读写操作进行时，程序可以继续执行其他任务。这对于需要处理大量并发连接的高性能服务器来说是非常有用的。</p></li><li><p>高效：由于AIO可以处理大量并发连接，因此它通常比同步I&#x2F;O（例如Java的传统I&#x2F;O和NIO）更高效。</p></li><li><p>简化编程模型：AIO使用了回调函数，这使得编程模型相对简单。当一个操作完成时，会自动调用回调函数，无需程序员手动检查和等待操作的完成。</p></li></ul><p>缺点：</p><ul><li><p>复杂性：虽然AIO的编程模型相对简单，但是由于其非阻塞的特性，编程复杂性可能会增加。例如，需要处理操作完成的通知，以及可能的并发问题。</p></li><li><p>资源消耗：AIO可能会消耗更多的系统资源。因为每个操作都需要创建一个回调函数，如果并发连接数非常大，可能会消耗大量的系统资源。</p></li><li><p>可移植性：AIO在某些平台上可能不可用或者性能不佳。因此，如果需要跨平台的可移植性，可能需要考虑使用其他I&#x2F;O模型。</p></li></ul><h1 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h1><p>当服务器与客户端 TCP 完成连接后，通过 <code>pthread_create()</code> 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。</p><p>如果每来一个连接就创建一个线程，线程运行完后，还得操作系统还得销毁线程，虽说线程切换的上写文开销不大，但是如果频繁创建和销毁线程，系统开销也是不小的。</p><p>那么，我们可以使用线程池的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250130092640930.png"></p><p>新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程&#x2F;线程，操作系统就算死扛也是扛不住的。</p><h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><p>一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。</p><p>我们熟悉的 <code>select/poll/epoll</code> 内核提供给用户态的多路复用系统调用，进程可以通过一个系统调用函数从内核中获取多个事件。</p><p><code>select/poll/epoll</code> 是如何获取网络事件的呢？在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。</p><h2 id="select-poll"><a href="#select-poll" class="headerlink" title="select&#x2F;poll"></a>select&#x2F;poll</h2><p>select 实现多路复用的方式是，将已连接的 Socket 都放到一个文件描述符集合，然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。</p><p>所以，对于 select 这种方式，需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里 ，而且还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p><p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 1024，只能监听 0~1023 的文件描述符。</p><p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p><p>poll 和 select 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>第一点，epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)。而 select&#x2F;poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select&#x2F;poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。 </p><p>第二点， epoll 使用事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250130095151250.png"></p><h3 id="边缘触发和水平触发"><a href="#边缘触发和水平触发" class="headerlink" title="边缘触发和水平触发"></a>边缘触发和水平触发</h3><p>epoll 支持两种事件触发模式，分别是边缘触发（edge-triggered，ET）和水平触发（level-triggered，LT）。</p><ul><li><p>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，服务器端只会从 epoll_wait 中苏醒一次，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；</p></li><li><p>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束，目的是告诉我们有数据需要读取；</p></li></ul><p>select&#x2F;poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。 使用 I&#x2F;O 多路复用时，最好搭配非阻塞 I&#x2F;O 一起使用。</p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Future类相关</title>
    <link href="/2025/01/29/Future%E7%B1%BB%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/01/29/Future%E7%B1%BB%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li>取消任务；</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// V 代表了Future执行的任务返回值的类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br>    <span class="hljs-comment">// 取消任务执行</span><br>    <span class="hljs-comment">// 成功取消返回 true，否则返回 false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span>;<br>    <span class="hljs-comment">// 判断任务是否被取消</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 判断任务是否已经执行完成</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 获取任务执行结果</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br>    <span class="hljs-comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutExceptio<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Callable-与-Future有什么关系？"><a href="#Callable-与-Future有什么关系？" class="headerlink" title="Callable 与 Future有什么关系？"></a>Callable 与 Future有什么关系？</h1><p><code>FutureTask</code> 提供了 <code>Future</code> 接口的基本实现，常用来封装 <code>Callable</code> 和 <code>Runnable</code>，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。<code>ExecutorService.submit()</code> 方法返回的其实就是 <code>Future</code> 的实现类 <code>FutureTask</code> 。</p><p><code>FutureTask</code> 不光实现了 <code>Future</code>接口，还实现了<code>Runnable</code> 接口，因此可以作为任务直接被线程执行。</p><p><code>FutureTask</code> 有两个构造函数，可传入 <code>Callable</code> 或者 <code>Runnable</code> 对象。实际上，传入 <code>Runnable</code> 对象也会在方法内部转换为 <code>Callable</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.callable = callable;<br>    <span class="hljs-built_in">this</span>.state = NEW;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>    <span class="hljs-comment">// 通过适配器RunnableAdapter来将Runnable对象runnable转换成Callable对象</span><br>    <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>    <span class="hljs-built_in">this</span>.state = NEW;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FutureTask</code> 相当于对 <code>Callable</code> 进行了封装，管理着任务执行的情况，存储了 <code>Callable</code> 的 <code>call</code> 方法的任务执行结果。</p><h1 id="CompletableFuture-类有什么用？"><a href="#CompletableFuture-类有什么用？" class="headerlink" title="CompletableFuture 类有什么用？"></a>CompletableFuture 类有什么用？</h1><p><code>Future</code> 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 <code>get()</code> 方法为阻塞调用。</p><p><code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p><h2 id="一个任务需要依赖另外两个任务执行完之后再执行，怎么设计？"><a href="#一个任务需要依赖另外两个任务执行完之后再执行，怎么设计？" class="headerlink" title="一个任务需要依赖另外两个任务执行完之后再执行，怎么设计？"></a>一个任务需要依赖另外两个任务执行完之后再执行，怎么设计？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// T1</span><br>CompletableFuture&lt;Void&gt; futureT1 = CompletableFuture.runAsync(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;T1 is executing. Current time：&quot;</span> + DateUtil.now());<br>    <span class="hljs-comment">// 模拟耗时操作</span><br>    ThreadUtil.sleep(<span class="hljs-number">1000</span>);<br>&#125;);<br><span class="hljs-comment">// T2</span><br>CompletableFuture&lt;Void&gt; futureT2 = CompletableFuture.runAsync(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;T2 is executing. Current time：&quot;</span> + DateUtil.now());<br>    ThreadUtil.sleep(<span class="hljs-number">1000</span>);<br>&#125;);<br><br><span class="hljs-comment">// 使用allOf()方法合并T1和T2的CompletableFuture，等待它们都完成</span><br>CompletableFuture&lt;Void&gt; bothCompleted = CompletableFuture.allOf(futureT1, futureT2);<br><span class="hljs-comment">// 当T1和T2都完成后，执行T3</span><br>bothCompleted.thenRunAsync(() -&gt; System.out.println(<span class="hljs-string">&quot;T3 is executing after T1 and T2 have completed.Current time：&quot;</span> + DateUtil.now()));<br><span class="hljs-comment">// 等待所有任务完成，验证效果</span><br>ThreadUtil.sleep(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><h2 id="使用-CompletableFuture，有一个任务失败，如何处理异常？"><a href="#使用-CompletableFuture，有一个任务失败，如何处理异常？" class="headerlink" title="使用 CompletableFuture，有一个任务失败，如何处理异常？"></a>使用 CompletableFuture，有一个任务失败，如何处理异常？</h2><ul><li><p>使用 <code>whenComplete</code> 方法可以在任务完成时触发回调函数，并正确地处理异常，而不是让异常被吞噬或丢失。</p></li><li><p>使用 <code>exceptionally</code> 方法可以处理异常并重新抛出，以便异常能够传播到后续阶段，而不是让异常被忽略或终止。</p></li><li><p>使用 <code>handle</code> 方法可以处理正常的返回结果和异常，并返回一个新的结果，而不是让异常影响正常的业务逻辑。</p></li><li><p>使用 <code>CompletableFuture.allOf</code> 方法可以组合多个 <code>CompletableFuture</code>，并统一处理所有任务的异常，而不是让异常处理过于冗长或重复。</p></li></ul><h2 id="在使用-CompletableFuture-的时候为什么要自定义线程池？"><a href="#在使用-CompletableFuture-的时候为什么要自定义线程池？" class="headerlink" title="在使用 CompletableFuture 的时候为什么要自定义线程池？"></a>在使用 CompletableFuture 的时候为什么要自定义线程池？</h2><ul><li>隔离性：为不同任务分配独立的线程池，避免全局线程池资源争夺。</li><li>资源控制：根据任务特性调整线程池大小和队列类型，优化性能表现。</li><li>异常处理：通过自定义 <code>ThreadFactory</code> 更好地处理线程中的异常情况。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2025/01/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2025/01/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h1><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h1 id="创建线程池的常见方法"><a href="#创建线程池的常见方法" class="headerlink" title="创建线程池的常见方法"></a>创建线程池的常见方法</h1><p>方式一：通过ThreadPoolExecutor构造函数来创建</p><p>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</p><h2 id="为什么不推荐使用内置线程池？"><a href="#为什么不推荐使用内置线程池？" class="headerlink" title="为什么不推荐使用内置线程池？"></a>为什么不推荐使用内置线程池？</h2><p><code>Executors</code> 返回线程池对象的弊端如下：</p><ul><li><p><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>:使用的是有界阻塞队列是 <code>LinkedBlockingQueue</code> ，其任务队列的最大长度为 <code>Integer.MAX_VALUE</code> ，可能堆积大量的请求，从而导致 OOM。</p></li><li><p><code>CachedThreadPool</code>:使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。</p></li><li><p><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> :使用的无界的延迟阻塞队列 <code>DelayedWorkQueue</code> ，任务队列最大长度为 <code>Integer.MAX_VALUE</code> ，可能堆积大量的请求，从而导致 OOM。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 有界队列 LinkedBlockingQueue</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br><br>&#125;<br><br><span class="hljs-comment">// 无界队列 LinkedBlockingQueue</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br><br>&#125;<br><br><span class="hljs-comment">// 同步队列 SynchronousQueue，没有容量，最大线程数是 Integer.MAX_VALUE`</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<span class="hljs-number">60L</span>, TimeUnit.SECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br><br>&#125;<br><br><span class="hljs-comment">// DelayedWorkQueue（延迟阻塞队列）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程池常见参数"><a href="#线程池常见参数" class="headerlink" title="线程池常见参数"></a>线程池常见参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,//线程池的核心线程数量</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,//线程池的最大线程数</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="hljs-params">                          TimeUnit unit,//时间单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span><br><span class="hljs-params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="hljs-params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br><span class="hljs-params">                           )</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>    <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ThreadPoolExecutor</code>常见参数 :</p><ul><li><code>corePoolSize</code> : 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><code>maximumPoolSize</code> : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><code>workQueue</code>: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li><li><code>keepAliveTime</code>:当线程池中的线程数量大于 <code>corePoolSize</code> ，即有非核心线程（线程池中核心线程以外的线程）时，这些非核心线程空闲后不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code> 才会被回收销毁。</li><li><code>unit</code> : keepAliveTime 参数的时间单位。</li><li><code>threadFactory</code> :executor 创建新线程的时候会用到。</li><li><code>handler</code> :拒绝策略。</li></ul><h2 id="线程池的核心线程会被回收吗？"><a href="#线程池的核心线程会被回收吗？" class="headerlink" title="线程池的核心线程会被回收吗？"></a>线程池的核心线程会被回收吗？</h2><p><code>ThreadPoolExecutor</code> 默认不会回收核心线程，即使它们已经空闲了。这是为了减少创建线程的开销，因为核心线程通常是要长期保持活跃的。但是，如果线程池是被用于周期性使用的场景，且频率不高（周期之间有明显的空闲时间），可以考虑将 <code>allowCoreThreadTimeOut(boolean value)</code> 方法的参数设置为 true，这样就会回收空闲（时间间隔由 <code>keepAliveTime</code> 指定）的核心线程了。</p><h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><ul><li><code>ThreadPoolExecutor.AbortPolicy</code>：抛出 <code>RejectedExecutionException</code> 来拒绝新任务的处理。</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：调用执行者自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果你的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：此策略将丢弃最早的未处理的任务请求。</li></ul><h2 id="线程池常用的阻塞队列"><a href="#线程池常用的阻塞队列" class="headerlink" title="线程池常用的阻塞队列"></a>线程池常用的阻塞队列</h2><ul><li><p>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（有界阻塞队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code> 。<code>FixedThreadPool</code>最多只能创建核心线程数的线程（核心线程数和最大线程数相等），<code>SingleThreadExecutor</code>只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。 </p></li><li><p><code>SynchronousQueue</code>（同步队列）：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。 </p></li><li><p><code>DelayedWorkQueue</code>（延迟队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容，增加原来容量的 50%，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。 </p></li><li><p><code>ArrayBlockingQueue</code>（有界阻塞队列）：底层由数组实现，容量一旦创建，就不能修改。</p></li></ul><h2 id="线程池处理任务的流程"><a href="#线程池处理任务的流程" class="headerlink" title="线程池处理任务的流程"></a>线程池处理任务的流程</h2><ol><li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li><li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li><li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li><li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，拒绝策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ol><p><code>ThreadPoolExecutor</code> 提供了两个方法帮助我们在提交任务之前，完成核心线程的创建，从而实现线程池预热的效果：</p><ul><li><code>prestartCoreThread()</code>:启动一个线程，等待任务，如果已达到核心线程数，这个方法返回 false，否则返回 true；</li><li><code>prestartAllCoreThreads()</code>:启动所有的核心线程，并返回启动成功的核心线程数。</li></ul><h2 id="线程池中线程异常过后，中断还是复用？"><a href="#线程池中线程异常过后，中断还是复用？" class="headerlink" title="线程池中线程异常过后，中断还是复用？"></a>线程池中线程异常过后，中断还是复用？</h2><ul><li><p>使用<code>execute()</code>提交任务：当任务通过<code>execute()</code>提交到线程池并在执行过程中抛出异常时，如果这个异常没有在任务内被捕获，那么该异常会导致当前线程终止，并且异常会被打印到控制台或日志文件中。线程池会检测到这种线程终止，并创建一个新线程来替换它，从而保持配置的线程数不变。使用submit()提交任务：</p></li><li><p>对于通过<code>submit()</code>提交的任务，如果在任务执行中发生异常，这个异常不会直接打印出来。相反，异常会被封装在由<code>submit()</code>返回的<code>Future</code>对象中。当调用<code>Future.get()</code>方法时，可以捕获到一个<code>ExecutionException</code>。在这种情况下，线程不会因为异常而终止，它会继续存在于线程池中，准备执行后续的任务。</p></li></ul><h2 id="如何给线程池命名？"><a href="#如何给线程池命名？" class="headerlink" title="如何给线程池命名？"></a>如何给线程池命名？</h2><ol><li>利用 guava 的 <code>ThreadFactoryBuilder</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactoryBuilder</span>()<br>                        .setNameFormat(threadNamePrefix + <span class="hljs-string">&quot;-%d&quot;</span>)<br>                        .setDaemon(<span class="hljs-literal">true</span>).build();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);<br></code></pre></td></tr></table></figure><ol start="2"><li>自己实现 <code>ThreadFactory</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ThreadFactory;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个带名字的线程池生产工厂</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NamingThreadFactory</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>        t.setName(name + <span class="hljs-string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="hljs-string">&quot;]&quot;</span>);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如何设定线程池大小？"><a href="#如何设定线程池大小？" class="headerlink" title="如何设定线程池大小？"></a>如何设定线程池大小？</h2><ul><li><p>CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p></li><li><p>I&#x2F;O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p></li></ul><h2 id="如何动态修改线程池参数？"><a href="#如何动态修改线程池参数？" class="headerlink" title="如何动态修改线程池参数？"></a>如何动态修改线程池参数？</h2><p>自定义一个叫做 <code>ResizableCapacityLinkedBlockIngQueue</code> 的队列（主要就是把<code>LinkedBlockingQueue</code>的 capacity 字段的 final 关键字修饰给去掉了，让它变为可变的）。</p><h2 id="如何设计一个能够根据任务的优先级来执行的线程池？"><a href="#如何设计一个能够根据任务的优先级来执行的线程池？" class="headerlink" title="如何设计一个能够根据任务的优先级来执行的线程池？"></a>如何设计一个能够根据任务的优先级来执行的线程池？</h2><p>需要实现一个优先级任务线程池的话，那可以考虑使用 <code>PriorityBlockingQueue</code> （优先级阻塞队列）作为任务队列。</p><p>要想让 <code>PriorityBlockingQueue</code> 实现对任务的排序，传入其中的任务必须是具备排序能力的，方式有两种：</p><ul><li>提交到线程池的任务实现 <code>Comparable</code> 接口，并重写 <code>compareTo</code> 方法来指定任务之间的优先级比较规则。</li><li>创建 <code>PriorityBlockingQueue</code> 时传入一个<code> Comparator</code> 对象来指定任务之间的排序规则(推荐)。</li></ul><p>不过，这存在一些风险和问题，比如：</p><ul><li><code>PriorityBlockingQueue</code> 是无界的，可能堆积大量的请求，从而导致 OOM。</li><li>可能会导致饥饿问题，即低优先级的任务长时间得不到执行。</li><li>由于需要对队列中的元素进行排序操作以及保证线程安全（并发控制采用的是可重入锁 ReentrantLock），因此会降低性能。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="/2025/01/29/ThreadLocal/"/>
    <url>/2025/01/29/ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h1 id="TheadLocal有什么用？"><a href="#TheadLocal有什么用？" class="headerlink" title="TheadLocal有什么用？"></a>TheadLocal有什么用？</h1><p><code>ThreadLocal</code> 类允许每个线程绑定自己的值，可以将其形象地比喻为一个“存放数据的盒子”。每个线程都有自己独立的盒子，用于存储私有数据，确保不同线程之间的数据互不干扰。</p><p>创建一个 <code>ThreadLocal</code> 变量时，每个访问该变量的线程都会拥有一个独立的副本。这也是 <code>ThreadLocal</code> 名称的由来。线程可以通过 <code>get()</code> 方法获取自己线程的本地副本，或通过 <code>set()</code> 方法修改该副本的值，从而避免了线程安全问题。</p><h1 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h1><p><code>Thread</code>类源代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">//......</span><br>    <span class="hljs-comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p><p>ThreadLocal类的set()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">//获取当前请求的线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 将需要存储的值放入到这个哈希表中</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。 <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p><p>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ThreadLocal-内存泄露问题是怎么导致的？"><a href="#ThreadLocal-内存泄露问题是怎么导致的？" class="headerlink" title="ThreadLocal 内存泄露问题是怎么导致的？"></a>ThreadLocal 内存泄露问题是怎么导致的？</h1><p><code>ThreadLocal</code> 内存泄漏的根本原因在于其内部实现机制。</p><p>每个线程维护一个名为 <code>ThreadLocalMap</code> 的 map。 当你使用 <code>ThreadLocal</code> 存储值时，实际上是将值存储在当前线程的 <code>ThreadLocalMap</code> 中，其中 <code>ThreadLocal</code> 实例本身作为 key，而你要存储的值作为 value。</p><p><code>ThreadLocalMap</code> 的 <code>key</code> 和 <code>value</code> 引用机制：</p><ul><li><p>key 是弱引用：<code>ThreadLocalMap</code> 中的 key 是 <code>ThreadLocal</code> 的弱引用 (<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>)。 这意味着，如果 <code>ThreadLocal</code> 实例不再被任何强引用指向，垃圾回收器会在下次 GC 时回收该实例，导致 <code>ThreadLocalMap</code> 中对应的 key 变为 <code>null</code>。</p></li><li><p>value 是强引用：<code>ThreadLocalMap</code> 中的 value 是强引用。 即使 key 被回收（变为 <code>null</code>），value 仍然存在于 <code>ThreadLocalMap</code> 中，被强引用，不会被回收。</p></li></ul><p>当 <code>ThreadLocal</code> 实例失去强引用后，其对应的 value 仍然存在于 <code>ThreadLocalMap</code> 中，因为 <code>Entry</code> 对象强引用了它。如果线程持续存活（例如线程池中的线程），<code>ThreadLocalMap</code> 也会一直存在，导致 key 为 <code>null</code> 的 entry 无法被垃圾回收，机会造成内存泄漏。</p><p>内存泄漏的发生需要同时满足两个条件：</p><ol><li><p><code>ThreadLocal</code> 实例不再被强引用；</p></li><li><p>线程持续存活，导致 <code>ThreadLocalMap</code> 长期存在。</p></li></ol><h2 id="如何跨线程传递ThreadLocal的值？"><a href="#如何跨线程传递ThreadLocal的值？" class="headerlink" title="如何跨线程传递ThreadLocal的值？"></a>如何跨线程传递ThreadLocal的值？</h2><p>如果想要在异步场景下传递 ThreadLocal 值，有两种解决方案：</p><ul><li><p><code>InheritableThreadLocal</code> ：<code>InheritableThreadLocal</code> 是 JDK1.2 提供的工具，继承自 <code>ThreadLocal</code> 。使用 <code>InheritableThreadLocal</code> 时，会在创建子线程时，令子线程继承父线程中的 <code>ThreadLocal</code> 值，但是无法支持线程池场景下的 <code>ThreadLocal</code> 值传递。</p></li><li><p><code>TransmittableThreadLocal</code> ： <code>TransmittableThreadLocal</code> （简称 TTL） 是阿里巴巴开源的工具类，继承并加强了<code>InheritableThreadLocal</code>类，可以在线程池的场景下支持 <code>ThreadLocal</code> 值传递。</p></li></ul><h3 id="InheritableThreadLocal-原理"><a href="#InheritableThreadLocal-原理" class="headerlink" title="InheritableThreadLocal 原理"></a><code>InheritableThreadLocal</code> 原理</h3><p>在 <code>Thread</code> 类中添加了一个新的 <code>ThreadLocalMap</code> ，命名为 <code>inheritableThreadLocals</code> ，该变量用于存储需要跨线程传递的 <code>ThreadLocal</code> 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过改造 <code>Thread</code> 类的构造方法来实现，在创建 <code>Thread</code> 线程时，拿到父线程的 <code>inheritableThreadLocals</code> 变量赋值给子线程即可。</p><h3 id="TransmittableThreadLocal-原理"><a href="#TransmittableThreadLocal-原理" class="headerlink" title="TransmittableThreadLocal 原理"></a><code>TransmittableThreadLocal</code> 原理</h3><p>阿里巴巴无法改动 JDK 的源码，因此他内部通过 装饰器模式 在原有的功能上做增强，以此来实现线程池场景下的 <code>ThreadLocal</code> 值传递。</p><p>TTL 改造的地方有两处：</p><ul><li><p>实现自定义的 <code>Thread</code> ，在 <code>run()</code> 方法内部做 <code>ThreadLocal</code> 变量的赋值操作。</p></li><li><p>基于 线程池 进行装饰，在 <code>execute()</code> 方法中，不提交 JDK 内部的 <code>Thread</code> ，而是提交自定义的 <code>Thread</code> 。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC</title>
    <link href="/2025/01/29/JUC/"/>
    <url>/2025/01/29/JUC/</url>
    
    <content type="html"><![CDATA[<h1 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h1><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p><ul><li>NEW: 初始状态，线程被创建出来但没有被调用 start() 。</li><li>RUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。</li><li>BLOCKED：阻塞状态，需要等待锁释放。</li><li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li>TERMINATED：终止状态，表示该线程已经运行完毕。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250129134342338.png"></p><h1 id="什么是线程上下文切换？"><a href="#什么是线程上下文切换？" class="headerlink" title="什么是线程上下文切换？"></a>什么是线程上下文切换？</h1><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 sleep(), wait() 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行。</li></ul><h1 id="Thread-sleep-与-Object-wait-对比"><a href="#Thread-sleep-与-Object-wait-对比" class="headerlink" title="Thread.sleep() 与 Object.wait() 对比"></a>Thread.sleep() 与 Object.wait() 对比</h1><p>共同点：两者都可以暂停线程的执行。</p><p>区别：</p><ul><li>sleep() 方法没有释放锁，而 wait() 方法释放了锁 。</li><li>wait() 通常被用于线程间交互&#x2F;通信，sleep()通常被用于暂停执行。</li><li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll() 方法。sleep()方法执行完成后，线程会自动苏醒，或者也可以使用 wait(long timeout) 超时后线程会自动苏醒。</li><li>sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法。为什么这样设计呢？下一个问题就会聊到。</li></ul><h1 id="可以直接调用run-方法吗？"><a href="#可以直接调用run-方法吗？" class="headerlink" title="可以直接调用run()方法吗？"></a>可以直接调用run()方法吗？</h1><p>new 一个 Thread，线程进入了新建状态。调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>产生死锁的四个必要条件：</p><ul><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li></ul><p>死锁检测：</p><ul><li>使用<code>jmap</code>、<code>jstack</code>等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，<code>jstack</code> 的输出中通常会有 <code>Found one Java-level deadlock:</code>的字样，后面会跟着死锁相关的线程信息。另外，实际项目中还可以搭配使用<code>top</code>、<code>df</code>、<code>free</code>等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高。</li><li>采用 VisualVM、JConsole 等工具进行排查。</li></ul><h1 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h1><h2 id="如何保证变量的可见性"><a href="#如何保证变量的可见性" class="headerlink" title="如何保证变量的可见性"></a>如何保证变量的可见性</h2><p><code>volatile</code> 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 <code>volatile</code> 修饰，这就指示编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。<code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p><h2 id="如何禁止指令重排序？"><a href="#如何禁止指令重排序？" class="headerlink" title="如何禁止指令重排序？"></a>如何禁止指令重排序？</h2><p>将变量声明为 <code>volatile</code> ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。</p><p>Java 中，<code>Unsafe</code> 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadFence</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">storeFence</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fullFence</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h1 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h1><h2 id="什么是悲观锁？"><a href="#什么是悲观锁？" class="headerlink" title="什么是悲观锁？"></a>什么是悲观锁？</h2><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。<br>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</p><p>Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁</p><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p><h2 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a>什么是乐观锁？</h2><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了。</p><p>Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 CAS 实现的。</p><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p><p>理论上来说：</p><ul><li><p>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</p></li><li><p>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量</p></li></ul><h3 id="如何实现乐观锁"><a href="#如何实现乐观锁" class="headerlink" title="如何实现乐观锁"></a>如何实现乐观锁</h3><h4 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h4><p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些。</p><p>版本号机制一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 <code>version</code> 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p><h4 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h4><p>CAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p><p>CAS 涉及到三个操作数：</p><ul><li>V：要更新的变量值(Var)</li><li>E：预期值(Expected)</li><li>N：拟写入的新值(New)</li></ul><p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p><p>Java中的CAS是如何实现的？</p><p> Java 中，实现 CAS（Compare-And-Swap, 比较并交换）操作的一个关键类是Unsafe。</p><p><code>Unsafe</code>类位于<code>sun.misc</code>包下，是一个提供低级别、不安全操作的类。</p><p><code>sun.misc</code>包下的<code>Unsafe</code>类提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 以原子方式更新对象字段的值。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> o        要操作的对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> offset   对象字段的内存偏移量</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> expected 期望的旧值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> x        要设置的新值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 如果值被成功更新，则返回 true；否则返回 false</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, Object expected, Object x)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 以原子方式更新 int 类型的对象字段的值。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> expected, <span class="hljs-type">int</span> x)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 以原子方式更新 long 类型的对象字段的值。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapLong</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">long</span> expected, <span class="hljs-type">long</span> x)</span>;<br></code></pre></td></tr></table></figure><h4 id="CAS-算法存在哪些问题？"><a href="#CAS-算法存在哪些问题？" class="headerlink" title="CAS 算法存在哪些问题？"></a>CAS 算法存在哪些问题？</h4><ol><li>ABA 问题</li></ol><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA”问题。</p><p>ABA 问题的解决思路是在变量前面追加上版本号或者时间戳。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(V   expectedReference,</span><br><span class="hljs-params">                             V   newReference,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> expectedStamp,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> newStamp)</span> &#123;<br>    Pair&lt;V&gt; current = pair;<br>    <span class="hljs-keyword">return</span><br>        expectedReference == current.reference &amp;&amp;<br>        expectedStamp == current.stamp &amp;&amp;<br>        ((newReference == current.reference &amp;&amp;<br>          newStamp == current.stamp) ||<br>         casPair(current, Pair.of(newReference, newStamp)));<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>循环开销时间大</li></ol><p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p><ol start="3"><li>只能保证一个共享变量的原子操作CAS</li></ol><p>操作仅能对单个共享变量有效。当需要操作多个共享变量时，CAS 就显得无能为力。不过，从 JDK 1.5 开始，Java 提供了<code>AtomicReference</code>类，这使得我们能够保证引用对象之间的原子性。通过将多个变量封装在一个对象中，我们可以使用<code>AtomicReference</code>来执行 CAS 操作。除了 <code>AtomicReference</code> 这种方式之外，还可以利用加锁来保证。</p><h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h3><p><code>synchronized</code> 是 Java 中的一个关键字，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><p>Java 早期版本中，<code>synchronized</code> 属于 重量级锁，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p><p>在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。</p><p>构造方法可以用 synchronized 修饰么？</p><p>构造方法不能使用 synchronized 关键字修饰。不过，可以在构造方法内部使用 synchronized 代码块。</p><h4 id="synchronized-底层原理"><a href="#synchronized-底层原理" class="headerlink" title="synchronized 底层原理"></a>synchronized 底层原理</h4><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 对象监视器 <code>monitor</code> 的持有权。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取而代之的是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;&#125;<br></code></pre></td></tr></table></figure><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250129143454695.png"></p><p><code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="公平锁和非公平锁有什么区别？"><a href="#公平锁和非公平锁有什么区别？" class="headerlink" title="公平锁和非公平锁有什么区别？"></a>公平锁和非公平锁有什么区别？</h2><ul><li>公平锁 : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li><li>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li></ul><h2 id="synchronized-和-ReentrantLock-有什么区别？"><a href="#synchronized-和-ReentrantLock-有什么区别？" class="headerlink" title="synchronized 和 ReentrantLock 有什么区别？"></a>synchronized 和 ReentrantLock 有什么区别？</h2><ul><li><p>两者都是可重入锁<br>可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p></li><li><p>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</p></li><li><p>ReentrantLock 比 synchronized 增加了一些高级功能</p><ul><li>等待可中断 : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说当前线程在等待获取锁的过程中，如果其他线程中断当前线程「 <code>interrupt()</code> 」，当前线程就会抛出 <code>InterruptedException</code> 异常，可以捕捉该异常进行相应处理。</li><li>可实现公平锁 : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li><li>可实现选择性通知（锁可以绑定多个条件）: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li><li>支持超时 ：<code>ReentrantLock</code> 提供了 <code>tryLock(timeout)</code> 的方法，可以指定等待获取锁的最长等待时间，如果超过了等待时间，就会获取锁失败，不会一直等待。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TopK问题</title>
    <link href="/2025/01/29/TopK%E9%97%AE%E9%A2%98/"/>
    <url>/2025/01/29/TopK%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>实现思路：</p><ol><li><p>选择小顶堆：维护当前最高的K个元素，堆顶是这K个中的最小值。新元素若大于堆顶，则替换堆顶并调整堆，确保堆中始终为Top K大元素。</p></li><li><p>插入逻辑：堆未满时直接插入；堆满时，新元素大于堆顶则替换，否则忽略。</p></li><li><p>获取排行榜：取出堆元素并按热度降序排列。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotSearchRanking</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotSearchItem</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String keyword;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> heat;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">HotSearchItem</span><span class="hljs-params">(String keyword, <span class="hljs-type">int</span> heat)</span> &#123;<br>            <span class="hljs-built_in">this</span>.keyword = keyword;<br>            <span class="hljs-built_in">this</span>.heat = heat;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHeat</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> heat;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getKeyword</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> keyword;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> keyword + <span class="hljs-string">&quot;(&quot;</span> + heat + <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityQueue&lt;HotSearchItem&gt; minHeap;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> k;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HotSearchRanking</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.k = k;<br>        <span class="hljs-comment">// 初始化小顶堆，按热度升序排序</span><br>        <span class="hljs-built_in">this</span>.minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(HotSearchItem::getHeat));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(HotSearchItem item)</span> &#123;<br>        <span class="hljs-keyword">if</span> (item == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (minHeap.size() &lt; k) &#123;<br>            minHeap.offer(item);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 仅当新元素热度大于堆顶时替换</span><br>            <span class="hljs-keyword">if</span> (item.getHeat() &gt; minHeap.peek().getHeat()) &#123;<br>                minHeap.poll();<br>                minHeap.offer(item);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;HotSearchItem&gt; <span class="hljs-title function_">getTopK</span><span class="hljs-params">()</span> &#123;<br>        List&lt;HotSearchItem&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(minHeap);<br>        <span class="hljs-comment">// 按热度降序排序以形成排行榜</span><br>        result.sort(Comparator.comparingInt(HotSearchItem::getHeat).reversed());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HotSearchRanking</span> <span class="hljs-variable">ranking</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HotSearchRanking</span>(<span class="hljs-number">3</span>);<br>        ranking.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HotSearchItem</span>(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-number">50</span>));<br>        ranking.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HotSearchItem</span>(<span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-number">30</span>));<br>        ranking.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HotSearchItem</span>(<span class="hljs-string">&quot;C++&quot;</span>, <span class="hljs-number">70</span>));<br>        ranking.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HotSearchItem</span>(<span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-number">60</span>));<br>        ranking.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HotSearchItem</span>(<span class="hljs-string">&quot;Go&quot;</span>, <span class="hljs-number">65</span>));<br><br>        List&lt;HotSearchItem&gt; top = ranking.getTopK();<br>        System.out.println(<span class="hljs-string">&quot;实时热搜排行榜TOP3:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (HotSearchItem item : top) &#123;<br>            System.out.println(item);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法确保每次插入和调整的时间复杂度为O(log K)，获取排行榜的时间复杂度为O(K log K)，适合处理实时更新的热搜数据。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go基本语法</title>
    <link href="/2025/01/28/Go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2025/01/28/Go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap源码</title>
    <link href="/2025/01/28/ConcurrentHashMap%E6%BA%90%E7%A0%81/"/>
    <url>/2025/01/28/ConcurrentHashMap%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<ol><li><p>ConcurrentHashMap 1.7</p><ol><li>存储结构</li></ol><p> Java 7 中 ConcurrentHashMap 的存储结构如上图，<code>ConcurrnetHashMap</code> 由很多个 <code>Segment</code> 组合，而每一个 <code>Segment</code> 是一个类似于 <code>HashMap</code> 的结构，所以每一个 <code>HashMap</code> 的内部可以进行扩容。但是 <code>Segment</code> 的个数一旦初始化就不能改变，默认 <code>Segment</code> 的个数是 16 个。</p><ol start="2"><li>初始化<br> 无参构造：</li></ol> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a new, empty map with a default initial capacity (16),</span><br><span class="hljs-comment"> * load factor (0.75) and concurrencyLevel (16).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);<br>&#125;<br></code></pre></td></tr></table></figure><p> 有参构造函数的内部实现逻辑：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity,<span class="hljs-type">float</span> loadFactor, <span class="hljs-type">int</span> concurrencyLevel)</span> &#123;<br><span class="hljs-comment">// 参数校验</span><br><span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br><span class="hljs-comment">// 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span><br><span class="hljs-keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)<br>    concurrencyLevel = MAX_SEGMENTS;<br><span class="hljs-comment">// Find power-of-two sizes best matching arguments</span><br><span class="hljs-comment">// 2的多少次方</span><br><span class="hljs-type">int</span> <span class="hljs-variable">sshift</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">ssize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span><br><span class="hljs-keyword">while</span> (ssize &lt; concurrencyLevel) &#123;<br>    ++sshift;<br>    ssize &lt;&lt;= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 记录段偏移量</span><br><span class="hljs-built_in">this</span>.segmentShift = <span class="hljs-number">32</span> - sshift;<br><span class="hljs-comment">// 记录段掩码</span><br><span class="hljs-built_in">this</span>.segmentMask = ssize - <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 设置容量</span><br><span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>    initialCapacity = MAXIMUM_CAPACITY;<br><span class="hljs-comment">// c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> initialCapacity / ssize;<br><span class="hljs-keyword">if</span> (c * ssize &lt; initialCapacity)<br>    ++c;<br><span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> MIN_SEGMENT_TABLE_CAPACITY;<br><span class="hljs-comment">//Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span><br><span class="hljs-keyword">while</span> (cap &lt; c)<br>    cap &lt;&lt;= <span class="hljs-number">1</span>;<br><span class="hljs-comment">// create segments and segments[0]</span><br><span class="hljs-comment">// 创建 Segment 数组，设置 segments[0]</span><br>Segment&lt;K,V&gt; s0 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="hljs-type">int</span>)(cap * loadFactor),<br>                     (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[cap]);<br>Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>[ssize];<br>UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="hljs-comment">// ordered write of segments[0]</span><br><span class="hljs-built_in">this</span>.segments = ss;<br>&#125;<br></code></pre></td></tr></table></figure></p><p> Java 7 中 ConcurrentHashMap 的初始化逻辑。</p><ul><li><p>必要参数校验。</p></li><li><p>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无参构造默认值是 16。</p></li><li><p>寻找并发级别 concurrencyLevel 之上最近的 2 的幂次方值，作为初始化容量大小，默认是 16。</p></li><li><p>记录 segmentShift 偏移量，这个值为【容量 &#x3D; 2 的 N 次方】中的 N，在后面 Put 时计算位置时会用到。默认是 32 - sshift &#x3D; 28。</p></li><li><p>记录 segmentMask，默认是 ssize - 1 &#x3D; 16 -1 &#x3D; 15。</p></li><li><p>初始化 segments[0]，默认大小为 2，负载因子 0.75，扩容阀值是 2*0.75&#x3D;1.5，插入第二个值时才会进行扩容。</p></li></ul><ol start="3"><li>put 方法源码</li></ol> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Maps the specified key to the specified value in this table.</span><br><span class="hljs-comment">* Neither the key nor the value can be null.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method</span><br><span class="hljs-comment">* with a key that is equal to the original key.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> key key with which the specified value is to be associated</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value value to be associated with the specified key</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span><br><span class="hljs-comment">*         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;</span><br><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> NullPointerException if the specified key or value is null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>Segment&lt;K,V&gt; s;<br><span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br><span class="hljs-comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span><br><span class="hljs-comment">// 其实也就是把高4位与segmentMask（1111）做与运算</span><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;<br><span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="hljs-comment">// nonvolatile; recheck</span><br>     (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="hljs-literal">null</span>) <span class="hljs-comment">//  in ensureSegment</span><br>    <span class="hljs-comment">// 如果查找到的 Segment 为空，初始化</span><br>    s = ensureSegment(j);<br><span class="hljs-keyword">return</span> s.put(key, hash, value, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the segment for the given index, creating    it and</span><br><span class="hljs-comment"> * recording in segment table (via CAS) if not  already present.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k the index</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the segment</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">private</span> Segment&lt;K,V&gt; <span class="hljs-title function_">ensureSegment</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="hljs-built_in">this</span>.segments;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> (k &lt;&lt; SSHIFT) + SBASE; <span class="hljs-comment">// raw offset</span><br>    Segment&lt;K,V&gt; seg;<br>    <span class="hljs-comment">// 判断 u 位置的 Segment 是否为null</span><br>    <span class="hljs-keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile   (ss, u)) == <span class="hljs-literal">null</span>) &#123;<br>        Segment&lt;K,V&gt; proto = ss[<span class="hljs-number">0</span>]; <span class="hljs-comment">// use segment 0    as prototype</span><br>        <span class="hljs-comment">// 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化   长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> proto.table.length;<br>        <span class="hljs-comment">// 获取0号 segment 里的 hash 表里的扩容负载因   子，所有的 segment 的 loadFactor 是相同的</span><br>        <span class="hljs-type">float</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> proto.loadFactor;<br>        <span class="hljs-comment">// 计算扩容阀值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">threshold</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(cap * lf);<br>        <span class="hljs-comment">// 创建一个 cap 容量的 HashEntry 数组</span><br>        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span>    <span class="hljs-title class_">HashEntry</span>[cap];<br>        <span class="hljs-keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.    getObjectVolatile(ss, u)) == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//     recheck</span><br>            <span class="hljs-comment">// 再次检查 u 位置的 Segment 是否为null，因 为这时可能有其他线程进行了操作</span><br>            Segment&lt;K,V&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt;(lf,   threshold, tab);<br>            <span class="hljs-comment">// 自旋检查 u 位置的 Segment 是否为null</span><br>            <span class="hljs-keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE. getObjectVolatile(ss, u))<br>                   == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 使用CAS 赋值，只会成功一次</span><br>                <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(ss,     u, <span class="hljs-literal">null</span>, seg = s))<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> seg;<br>&#125;<br></code></pre></td></tr></table></figure><p> put 一个数据时的处理流程。<br> 1.计算要 put 的 key 的位置，获取指定位置的 Segment。</p><p> 2.如果指定位置的 Segment 为空，则初始化这个 Segment。</p><p> 初始化 Segment 流程：</p><ol><li><p>检查计算得到的位置的 Segment 是否为 null。</p></li><li><p>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</p></li><li><p>再次检查计算得到的指定位置的 Segment 是否为 null。</p></li><li><p>使用创建的 HashEntry 数组初始化这个 Segment.</p></li><li><p>自旋判断计算得到的指定位置的 Segment 是否为 null，使用 CAS 在这个位置赋值为 Segment。</p></li></ol><p> 3.Segment.put 插入 key,value 值。</p><p> Segment 的 put 方法：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, <span class="hljs-type">int</span> hash, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br><span class="hljs-comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span><br>HashEntry&lt;K,V&gt; node = tryLock() ? <span class="hljs-literal">null</span> : scanAndLockForPut(key, hash, value);<br>V oldValue;<br><span class="hljs-keyword">try</span> &#123;<br>    HashEntry&lt;K,V&gt;[] tab = table;<br>    <span class="hljs-comment">// 计算要put的数据位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (tab.length - <span class="hljs-number">1</span>) &amp; hash;<br>    <span class="hljs-comment">// CAS 获取 index 坐标的值</span><br>    HashEntry&lt;K,V&gt; first = entryAt(tab, index);<br>    <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span><br>            K k;<br>            <span class="hljs-keyword">if</span> ((k = e.key) == key ||<br>                (e.hash == hash &amp;&amp; key.equals(k))) &#123;<br>                oldValue = e.value;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent) &#123;<br>                    e.value = value;<br>                    ++modCount;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            e = e.next;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span><br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)<br>                node.setNext(first);<br>            <span class="hljs-keyword">else</span><br>                node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> count + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span><br>            <span class="hljs-keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)<br>                rehash(node);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span><br>                setEntryAt(tab, index, node);<br>            ++modCount;<br>            count = c;<br>            oldValue = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    unlock();<br>&#125;<br><span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure><br> 由于 <code>Segment</code> 继承了 <code>ReentrantLock</code>，所以 <code>Segment</code> 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><ol><li><p><code>tryLock()</code> 获取锁，获取不到使用 <code>scanAndLockForPut</code> 方法继续获取。</p></li><li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 <code>HashEntry</code> 。</p></li><li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待。<br> 如果这个位置上的 <code>HashEntry</code> 不存在：</p><ol><li>如果当前容量大于扩容阀值，小于最大容量，进行扩容。</li><li>直接头插法插入。</li></ol><p> 如果这个位置上的 <code>HashEntry</code> 存在：</p><ol><li>判断链表当前元素 key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值。</li><li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。 <ol><li>如果当前容量大于扩容阀值，小于最大容量，进行扩容。</li><li>直接链表头插法插入。</li></ol></li></ol></li><li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null。</p></li></ol><p> <code>scanAndLockForPut</code> 这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。在自旋时顺表获取下 hash 位置的 <code>HashEntry</code>。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HashEntry&lt;K,V&gt; <span class="hljs-title function_">scanAndLockForPut</span><span class="hljs-params">(K key, <span class="hljs-type">int</span> hash, V value)</span> &#123;<br>HashEntry&lt;K,V&gt; first = entryForHash(<span class="hljs-built_in">this</span>, hash);<br>HashEntry&lt;K,V&gt; e = first;<br>HashEntry&lt;K,V&gt; node = <span class="hljs-literal">null</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">retries</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// negative while locating node</span><br><span class="hljs-comment">// 自旋获取锁</span><br><span class="hljs-keyword">while</span> (!tryLock()) &#123;<br>    HashEntry&lt;K,V&gt; f; <span class="hljs-comment">// to recheck first below</span><br>    <span class="hljs-keyword">if</span> (retries &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-comment">// speculatively create node</span><br>                node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>);<br>            retries = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.equals(e.key))<br>            retries = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span><br>            e = e.next;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;<br>        <span class="hljs-comment">// 自旋达到指定次数后，阻塞等到只到获取到锁</span><br>        lock();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((retries &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp;<br>             (f = entryForHash(<span class="hljs-built_in">this</span>, hash)) != first) &#123;<br>        e = first = f; <span class="hljs-comment">// re-traverse if entry changed</span><br>        retries = -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><p> 扩容 rehash<br> <code>ConcurrentHashMap</code> 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 <code>index + oldSize</code>，参数里的 node 会在扩容之后使用链表头插法插入到指定位置。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">(HashEntry&lt;K,V&gt; node)</span> &#123;<br>HashEntry&lt;K,V&gt;[] oldTable = table;<br><span class="hljs-comment">// 老容量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;<br><span class="hljs-comment">// 新容量，扩大两倍</span><br><span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity &lt;&lt; <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 新的扩容阀值</span><br>threshold = (<span class="hljs-type">int</span>)(newCapacity * loadFactor);<br><span class="hljs-comment">// 创建新的数组</span><br>HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[newCapacity];<br><span class="hljs-comment">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span><br><span class="hljs-type">int</span> <span class="hljs-variable">sizeMask</span> <span class="hljs-operator">=</span> newCapacity - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; oldCapacity ; i++) &#123;<br>    <span class="hljs-comment">// 遍历老数组</span><br>    HashEntry&lt;K,V&gt; e = oldTable[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        HashEntry&lt;K,V&gt; next = e.next;<br>        <span class="hljs-comment">// 计算新的位置，新的位置只可能是不变或者是老的位置+老的容量。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> e.hash &amp; sizeMask;<br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)   <span class="hljs-comment">//  Single node on list</span><br>            <span class="hljs-comment">// 如果当前位置还不是链表，只是一个元素，直接赋值</span><br>            newTable[idx] = e;<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Reuse consecutive sequence at same slot</span><br>            <span class="hljs-comment">// 如果是链表了</span><br>            HashEntry&lt;K,V&gt; lastRun = e;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lastIdx</span> <span class="hljs-operator">=</span> idx;<br>            <span class="hljs-comment">// 新的位置只可能是不变或者是老的位置+老的容量。</span><br>            <span class="hljs-comment">// 遍历结束后，lastRun 后面的元素位置都是相同的</span><br>            <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="hljs-literal">null</span>; last = last.next) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> last.hash &amp; sizeMask;<br>                <span class="hljs-keyword">if</span> (k != lastIdx) &#123;<br>                    lastIdx = k;<br>                    lastRun = last;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span><br>            newTable[lastIdx] = lastRun;<br>            <span class="hljs-comment">// Clone remaining nodes</span><br>            <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;<br>                <span class="hljs-comment">// 遍历剩余元素，头插法到指定 k 位置。</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> p.value;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> p.hash;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> h &amp; sizeMask;<br>                HashEntry&lt;K,V&gt; n = newTable[k];<br>                newTable[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(h, p.key, v, n);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 头插法插入新的节点</span><br><span class="hljs-type">int</span> <span class="hljs-variable">nodeIndex</span> <span class="hljs-operator">=</span> node.hash &amp; sizeMask; <span class="hljs-comment">// add the new node</span><br>node.setNext(newTable[nodeIndex]);<br>newTable[nodeIndex] = node;<br>table = newTable;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>ConcurrentHashMap 1.8</p></li></ol><p>Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 &#x2F; 红黑树。当冲突链表达到一定长度时，链表会转换成红黑树。</p><p>初始化 initTable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Initializes table, using the size recorded in sizeCtl.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span><br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 让出 CPU 使用权</span><br>            Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcurrentHashMap</code> 的初始化是通过自旋和 CAS 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> （sizeControl 的缩写），它的值决定着当前的初始化状态。</p><ul><li>-1 说明正在初始化，其他线程需要自旋等待</li><li>-N 说明 table 正在进行扩容，高 16 位表示扩容的标识戳，低 16 位减 1 为正在进行扩容的线程数</li><li>0 表示 table 初始化大小，如果 table 没有初始化</li><li>大于0表示 table 扩容的阈值，如果 table 已经初始化。</li></ul><p>put</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/** Implementation for put and putIfAbsent */</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-comment">// key 和 value 不能为空</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        <span class="hljs-comment">// f = 目标位置元素</span><br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<span class="hljs-comment">// fh 后面存放目标位置的元素 hash 值</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 数组桶为空，初始化数组桶（自旋+CAS)</span><br>            tab = initTable();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 使用 synchronized 加锁加入节点</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-comment">// 说明是链表</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-comment">// 循环加入新的或者覆盖节点</span><br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                                          value, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        <span class="hljs-comment">// 红黑树</span><br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                       value)) != <span class="hljs-literal">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 hashcode &#x3D;&#x3D; MOVED &#x3D;&#x3D; -1,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据。</li><li>如果数量大于 TREEIFY_THRESHOLD 则要执行树化方法，在 treeifyBin 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码</title>
    <link href="/2025/01/28/HashMap%E6%BA%90%E7%A0%81/"/>
    <url>/2025/01/28/HashMap%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h1><h2 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h2><p>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。</p><p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），<br>如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p>扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p><p>JDK 1.8 HashMap 的 hash 方法源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>“拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><h2 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h2><p>当链表长度大于阈值（默认为 8）时，会首先调用 ·方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。</p><p>类的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;<br>    <span class="hljs-comment">// 序列号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">362498820763181265L</span>;<br>    <span class="hljs-comment">// 默认的初始容量是16</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 最大容量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br>    <span class="hljs-comment">// 默认的负载因子</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br>    <span class="hljs-comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>    <span class="hljs-comment">// 桶中结构转化为红黑树对应的table的最小容量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br>    <span class="hljs-comment">// 存储元素的数组，总是2的幂次倍</span><br>    <span class="hljs-keyword">transient</span> Node&lt;k,v&gt;[] table;<br>    <span class="hljs-comment">// 一个包含了映射中所有键值对的集合视图</span><br>    <span class="hljs-keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;<br>    <span class="hljs-comment">// 存放元素的个数，注意这个不等于数组的长度。</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-comment">// 每次扩容和更改map结构的计数器</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;<br>    <span class="hljs-comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span><br>    <span class="hljs-type">int</span> threshold;<br>    <span class="hljs-comment">// 负载因子</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>loadFactor 负载因子</li></ul><p>loadFactor 负载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。</p><ul><li>threshold</li></ul><p>threshold &#x3D; capacity * loadFactor，当 Size&gt;threshold的时候，那么就要考虑对数组的扩增了，这个的意思就是衡量数组是否需要扩增的一个标准。</p><h1 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h1><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。</p><p>putVal 方法添加元素的过程如下：</p><ol><li><p>如果定位到的数组位置没有元素 就直接插入。</p></li><li><p>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</p></li></ol><p>JDK1.7 put方法：</p><ol><li><p>如果定位到的数组位置没有元素 就直接插入。</p></li><li><p>如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</p></li></ol><h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><p>resize 方法实际上是将 table 初始化和 table 扩容 进行了整合，底层的行为都是给 table 赋值一个新的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 没超过最大值，就扩充为原来的2倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        <span class="hljs-comment">// 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// signifies using defaults 无参构造函数创建的对象在这里计算容量和阈值</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化，</span><br>    <span class="hljs-comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span><br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ? (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 把每个bucket都移动到新的buckets中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 只有一个节点，直接计算元素新的位置即可</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    <span class="hljs-comment">// 将红黑树拆分成2棵子树，如果子树节点数小于等于 UNTREEIFY_THRESHOLD（默认为 6），则将子树转换为链表。</span><br>                    <span class="hljs-comment">// 如果子树节点数大于 UNTREEIFY_THRESHOLD，则保持子树的树结构。</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 原索引</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// 原索引+oldCap</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 原索引放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-comment">// 原索引+oldCap放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地部署deepseek r1</title>
    <link href="/2025/01/27/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2deepseek%20r1/"/>
    <url>/2025/01/27/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2deepseek%20r1/</url>
    
    <content type="html"><![CDATA[<p>使用Ollama进行本地部署。</p><p>Ollama是一个轻量级的工具，可以帮助你在本地快速部署和运行大语言模型。</p><p>访问<a href="https://www.ollama.com/" title="Ollama官网">Ollama官网</a>下载对应的版本。</p><p>注：Ollama安装时默认安装至C盘，修改安装路径可执行以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">.\OllamaSetup.exe /<span class="hljs-built_in">DIR</span>=<span class="hljs-string">&quot;指定路径&quot;</span><br></code></pre></td></tr></table></figure><p>更改模型存储位置：</p><p>要更改 Ollama 存储下载模型的位置，而不是使用你的主目录，可以在你的用户账户中设置环境变量 OLLAMA_MODELS。</p><p>安装完成后，执行以下命令安装对应的模型：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ollama run deepseek<span class="hljs-literal">-r1</span>:<span class="hljs-number">8</span>b<br></code></pre></td></tr></table></figure><p>图形化：<br>使用Github下开源工具<a href="https://github.com/Bin-Huang/chatbox" title="ChatBox">ChatBox</a>，安装完成后选择对应的模型即可。<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250129160245748.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList源码</title>
    <link href="/2025/01/27/ArrayList%E6%BA%90%E7%A0%81/"/>
    <url>/2025/01/27/ArrayList%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="ArrayList核心源码"><a href="#ArrayList核心源码" class="headerlink" title="ArrayList核心源码"></a>ArrayList核心源码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br></pre></td><td class="code"><pre><code class="hljs Java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">8683452581122892189L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认初始容量大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 空数组（用于空实例）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><br>    <span class="hljs-comment">//用于默认大小空实例的共享空数组实例。</span><br>    <span class="hljs-comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存ArrayList数据的数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ArrayList 所包含的元素个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span><br>            <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果传入的参数等于0，创建空数组</span><br>            <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//其他情况，抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span> +<br>                    initialCapacity);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认无参构造函数</span><br><span class="hljs-comment">     * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>        <span class="hljs-comment">//将指定集合转换为数组</span><br>        elementData = c.toArray();<br>        <span class="hljs-comment">//如果elementData数组的长度不为0</span><br>        <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span><br>            <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>                <span class="hljs-comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span><br>                elementData = Arrays.copyOf(elementData, size, Object[].class);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 其他情况，用空数组代替</span><br>            <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trimToSize</span><span class="hljs-params">()</span> &#123;<br>        modCount++;<br>        <span class="hljs-keyword">if</span> (size &lt; elementData.length) &#123;<br>            elementData = (size == <span class="hljs-number">0</span>)<br>                    ? EMPTY_ELEMENTDATA<br>                    : Arrays.copyOf(elementData, size);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//下面是ArrayList的扩容机制</span><br><span class="hljs-comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span><br><span class="hljs-comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> minCapacity 所需的最小容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// 如果不是默认空数组，则minExpand的值为0；</span><br>        <span class="hljs-comment">// 如果是默认空数组，则minExpand的值为10</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">minExpand</span> <span class="hljs-operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)<br>                <span class="hljs-comment">// 如果不是默认元素表，则可以使用任意大小</span><br>                ? <span class="hljs-number">0</span><br>                <span class="hljs-comment">// 如果是默认空数组，它应该已经是默认大小</span><br>                : DEFAULT_CAPACITY;<br><br>        <span class="hljs-comment">// 如果最小容量大于已有的最大容量</span><br>        <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;<br>            <span class="hljs-comment">// 根据需要的最小容量，确保容量足够</span><br>            ensureExplicitCapacity(minCapacity);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 根据给定的最小容量和当前数组元素来计算所需容量。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span><br>        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>            <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>        &#125;<br>        <span class="hljs-comment">// 否则直接返回最小容量</span><br>        <span class="hljs-keyword">return</span> minCapacity;<br>    &#125;<br><br>    <span class="hljs-comment">// 确保内部容量达到指定的最小容量。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>    &#125;<br><br>    <span class="hljs-comment">//判断是否需要扩容</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        modCount++;<br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>            grow(minCapacity);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 要分配的最大数组大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ArrayList扩容的核心方法。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>        <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>        <span class="hljs-comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br>        <span class="hljs-comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span><br>        <span class="hljs-comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span><br>        <span class="hljs-comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span><br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = hugeCapacity(minCapacity);<br>        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br><br>    <span class="hljs-comment">//比较minCapacity和 MAX_ARRAY_SIZE</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>                Integer.MAX_VALUE :<br>                MAX_ARRAY_SIZE;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中的元素数。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果此列表不包含元素，则返回 true 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//注意=和==的区别</span><br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果此列表包含指定的元素，则返回true 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span><br>        <span class="hljs-keyword">return</span> indexOf(o) &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>                <span class="hljs-keyword">if</span> (elementData[i] == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>                <span class="hljs-comment">//equals()方法比较</span><br>                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>                <span class="hljs-keyword">if</span> (elementData[i] == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="hljs-built_in">super</span>.clone();<br>            <span class="hljs-comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span><br>            v.elementData = Arrays.copyOf(elementData, size);<br>            v.modCount = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> v;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-comment">// 这不应该发生，因为我们是可以克隆的</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span><br><span class="hljs-comment">     * 返回的数组将是“安全的”，因为该列表不保留对它的引用。</span><br><span class="hljs-comment">     * （换句话说，这个方法必须分配一个新的数组）。</span><br><span class="hljs-comment">     * 因此，调用者可以自由地修改返回的数组结构。</span><br><span class="hljs-comment">     * 注意：如果元素是引用类型，修改元素的内容会影响到原列表中的对象。</span><br><span class="hljs-comment">     * 此方法充当基于数组和基于集合的API之间的桥梁。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object[] toArray() &#123;<br>        <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span><br><span class="hljs-comment">     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span><br><span class="hljs-comment">     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span><br><span class="hljs-comment">     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span><br><span class="hljs-comment">     * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<br>        <span class="hljs-keyword">if</span> (a.length &lt; size)<br>            <span class="hljs-comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span><br>            <span class="hljs-keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());<br>        <span class="hljs-comment">//调用System提供的arraycopy()方法实现数组之间的复制</span><br>        System.arraycopy(elementData, <span class="hljs-number">0</span>, a, <span class="hljs-number">0</span>, size);<br>        <span class="hljs-keyword">if</span> (a.length &gt; size)<br>            a[size] = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-comment">// Positional Access Operations</span><br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    E <span class="hljs-title function_">elementData</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> (E) elementData[index];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定位置的元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        rangeCheck(index);<br><br>        <span class="hljs-keyword">return</span> elementData(index);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用指定的元素替换此列表中指定位置的元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>        <span class="hljs-comment">//对index进行界限检查</span><br>        rangeCheck(index);<br><br>        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>        elementData[index] = element;<br>        <span class="hljs-comment">//返回原来在这个位置的元素</span><br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在此列表中的指定位置插入指定的元素。</span><br><span class="hljs-comment">     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span><br><span class="hljs-comment">     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>        rangeCheckForAdd(index);<br><br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span><br>        System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,<br>                size - index);<br>        elementData[index] = element;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        rangeCheck(index);<br><br>        modCount++;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index + <span class="hljs-number">1</span>, elementData, index,<br>                    numMoved);<br>        elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>        <span class="hljs-comment">//从列表中删除的元素</span><br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span><br><span class="hljs-comment">     * 返回true，如果此列表包含指定的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>                <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>                <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 该方法为私有的移除方法，跳过了边界检查，并且不返回被移除的值。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        modCount++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index + <span class="hljs-number">1</span>, elementData, index,<br>                    numMoved);<br>        elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 在移除元素后，将该位置的元素设为 null，以便垃圾回收器（GC）能够回收该元素。</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中删除所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        modCount++;<br><br>        <span class="hljs-comment">// 把数组中所有的元素的值设为null</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>            elementData[i] = <span class="hljs-literal">null</span>;<br><br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>        Object[] a = c.toArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;<br>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, size, numNew);<br>        size += numNew;<br>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;<br>        rangeCheckForAdd(index);<br><br>        Object[] a = c.toArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;<br>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index, elementData, index + numNew,<br>                    numMoved);<br><br>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, index, numNew);<br>        size += numNew;<br>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span><br><span class="hljs-comment">     * 将任何后续元素移动到左侧（减少其索引）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeRange</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span> &#123;<br>        modCount++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - toIndex;<br>        System.arraycopy(elementData, toIndex, elementData, fromIndex,<br>                numMoved);<br><br>        <span class="hljs-comment">// clear to let GC do its work</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newSize</span> <span class="hljs-operator">=</span> size - (toIndex - fromIndex);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> newSize; i &lt; size; i++) &#123;<br>            elementData[i] = <span class="hljs-literal">null</span>;<br>        &#125;<br>        size = newSize;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查给定的索引是否在范围内。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheck</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * add和addAll使用的rangeCheck的一个版本</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回IndexOutOfBoundsException细节信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">outOfBoundsMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Index: &quot;</span> + index + <span class="hljs-string">&quot;, Size: &quot;</span> + size;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从此列表中删除指定集合中包含的所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        Objects.requireNonNull(c);<br>        <span class="hljs-comment">//如果此列表被修改则返回true</span><br>        <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 仅保留此列表中包含在指定集合中的元素。</span><br><span class="hljs-comment">     * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        Objects.requireNonNull(c);<br>        <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-literal">true</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span><br><span class="hljs-comment">     * 指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span><br><span class="hljs-comment">     * 返回的列表迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;Index: &quot;</span> + index);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListItr</span>(index);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回列表中的列表迭代器（按适当的顺序）。</span><br><span class="hljs-comment">     * 返回的列表迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListItr</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以正确的顺序返回该列表中的元素的迭代器。</span><br><span class="hljs-comment">     * 返回的迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itr</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="ArrayList 扩容机制"></a>ArrayList 扩容机制</h1><h2 id="ArrayList-的构造函数"><a href="#ArrayList-的构造函数" class="headerlink" title="ArrayList 的构造函数"></a>ArrayList 的构造函数</h2><p>ArrayList 有三种方式来初始化，构造方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认初始容量大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 带初始容量参数的构造函数。（用户自己指定容量）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//初始容量大于0</span><br>        <span class="hljs-comment">//创建initialCapacity大小的数组</span><br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//初始容量等于0</span><br>        <span class="hljs-comment">//创建空数组</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//初始容量小于0，抛出异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span> + initialCapacity);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span><br><span class="hljs-comment"> *如果指定的集合为null，throws NullPointerException。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    elementData = c.toArray();<br>    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>            elementData = Arrays.copyOf(elementData, size, Object[].class);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</p><p>以无参构造函数创建的 ArrayList 为例分析。</p><p>add() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 加元素之前，先调用ensureCapacityInternal方法</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">// 这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ensureCapacityInternal</code> 方法的源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据给定的最小容量和当前数组元素来计算所需容量。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span><br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-comment">// 否则直接返回最小容量</span><br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br><br><span class="hljs-comment">// 确保内部容量达到指定的最小容量。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ensureCapacityInternal</code> 方法非常简单，内部直接调用了 <code>ensureExplicitCapacity</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断是否需要扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">//判断当前数组容量是否足以存储minCapacity个元素</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//调用grow方法进行扩容</span><br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>添加第 11 个元素，<code>minCapacity</code>(为 11)比 <code>elementData.length</code>（为 10）要大。进入 <code>grow</code> 方法进行扩容。</p><p>grow 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 要分配的最大数组大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ArrayList扩容的核心方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-comment">// 将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>    <span class="hljs-comment">// 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br><br>    <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span><br>    <span class="hljs-comment">// 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br><br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>,所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右。</p><p>hugeCapacity()方法</p><p>从上面 <code>grow()</code> 方法源码我们知道：如果新容量大于 <code>MAX_ARRAY_SIZE</code>,进入(执行) <code>hugeCapacity()</code> 方法来比较 <code>minCapacity</code> 和 <code>MAX_ARRAY_SIZE</code>，如果 <code>minCapacity</code> 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 <code>MAX_ARRAY_SIZE</code> 即为 <code>Integer.MAX_VALUE - 8</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>    <span class="hljs-comment">// 对minCapacity和MAX_ARRAY_SIZE进行比较</span><br>    <span class="hljs-comment">// 若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span><br>    <span class="hljs-comment">// 若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span><br>    <span class="hljs-comment">// MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>        Integer.MAX_VALUE :<br>        MAX_ARRAY_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>System.arraycopy() 和 Arrays.copyOf()方法</p><p>System.arraycopy() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*   复制数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> src 源数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> srcPos 源数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> dest 目标数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> destPos 目标数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> length 要复制的数组元素的数量</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-type">int</span>  srcPos,</span><br><span class="hljs-params">                                    Object dest, <span class="hljs-type">int</span> destPos,</span><br><span class="hljs-params">                                    <span class="hljs-type">int</span> length)</span>;<br></code></pre></td></tr></table></figure><p>Arrays.copyOf()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] copyOf(<span class="hljs-type">int</span>[] original, <span class="hljs-type">int</span> newLength) &#123;<br>    <span class="hljs-comment">// 申请一个新的数组</span><br>      <span class="hljs-type">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[newLength];<br><span class="hljs-comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span><br>      System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,<br>                       Math.min(original.length, newLength));<br>      <span class="hljs-keyword">return</span> copy;<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的代理模式</title>
    <link href="/2025/01/27/Java%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/01/27/Java%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计网相关</title>
    <link href="/2025/01/27/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/01/27/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法</title>
    <link href="/2025/01/26/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/26/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2025/01/25/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2025/01/25/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>单调队列结构</title>
    <link href="/2025/01/23/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84/"/>
    <url>/2025/01/23/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>为啥要发明「单调队列」这种结构呢，主要是为了解决下面这个场景：</p><p>给你一个数组 window，已知其最值为 A，如果给 window 中添加一个数 B，那么比较一下 A 和 B 就可以立即算出新的最值；但如果要从 window 数组中减少一个数，就不能直接得到最值了，因为如果减少的这个数恰好是 A，就需要遍历 window 中的所有元素重新寻找新的最值。</p><p>LeetCode 139.滑动窗口最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 单调队列的实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MonotonicQueue</span> &#123;<br>    LinkedList&lt;Integer&gt; maxq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 将小于 n 的元素全部删除</span><br>        <span class="hljs-keyword">while</span> (!maxq.isEmpty() &amp;&amp; maxq.getLast() &lt; n) &#123;<br>            maxq.pollLast();<br>        &#125;<br>        <span class="hljs-comment">// 然后将 n 加入尾部</span><br>        maxq.addLast(n);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> maxq.getFirst();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == maxq.getFirst()) &#123;<br>            maxq.pollFirst();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">MonotonicQueue</span> <span class="hljs-variable">window</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MonotonicQueue</span>();<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; k - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 先填满窗口的前 k - 1</span><br>                window.push(nums[i]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 窗口向前滑动，加入新数字</span><br>                window.push(nums[i]);<br>                <span class="hljs-comment">// 记录当前窗口的最大值</span><br>                res.add(window.max());<br>                <span class="hljs-comment">// 移出旧数字</span><br>                window.pop(nums[i - k + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 需要转成 int[] 数组再返回</span><br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; res.size(); i++) &#123;<br>            arr[i] = res.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2025/01/23/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2025/01/23/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a>单调栈模板</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] calculateGreaterElement(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-comment">// 存放答案的数组</span><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <br>    <span class="hljs-comment">// 倒着往栈里放</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 判定个子高矮</span><br>        <span class="hljs-keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &lt;= nums[i]) &#123;<br>            <span class="hljs-comment">// 矮个起开，反正也被挡着了。。。</span><br>            s.pop();<br>        &#125;<br>        <span class="hljs-comment">// nums[i] 身后的更大元素</span><br>        res[i] = s.isEmpty() ? -<span class="hljs-number">1</span> : s.peek();<br>        s.push(nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是单调队列解决问题的模板。for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个「个子高」元素之间的元素排除，因为他们的存在没有意义，前面挡着个「更高」的元素，所以他们不可能被作为后续进来的元素的下一个更大元素了。</p><p>分析它的时间复杂度，要从整体来看：总共有 n 个元素，每个元素都被 push 入栈了一次，而最多会被 pop 一次，没有任何冗余操作。所以总的计算规模是和元素规模 n 成正比的，也就是 O(n) 的复杂度。</p><h2 id="LeetCode-496-下一个更大的元素Ⅰ"><a href="#LeetCode-496-下一个更大的元素Ⅰ" class="headerlink" title="LeetCode 496.下一个更大的元素Ⅰ"></a>LeetCode 496.下一个更大的元素Ⅰ</h2><p>题目说 nums1 是 nums2 的子集，那么我们先把 nums2 中每个元素的下一个更大元素算出来存到一个映射里，然后再让 nums1 中的元素去查表即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] nextGreaterElement(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        <span class="hljs-comment">// 记录 nums2 中每个元素的下一个更大元素</span><br>        <span class="hljs-type">int</span>[] greater = calculateGreaterElement(nums2);<br>        <span class="hljs-comment">// 转化成映射：元素 x -&gt; x 的下一个最大元素</span><br>        HashMap&lt;Integer, Integer&gt; greaterMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums2.length; i++) &#123;<br>            greaterMap.put(nums2[i], greater[i]);<br>        &#125;<br>        <span class="hljs-comment">// nums1 是 nums2 的子集，所以根据 greaterMap 可以得到结果</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums1.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; i++) &#123;<br>            res[i] = greaterMap.get(nums1[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] calculateGreaterElement(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-comment">// 见上文</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-739-每日温度"><a href="#LeetCode-739-每日温度" class="headerlink" title="LeetCode 739.每日温度"></a>LeetCode 739.每日温度</h2><p>这个问题本质上也是找下一个更大元素，只不过现在不是问你下一个更大元素的值是多少，而是问你当前元素距离下一个更大元素的索引距离而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> temperatures.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 这里放元素索引，而不是元素</span><br>        Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <br>        <span class="hljs-comment">// 单调栈模板</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">while</span> (!s.isEmpty() &amp;&amp; temperatures[s.peek()] &lt;= temperatures[i]) &#123;<br>                s.pop();<br>            &#125;<br>            <span class="hljs-comment">// 得到索引间距</span><br>            res[i] = s.isEmpty() ? <span class="hljs-number">0</span> : (s.peek() - i); <br>            <span class="hljs-comment">// 将索引入栈，而不是元素</span><br>            s.push(i); <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-503-下一个更大的元素Ⅱ"><a href="#LeetCode-503-下一个更大的元素Ⅱ" class="headerlink" title="LeetCode 503.下一个更大的元素Ⅱ"></a>LeetCode 503.下一个更大的元素Ⅱ</h2><p>这个问题肯定还是要用单调栈的解题模板，但难点在于，比如输入是 [2,1,2,4,3]，对于最后一个元素 3，如何找到元素 4 作为下一个更大元素。</p><p>对于这种需求，常用套路就是将数组长度翻倍：</p><p>这样，元素 3 就可以找到元素 4 作为下一个更大元素了，而且其他的元素都可以被正确地计算。</p><p>有了思路，最简单的实现方式当然可以把这个双倍长度的数组构造出来，然后套用算法模板。但是，我们可以不用构造新数组，而是利用循环数组的技巧来模拟数组长度翻倍的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] nextGreaterElements(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">// 数组长度加倍模拟环形数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">// 索引 i 要求模，其他的和模板一样</span><br>            <span class="hljs-keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &lt;= nums[i % n]) &#123;<br>                s.pop();<br>            &#125;<br>            res[i % n] = s.isEmpty() ? -<span class="hljs-number">1</span> : s.peek();<br>            s.push(nums[i % n]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-1019-链表中的下一个更大节点"><a href="#LeetCode-1019-链表中的下一个更大节点" class="headerlink" title="LeetCode 1019.链表中的下一个更大节点"></a>LeetCode 1019.链表中的下一个更大节点</h2><p>这道题输入的是一条单链表，我们把它转化成数组，方便用索引访问即可直接套用<br>单调栈模板 中的 nextGreaterElement 函数逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] nextLargerNodes(ListNode head) &#123;<br>        <span class="hljs-comment">// 把单链表转化成数组，方便通过索引访问</span><br>        ArrayList&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>            nums.add(p.val);<br>        &#125;<br>        <span class="hljs-comment">// 存放答案的数组</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.size()];<br>        Stack&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">// 单调栈模板，求下一个更大元素，从后往前遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; stk.peek() &lt;= nums.get(i)) &#123;<br>                stk.pop();<br>            &#125;<br>            <span class="hljs-comment">// 本题要求没有下一个更大元素时返回 0</span><br>            res[i] = stk.isEmpty() ? <span class="hljs-number">0</span> : stk.peek();<br>            stk.push(nums.get(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-1944-队列中可以看到的人数"><a href="#LeetCode-1944-队列中可以看到的人数" class="headerlink" title="LeetCode 1944.队列中可以看到的人数"></a>LeetCode 1944.队列中可以看到的人数</h2><p>这道题显然要用到<br>单调栈技巧：靠左的高个子可以把靠右相邻的矮个子都「挤掉」，相当于计算下一个更大元素，即<br>单调栈的几种模板实现 中的 nextGreaterElement 函数。</p><p>只不过这道题不是问你下一个更大元素是多少，而是问你当前元素和下一个更大元素之间的元素个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] canSeePersonsCount(<span class="hljs-type">int</span>[] heights) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// int[] 记录 &#123;身高，小于等于该身高的人数&#125; 二元组</span><br>        Stack&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">// 记录右侧比自己矮的人</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 单调栈模板，计算下一个更大或相等元素（身高）</span><br>            <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; heights[i] &gt; stk.peek()) &#123;<br>                stk.pop();<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// 不仅可以看到比自己矮的人，如果后面存在更高的的人，也可以看到这个高人</span><br>            res[i] = stk.isEmpty() ? count : count + <span class="hljs-number">1</span>;<br>            stk.push(heights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-1475-商品折扣后的最终价格"><a href="#LeetCode-1475-商品折扣后的最终价格" class="headerlink" title="LeetCode 1475.商品折扣后的最终价格"></a>LeetCode 1475.商品折扣后的最终价格</h2><p>这道题就用到了<br>单调栈的几种模板实现 中讲到的一个单调栈模板：计算下一个更小或相等的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] finalPrices(<span class="hljs-type">int</span>[] prices) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 下一个小于等于 price[i] 的价格就是优惠券折扣</span><br>        <span class="hljs-type">int</span>[] nextElement = nextLessOrEqualElement(prices);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>            <span class="hljs-comment">// 如果存在优惠券，则减少相应的价格</span><br>            <span class="hljs-keyword">if</span> (nextElement[i] != -<span class="hljs-number">1</span>) &#123;<br>                res[i] = prices[i] - nextElement[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res[i] = prices[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 单调栈模板：计算 nums 中每个元素的下一个更小或相等的元素</span><br>    <span class="hljs-type">int</span>[] nextLessOrEqualElement(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 存放答案的数组</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">// 倒着往栈里放</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">// 删掉 nums[i] 后面较大的元素</span><br>            <span class="hljs-keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &gt; nums[i]) &#123;<br>                s.pop();<br>            &#125;<br>            <span class="hljs-comment">// 现在栈顶就是 nums[i] 身后的更小或相等元素</span><br>            res[i] = s.isEmpty() ? -<span class="hljs-number">1</span> : s.peek();<br>            s.push(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown基本语法</title>
    <link href="/2025/01/23/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2025/01/23/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Guava令牌桶</title>
    <link href="/2025/01/23/Guava%E4%BB%A4%E7%89%8C%E6%A1%B6/"/>
    <url>/2025/01/23/Guava%E4%BB%A4%E7%89%8C%E6%A1%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Guava-令牌桶"><a href="#Guava-令牌桶" class="headerlink" title="Guava 令牌桶"></a>Guava 令牌桶</h1><p>Guava 是 Google 提供的一个开源 Java 库，RateLimiter 是 Guava 中实现令牌桶限流机制的核心工具。Guava 的令牌桶实现基于 RateLimiter 类，它通过令牌的生成来控制并限制请求的速率，确保系统在一定时间窗口内不会被过多请求淹没，从而起到保护系统和保证服务质量的作用。</p><h2 id="Guava-令牌桶的特点"><a href="#Guava-令牌桶的特点" class="headerlink" title="Guava 令牌桶的特点"></a>Guava 令牌桶的特点</h2><ul><li><p>平滑限流：Guava 通过令牌的生成速率来确保流量的平滑度。RateLimiter 默认采用的是“平滑突发限流”（Smooth Bursty），它允许一定的流量突发。</p></li><li><p>平滑预热限流：Guava 还提供了一种“平滑预热限流”（Smooth Warming Up），当系统启动时，令牌生成速度逐渐增加，适用于服务在冷启动或需要预热阶段的场景。</p></li><li><p>灵活配置：可以根据实际需求设置令牌的生成速率，并提供灵活的参数配置。</p></li></ul><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="RateLimiter-使用"><a href="#RateLimiter-使用" class="headerlink" title="RateLimiter 使用"></a>RateLimiter 使用</h2><p>在 onMessage() 消息消费方法中，通过 acquire() 方法可获取令牌，若成功获取了令牌，则正常执行后续代码；如果没有令牌可用，将阻塞，直到获得为止。</p><h2 id="搭配-Nacos-动态配置"><a href="#搭配-Nacos-动态配置" class="headerlink" title="搭配 Nacos 动态配置"></a>搭配 Nacos 动态配置</h2><p>在生产环境中，服务往往是以集群的方式部署，假设 3 个服务实例构建成一个最基础的集群，数据库每秒能够承受 5000 的并发访问，则平摊到每个服务实例，应该配置为每秒生成 1666 个令牌：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123141829627.jpg" alt="Loading"></p><p>但是生产环境中，集群的实例数往往随时会发生变动，如果集群压力过大，顶不住目前的流量，运维可能会加机器，比如将 3 实例的集群扩展为 5 实例的集群，那么代码中写死的每秒令牌生成数就不对了，应该变更为 5000 &#x2F; 5 &#x3D; 1000，即每秒生成 1000 个令牌，以维持数据库每秒最大能够承受的访问量。</p><p>关于每秒生成的令牌数，完全可以添加到 Nacos 配置中心中。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Guava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Caffeine</title>
    <link href="/2025/01/23/Caffeine/"/>
    <url>/2025/01/23/Caffeine/</url>
    
    <content type="html"><![CDATA[<h1 id="Caffeine-介绍"><a href="#Caffeine-介绍" class="headerlink" title="Caffeine 介绍"></a>Caffeine 介绍</h1><p>Caffeine 是一个高性能、轻量级的 Java 缓存库，旨在提供简单易用的 API 和强大的功能集合。它由 Google 的工程师 Ben Manes 开发，并在多个 Google 内部项目中广泛使用。Caffeine 作为 Java 应用程序中的缓存解决方案，旨在提高应用程序的性能和响应速度，通过减少对外部系统的依赖来加快数据访问的速度。</p><p>Caffeine 的特性如下：</p><ul><li><p>高性能：Caffeine 优化了内部结构，使得缓存操作非常快速。它使用了高效的数据结构和算法，如哈希表和跳表，以及并发友好的实现策略。</p></li><li><p>内存效率：Caffeine 采用了一种称为 Window TinyLFU (W-TinyLFU) 的淘汰策略，它综合了 LRU 和 LFU 的优点，能够更智能地管理缓存中的条目。这种策略可以有效地利用有限的内存资源，同时保持较高的缓存命中率。</p></li><li><p>易于使用：Caffeine 提供了一个简洁的 API，允许开发者轻松地集成缓存逻辑到现有的应用程序中。它还支持多种配置选项，可以根据具体需求进行定制。</p></li><li><p>丰富的功能：除了基本的缓存功能外，Caffeine 还提供了许多高级特性，如定时清理、异步加载、统计报告等。</p></li><li><p>高度可配置：用户可以通过多种方式来调整缓存的行为，包括设置最大容量、TTL（Time To Live，存活时间）、TID（Time To Idle，空闲时间）等参数。</p></li></ul><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Caffeine 本地缓存 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="初始化缓存"><a href="#初始化缓存" class="headerlink" title="初始化缓存"></a>初始化缓存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用户信息本地缓存</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Cache&lt;Long, FindUserByIdRspDTO&gt; LOCAL_CACHE = Caffeine.newBuilder()<br>           .initialCapacity(<span class="hljs-number">10000</span>) <span class="hljs-comment">// 设置初始容量为 10000 个条目</span><br>           .maximumSize(<span class="hljs-number">10000</span>) <span class="hljs-comment">// 设置缓存的最大容量为 10000 个条目</span><br>           .expireAfterWrite(<span class="hljs-number">1</span>, TimeUnit.HOURS) <span class="hljs-comment">// 设置缓存条目在写入后 1 小时过期</span><br>           .build();<br></code></pre></td></tr></table></figure><p>代码解释：</p><ul><li><p><code>initialCapacity</code>: 指定缓存的初始容量。这里初始容量设置为 10000。这意味着缓存最初会预留足够的空间来容纳大约 10000 个条目。这有助于减少缓存扩容的次数，提高性能。</p></li><li><p><code>maximumSize</code>: 指定缓存的最大容量。这里最大容量同样设置为 10000。当缓存中的条目数量超过这个限制时，缓存将开始根据淘汰策略来移除旧条目。这里使用的是 W-TinyLFU 淘汰策略。</p></li><li><p><code>expireAfterWrite</code>: 这个配置指定了缓存条目写入后多久过期。在上面代码中，设置为 1 小时。这意味着一旦一个条目被写入缓存，它将在 1 小时后自动过期并被清除。这有助于防止缓存中存放过时的数据。</p></li></ul><p>再通过 Jmeter 压测一波，看看对比上小节，引入了二级缓存后，性能提升了多少：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123103536839.jpg" alt="Loading"></p><p>如上图所示，吞吐量提升了 2000&#x2F;s 左右，接口响应耗时平均减少了 1ms。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Caffeine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式ID生成</title>
    <link href="/2025/01/23/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90/"/>
    <url>/2025/01/23/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是分布式ID？"><a href="#什么是分布式ID？" class="headerlink" title="什么是分布式ID？"></a>什么是分布式ID？</h1><p>分布式 ID 是指在一个分布式系统中，为每一个数据项或事件生成一个全局唯一标识符的过程。 这个标识符通常是一个长整型数字或字符串，能够跨多个服务实例和数据库集群唯一识别每一个实体，是实现数据关联和跟踪的基础。</p><p>在传统的单体应用中，ID 生成相对简单，可以通过数据库的自增字段来实现。但在微服务架构下，每个服务可能运行在不同的服务器上，甚至可能有多个实例，这就意味着每个服务都需要独立生成 ID，并且保证全局唯一性。此外，分布式 ID 还需要解决以下几个关键问题：</p><ul><li><p>一致性：所有生成的 ID 必须在分布式环境中保持一致，避免重复和冲突。</p></li><li><p>高性能：在高并发场景下，ID 生成机制不能成为系统的瓶颈。</p></li><li><p>可扩展性：随着业务的增长，ID 生成策略应该易于扩展，适应更大的负载。</p></li><li><p>容错性：即使部分服务出现故障，ID 生成也不能中断。</p></li></ul><h1 id="分布式-ID-生成方案"><a href="#分布式-ID-生成方案" class="headerlink" title="分布式 ID 生成方案"></a>分布式 ID 生成方案</h1><p>目前，业界已经发展出了多种分布式 ID 生成算法和技术，以下是常见的几种方案：</p><ol><li><p>UUID ： UUID (Universally Unique Identifier) 是一种常用的分布式 ID 生成方式, 它的标准型式包含 32 个 16 进制数字，以连字号分为五段，形式为 8-4-4-4-12 的 36 个字符，示例：550e8400-e29b-41d4-a716-446655440000。</p><p> 优点:</p><ul><li>生成性能非常高：直接本地生成，不依赖其他中间件，无网络 &#x2F; 磁盘 IO 消耗；</li></ul><p> 缺点：</p><ul><li><p>不易于存储：UUID 太长，16 字节 128 位，通常以 36 长度的字符串表示。在海量数据场景下，会消耗较大的存储空间。</p></li><li><p>信息不安全：基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</p></li><li><p>充当主键时，在特定场景下，会存在问题。如作为 MySQL 数据库的主键时，UUID 就非常不合适。</p></li><li><p>基于数据库（DB）的自增 ID ：可以单独创建一张共享的 ID 生成表，使用自增字段来生成 ID，再存到业务表主键字段中。</p></li></ul></li><li><p>基于数据库（DB）的自增 ID ：可以单独创建一张共享的 ID 生成表，使用自增字段来生成 ID，再存到业务表主键字段中。<br> 优点：</p><ul><li><p>实现非常简单，利用现有的数据库即可搞定；</p></li><li><p>ID 单调递增；</p></li></ul><p> 缺点：</p><ul><li><p>强依赖 DB，当 DB 异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。</p></li><li><p>ID 发号性能瓶颈限制在单台 MySQL 的读写性能。</p></li></ul></li><li><p>基于分布式协调服务： 利用 Zookeeper、Etcd 等分布式协调服务，可以实现 ID 的有序分配。虽然这种方法可以保证 ID 的顺序性，但引入了外部依赖，增加了系统的复杂度。</p></li><li><p>基于分布式缓存：使用 Redis 的 INCRBY 命令，可以为键 （Key）的数字增加指定增量。如果键不存在，则数值会被初始化为 0，然后再执行增量操作。</p></li><li><p>基于 Snowflake 算法（雪花算法）： Snowflake 算法由 Twitter 开发，它结合了时间戳、机器 ID 和序列号，生成 64 位的 ID，如下图所示：</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123085339179.png" alt="Loading" title="snowflake"></p><ul><li><p>1bit: 符号位（标识正负），不作使用，始终为 0，代表生成的 ID 为正数。</p></li><li><p>41-bit 时间戳: 一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）</p></li><li><p>datacenter id + worker id (10 bits): 一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（项目中可以根据实际需求来调整）。这样就可以区分不同集群&#x2F;机房的节点。</p></li><li><p>12-bit 序列号: 一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 &#x3D; 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。理论上 snowflake 方案的QPS约为 409.6w &#x2F;s，这种分配方式可以保证在任何一个 IDC 的任何一台机器在任意毫秒内生成的 ID 都是不同的。</p></li></ul><p>snowflake 雪花算法优缺点如下：</p><p>优点：</p><ul><li><p>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</p></li><li><p>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</p></li><li><p>可以根据自身业务特性分配bit位，非常灵活。</p></li></ul><p>缺点：</p><ul><li>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</li></ul><h1 id="Leaf-介绍"><a href="#Leaf-介绍" class="headerlink" title="Leaf 介绍"></a>Leaf 介绍</h1><p>Leaf 这个名字是来自德国哲学家、数学家莱布尼茨的一句话： There are no two identical leaves in the world</p><p>—— “世界上没有两片相同的树叶”</p><p>美团 Leaf 基于数据库生成以及 snowflake 雪花算法方案之上，做了进一步的优化，提供了如下两种方案：</p><ol><li>第一种：Leaf-segment 数据库方案:</li></ol><p>在使用数据库的方案上，做了如下改变：</p><p>原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用proxy server批量获取，每次获取一个segment(step决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。<br>各个业务不同的发号需求用biz_tag字段来区分，每个biz-tag的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对biz_tag分库分表就行。</p><ol start="2"><li>第二种：Leaf-snowflake 雪花算法方案:</li></ol><p>Leaf-snowflake方案完全沿用snowflake方案的bit位设计，即是“1+41+10+12”的方式组装ID号。对于workerID的分配，当服务集群数量较小的情况下，完全可以手动配置。Leaf服务规模较大，动手配置成本太高。所以使用Zookeeper持久顺序节点的特性自动对snowflake节点配置wokerID。Leaf-snowflake是按照下面几个步骤启动的：</p><p>启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。<br>如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。<br>如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。</p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>Leaf 的 GitHub 地址是：<a href="https://github.com/Meituan-Dianping/Leaf">https://github.com/Meituan-Dianping/Leaf</a> ，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123085611256.png" alt="Loading"></p><ul><li>①：leaf-core : 核心模块，包括两种方案的核心代码；</li><li>②：leaf-server : 服务端工程，用于对外提供接口获取分布式 ID，以及监控页面;</li><li>③：scripts : 数据库脚本；</li></ul><p>打开命令行工具，进入到想要存放工程的文件夹下，执行如下命令，拉取 Leaf 源码。</p><p><code>git clone https://github.com/Meituan-Dianping/Leaf.git</code></p><h2 id="准备数据库"><a href="#准备数据库" class="headerlink" title="准备数据库"></a>准备数据库</h2><p>源码拉取完毕后，还有一些前置工作。由于 Leaf-segment 方案依赖于数据库，所以还需提前将数据库、表创建好。新建一个名为 leaf 的数据库。库创建完毕后，执行如下 SQL :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE TABLE</span> `leaf_alloc` (<br>  `biz_tag` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>)  <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  `max_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1&#x27;</span>,<br>  `step` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT NULL</span>,<br>  `description` <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>)  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `update_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`biz_tag`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB;<br><br><span class="hljs-keyword">insert into</span> leaf_alloc(biz_tag, max_id, step, description) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;leaf-segment-test&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;Test leaf Segment Mode Get Id&#x27;</span>)<br></code></pre></td></tr></table></figure><p>表设计</p><ul><li><p>biz_tag : 用来区分业务，例如生成用户 ID、生成笔记 ID通过此标识隔离开来;</p></li><li><p>max_id: 表示该 biz_tag 目前所被分配的 ID 号段的最大值;</p></li><li><p>step: 表示每次分配的号段长度。</p></li></ul><p>基于数据库生成 ID, 最原始的方案是，获取 ID 每次都需要写数据库，现在只需要把 step 设置得足够大，比如 1000。那么只有当 1000 个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从1减小到了 1&#x2F;step 。</p><p>表创建完成后，再插入一条业务标识为 leaf-segment-test 的记录，step 为 2000，表示号段长度为 2000， 即每次生成 2000 个 ID 。</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>数据库准备好后，通过 IDE 打开 Leaf 源码工程，并编辑 leaf-server 模块 &#x2F;resources 资源目录中的 leaf.properties 配置文件</p><p>将 leaf.segment.enable 配置为 true , 表示开启号段模式，并配置数据库连接等信息。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">leaf.name</span>=<span class="hljs-string">com.sankuai.leaf.opensource.test</span><br><span class="hljs-attr">leaf.segment.enable</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">leaf.jdbc.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/leaf?useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="hljs-attr">leaf.jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">leaf.jdbc.password</span>=<span class="hljs-string">123456</span><br><br><span class="hljs-attr">leaf.snowflake.enable</span>=<span class="hljs-string">false</span><br><span class="hljs-comment">#leaf.snowflake.zk.address=</span><br><span class="hljs-comment">#leaf.snowflake.port=</span><br></code></pre></td></tr></table></figure><h2 id="启动-Leaf"><a href="#启动-Leaf" class="headerlink" title="启动 Leaf"></a>启动 Leaf</h2><p>数据库连接配置完毕后，运行 leaf-server 模块下的启动类，看看能否启动成功。不出意外，你会发现控制台报错如下</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123085941651.jpg" alt="Loading" title="启动时报错"></p><p>因为我们目前使用的是 8.0 版本的 MySQL, 需要对 leaf-seaver 模块的 pom.xml 添加最新的驱动</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MySQL 驱动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.29<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加完依赖后，刷新一下 Maven。 然后，编辑 &#x2F;service 包下的 SegmentService 类，在初始化数据源的时候，指定一下驱动路径，以及连接池中连接检查 SQL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">         <span class="hljs-comment">// Config dataSource</span><br>         dataSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>         dataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br><span class="hljs-comment">// 省略...</span><br>         dataSource.setValidationQuery(<span class="hljs-string">&quot;select 1&quot;</span>);<br>         dataSource.init();<br></code></pre></td></tr></table></figure><h3 id="号段模式获取分布式-ID-测试"><a href="#号段模式获取分布式-ID-测试" class="headerlink" title="号段模式获取分布式 ID 测试"></a>号段模式获取分布式 ID 测试</h3><p>测试一下号段模式获取分布式 ID。两种方案的接口地址，可在 LeafController 类中找到<br>号段模式的接口地址为<br><code>http://localhost:8080/api/segment/get/&#123;key&#125;</code></p><p>key 表示业务标识，即表中的 biz_tag 字段。比如我们想要获取 biz_tag 为 leaf-segment-test 的下一个分布式 ID, 访问接口如下<br><code>http://localhost:8080/api/segment/get/leaf-segment-test</code></p><p>浏览器访问，如下图所示，成功拿到了 ID 值, 并且每次刷新，都会一直递增下去</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123090306186.jpg" alt="Loading"></p><h3 id="监控页"><a href="#监控页" class="headerlink" title="监控页"></a>监控页</h3><p>如果想获取一些监控数据，LeafMonitorController 类中定义了对应的接口，路径如下<br><code>http://localhost:8080/cache</code></p><p>浏览器访问，效果图如下：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123090419001.jpg" alt="Loading"></p><h2 id="Docker-安装-Zookeeper"><a href="#Docker-安装-Zookeeper" class="headerlink" title="Docker 安装 Zookeeper"></a>Docker 安装 Zookeeper</h2><p>我们已经测试了美团 Leaf-segment 号段模式（依赖数据库）来获取分布式 ID , 除了该模式外，还有 Leaf-snowflake （基于雪花算法）模式，它依赖于 Zookeeper。</p><h3 id="Zookeeper-介绍"><a href="#Zookeeper-介绍" class="headerlink" title="Zookeeper 介绍"></a>Zookeeper 介绍</h3><p>Apache ZooKeeper 是一个开源的分布式协调服务，用于大型分布式系统的开发和管理。它提供了一种简单而统一的方法来解决分布式应用中常见的协调问题，如命名服务、配置管理、集群管理、组服务、分布式锁、队列管理等。ZooKeeper 通过提供一种类似文件系统的结构来存储数据，并允许客户端通过简单的 API 进行读写操作，从而简化了分布式系统的复杂度。</p><p>Zookeeper 的核心特性如下：</p><ul><li><p>一致性：对于任何更新，所有客户端都将看到相同的数据视图。这是通过 ZooKeeper 的原子性保证的，意味着所有更新要么完全成功，要么完全失败。</p></li><li><p>可靠性：一旦数据被提交，它将被持久化存储，即使在某些服务器出现故障的情况下，数据也不会丢失。</p></li><li><p>实时性：ZooKeeper 支持事件通知机制，允许客户端实时接收到数据变化的通知。</p></li><li><p>高可用性：ZooKeeper 通常以集群形式部署，可以容忍部分节点的故障，只要集群中超过半数的节点是可用的，ZooKeeper 就能继续提供服务。</p></li></ul><p>ZooKeeper 的数据模型：</p><p>ZooKeeper 使用一个层次化的命名空间来组织数据，类似于文件系统中的目录树。每个节点（称为 znode）都可以有子节点，形成树状结构。每个 znode 可以存储一定量的数据，并且可以设置访问控制列表（ACL）来控制谁可以读取或修改数据。</p><p>ZooKeeper 的应用场景：</p><ul><li><p>配置管理：ZooKeeper 可以用来集中存储和管理分布式系统中的配置信息，当配置发生变化时，可以实时通知到所有客户端。</p></li><li><p>命名服务：ZooKeeper 可以作为服务发现的注册中心，帮助客户端查找和定位服务。</p></li><li><p>集群管理：ZooKeeper 可以用于选举主节点、检测集群成员的变化、以及监控集群的健康状况。</p></li><li><p>分布式锁：ZooKeeper 提供了一种机制来实现分布式环境下的互斥访问，保证多个进程之间数据操作的正确性。</p></li><li><p>队列管理：ZooKeeper 可以用来实现分布式队列，如任务调度队列或消息队列。</p></li></ul><ol><li>下载镜像</li></ol><p>打开命令行工具，执行如下命令，拉取 Zookeeper 镜像</p><p><code>docker pull zookeeper:3.5.6</code></p><ol start="2"><li>创建挂载文件夹</li></ol><p>镜像下载完成后，在 E:&#x2F;docker&#x2F; 目录下创建 &#x2F;zookeeper 文件夹，用于存放等会启动容器时，挂载出容器内 Zookeeper 的相关配置文件，以及相关持久化数据</p><ol start="3"><li>运行容器</li></ol><p>执行如下命令，运行一个 Zookeeper 容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --name zookeeper -p <span class="hljs-number">2181</span>:<span class="hljs-number">2181</span> -e TZ=<span class="hljs-string">&quot;Asia/Shanghai&quot;</span> -v E:\docker\zookeeper\data:/data -v E:\docker\zookeeper\conf:/conf zookeeper:<span class="hljs-number">3</span>.<span class="hljs-number">5</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>参数解释</p><ul><li><p>docker run: 这是启动一个新的 Docker 容器的命令。</p></li><li><p>-d: 这个选项表示以守护进程模式（即后台）运行容器。</p></li><li><p>–name zookeeper: 给容器指定一个名字叫做 zookeeper。这可以帮助你更容易地识别和管理这个容器。</p></li><li><p>-p 2181:2181: 这是一个端口映射选项，它将宿主机的 2181 端口映射到容器内的 2181 端口。这意味着在宿主机上，你可以通过访问 localhost:2181 来连接到运行在容器内的 ZooKeeper 服务。</p></li><li><p>-e TZ&#x3D;”Asia&#x2F;Shanghai”: 这个环境变量设置将容器内部的时间区域设为上海时区（亚洲&#x2F;上海）。这样可以确保容器内的时间与你的本地时区一致。</p></li><li><p>-v E:\docker\zookeeper\data:&#x2F;data: 这是一个卷挂载选项，将宿主机上的 E:\docker\zookeeper\data 目录挂载到容器内的 &#x2F;data 目录。通常，ZooKeeper 将数据存储在 &#x2F;data 目录下，因此这个挂载点可以让你在宿主机上持久化 ZooKeeper 的数据。</p></li><li><p>-v E:\docker\zookeeper\conf:&#x2F;conf: 类似于上面的挂载，这里将宿主机上的 E:\docker\zookeeper\conf 目录挂载到容器内的 &#x2F;conf 目录。ZooKeeper 的配置文件一般位于 &#x2F;conf 目录下，这样你可以在宿主机上编辑配置文件，而不会影响到容器重启后的配置。</p></li><li><p>zookeeper:3.5.6: 这是指定使用的 Docker 镜像，这里是 ZooKeeper 版本 3.5.6 的镜像。</p></li></ul><ol start="4"><li>容器运行成功后，可通过 docker ps 命令查看正在运行中的容器，确认一下 Zookeeper 是否启动成功了</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123090748174.png" alt="Loading"></p><ol start="5"><li>进入 Zookeeper</li></ol><p>执行如下命令，进入到 Zookeeper 容器中</p><p><code>docker exec -it zookeeper bash</code></p><p>接着，执行如下命令，来启动 ZooKeeper 的命令行界面（CLI），它允许用户直接与 ZooKeeper 服务器进行交互</p><p><code>./bin/zkCli.sh</code></p><p>连接成功后，效果图如下</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123090915828.png" alt="Loading"></p><ol start="6"><li>zk 基本命令</li></ol><p>ZooKeeper CLI (zkCli) 是 ZooKeeper 分布式协调服务附带的一个命令行工具，它提供了与 ZooKeeper 服务器交互的方式。使用 zkCli，你可以执行诸如查看、创建、修改和删除 ZooKeeper 中的数据节点（znodes）的操作。</p><ul><li>ls：列出当前路径下的子节点。如：查看根节点的子节点，命令如下</li></ul><p><code>ls /</code></p><ul><li>create：创建一个新的节点 （znode）</li></ul><p><code>create /myNode &quot;hello&quot;</code></p><p>以上命令，将创建一个名为 &#x2F;myNode 的节点，并初始化其数据为 “hello”。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123091016808.png" alt="Loading"></p><ul><li>get：获取指定节点的数据和状态信息。命令如下</li></ul><p><code>get /myNode</code></p><ul><li>set：设置指定节点的数据。命令如下</li></ul><p><code>set /myNode &quot;fresh&quot;</code></p><ul><li>delete：删除指定的节点（znode） 。命令如下</li></ul><p><code>delete /myNode</code></p><p>以上命令，将删除 &#x2F;myNode 节点，注意，只有当该节点没有子节点时才有效。</p><ul><li>quit：退出 zkCli 命令行工具。效果如下：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123091241534.png" alt="Loading"></p><p>美团 Leaf-snowflake 雪花算法模式测试</p><p>编辑配置<br>首先，编辑 leaf-server 模块中的 leaf.properties 配置文件，将 snowflake 模式开启，并配置好 Zookeeper 连接地址，如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 是否开启 snowflake 模式</span><br><span class="hljs-attr">leaf.snowflake.enable</span>=<span class="hljs-literal">true</span><br><span class="hljs-comment"># snowflake 模式下的 zk 地址</span><br><span class="hljs-attr">leaf.snowflake.zk.address</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2181</span><br><span class="hljs-comment"># snowflake 模式下的服务注册端口</span><br><span class="hljs-attr">leaf.snowflake.port</span>=<span class="hljs-number">2222</span><br></code></pre></td></tr></table></figure><p>运行 Leaf<br>运行 leaf-server 项目，若控制台中提示 Snowflake Service Init Successfully , 则表示 Leaf-snowflake 模式初始化成功了</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123091358519.jpg" alt="Loading"></p><p>接口测试<br>项目启动成功后，访问如下接口，即可获取雪花算法 ID</p><p><code>/api/snowflake/get/&#123;key&#125;</code></p><p>关于参数 key , 随便填一个就行。阅读源码，查看 SnowflakeIDGenImpl 类，即可得知 key 实际并没有使用到</p><p>浏览器访问此接口，即可获取基于雪花算法生成的 ID 了，如下图所示，每次刷新结果都会不同，而且值是趋势递增的</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123091535799.jpg" alt="Loading"></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>ZooKeeper</tag>
      
      <tag>leaf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合类</title>
    <link href="/2025/01/22/Java%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <url>/2025/01/22/Java%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Java集合类框架："><a href="#Java集合类框架：" class="headerlink" title="Java集合类框架："></a>Java集合类框架：</h1><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250127150915661.png" alt="Loading"></p><h2 id="简述-Set、List、Map、Queue-四者的区别？"><a href="#简述-Set、List、Map、Queue-四者的区别？" class="headerlink" title="简述 Set、List、Map、Queue 四者的区别？"></a>简述 Set、List、Map、Queue 四者的区别？</h2><ul><li><p>List存储的元素有序可重复。</p></li><li><p>Set存储的元素不可重复。</p></li><li><p>Queue按排队规则确定先后顺序，存储的元素有序可重复。</p></li><li><p>Map使用键值对存储，key无序不可重复，value无序可重复。</p></li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList-与-Array-的区别？"><a href="#ArrayList-与-Array-的区别？" class="headerlink" title="ArrayList 与 Array 的区别？"></a>ArrayList 与 Array 的区别？</h3><ul><li><p><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</p></li><li><p><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</p></li><li><p><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 <code>Integer</code>、<code>Double</code> 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</p></li><li><p><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</p></li><li><p><code>ArrayList</code> 创建时不需要指定大小，而 <code>Array</code> 创建时必须指定大小。</p></li></ul><h3 id="ArrayList-Vector-Stack-三者的区别？"><a href="#ArrayList-Vector-Stack-三者的区别？" class="headerlink" title="ArrayList Vector Stack 三者的区别？"></a>ArrayList Vector Stack 三者的区别？</h3><ul><li><p><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code> 存储，适用于频繁的查找工作，线程不安全。</p></li><li><p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用 <code>Object[]</code> 存储，线程安全。</p></li><li><p><code>Vector</code> 和 <code>Stack</code> 两者都是线程安全的，都是使用 <code>synchronized</code> 关键字进行同步处理。</p></li><li><p><code>Stack</code> 继承自 <code>Vector</code>，是一个后进先出的栈，而 <code>Vector</code> 是一个列表。</p></li></ul><h3 id="ArrayList-可以添加-null-值吗？"><a href="#ArrayList-可以添加-null-值吗？" class="headerlink" title="ArrayList 可以添加 null 值吗？"></a>ArrayList 可以添加 null 值吗？</h3><p><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。<br>不过，不建议向 <code>ArrayList</code> 中添加 <code>null</code> 值， <code>null</code> 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</p><h3 id="ArrayList-与-LinkedList-插入与删除元素时间复杂度对比"><a href="#ArrayList-与-LinkedList-插入与删除元素时间复杂度对比" class="headerlink" title="ArrayList 与 LinkedList 插入与删除元素时间复杂度对比"></a>ArrayList 与 LinkedList 插入与删除元素时间复杂度对比</h3><ol><li>ArrayList</li></ol><ul><li><p>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</p></li><li><p>尾部插入：当 ArrayList 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</p></li><li><p>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</p></li><li><p>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</p></li><li><p>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</p></li><li><p>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</p></li></ul><ol start="2"><li>LinkedList</li></ol><ul><li><p>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</p></li><li><p>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</p></li><li><p>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，不过由于有头尾指针，可以从较近的指针出发，因此需要遍历平均 n&#x2F;4 个元素，时间复杂度为 O(n)。</p></li></ul><h4 id="LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="LinkedList 为什么不能实现 RandomAccess 接口？"></a>LinkedList 为什么不能实现 RandomAccess 接口？</h4><p><code>RandomAcess</code> 是一个标记接口，表示实现该接口的类支持随机访问。<br>但 <code>LinkedList</code> 底层实现是链表，物理上不相邻，不支持随机访问。</p><h4 id="LinkedList-与-ArrayList-异同？"><a href="#LinkedList-与-ArrayList-异同？" class="headerlink" title="LinkedList 与 ArrayList 异同？"></a>LinkedList 与 ArrayList 异同？</h4><ul><li><p>是否线程安全： <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p></li><li><p>底层数据结构：<code>ArrayList</code> 底层使用的是 <code>Object</code> 数组；<code>LinkedList</code> 底层使用的是 双向链表 数据结构</p></li><li><p>插入和删除是否受元素位置影响：<code>ArrayList</code>采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响；<code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响</p></li><li><p>是否支持快速随机访问： <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。</p></li><li><p>内存空间占用： <code>ArrayList</code> 的空间浪费主要体现在在 <code>list</code> 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p></li></ul><h4 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h4><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h3><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p><ul><li><p><code>Comparable</code> 接口实际上是出自 <code>java.lang</code> 包，它有一个 <code>compareTo(Object obj)</code> 方法用来排序；</p></li><li><p><code>Comparator</code> 接口实际上是出自 <code>java.util</code> 包，它有一个 <code>compare(Object obj1, Object obj2)</code> 方法用来排序。</p></li></ul><h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul><li><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</p></li><li><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p></li><li><p>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 <code>FIFO</code> 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p></li></ul><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。</p><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。Deque 扩展了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法。</p><h3 id="ArrayDeque-与-LinkedList-区别"><a href="#ArrayDeque-与-LinkedList-区别" class="headerlink" title="ArrayDeque 与 LinkedList 区别"></a>ArrayDeque 与 LinkedList 区别</h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能。</p><ul><li><p><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</p></li><li><p><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</p></li><li><p><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p></li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><ul><li><p>线程是否安全： <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过 <code>synchronized</code> 修饰。</p></li><li><p>效率：因为线程安全的问题，<code>HashMap</code> 的效率要比 <code>Hashtable</code> 的效率高一些。</p></li><li><p>对 Null Key 与 Null Value 的支持：<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出<code> NullPointerException</code> 。</p></li><li><p>初始容量大小和每次扩充容量大小的不同：</p><ul><li><p>创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</p></li><li><p>创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的 <code>tableSizeFor()</code> 方法保证）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p></li></ul></li><li><p>底层数据结构： JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间；<code>Hashtable</code> 没有这样的机制。</p></li><li><p>哈希函数的实现：<code>HashMap</code> 对哈希值进行了高位和低位的混合扰动处理以减少冲突，而 <code>Hashtable</code> 直接使用键的 <code>hashCode()</code> 值。</p></li></ul><h3 id="HashMap-与-HashSet-的区别"><a href="#HashMap-与-HashSet-的区别" class="headerlink" title="HashMap 与 HashSet 的区别"></a>HashMap 与 HashSet 的区别</h3><p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。</p><h3 id="HashMap-与-TreeMap-的区别"><a href="#HashMap-与-TreeMap-的区别" class="headerlink" title="HashMap 与 TreeMap 的区别"></a>HashMap 与 TreeMap 的区别</h3><p><code>TreeMap</code> 和 <code>HashMap</code> 都继承自 <code>AbstractMap</code> ，但是需要注意的是 <code>TreeMap</code> 它还实现了 <code>NavigableMap</code> 接口和 <code>SortedMap</code> 接口。</p><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p><p>实现 <code>SortedMap</code> 接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。</p><h3 id="HashSet-如何检查元素重复？"><a href="#HashSet-如何检查元素重复？" class="headerlink" title="HashSet 如何检查元素重复？"></a>HashSet 如何检查元素重复？</h3><p>无论 <code>HashSet</code> 中是否已经存在了某元素，HashSet都会直接插入，只是会在 <code>add()</code> 方法的返回值处告诉我们插入前是否存在相同元素。</p><h3 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h3><h4 id="JDK1-8以前"><a href="#JDK1-8以前" class="headerlink" title="JDK1.8以前"></a>JDK1.8以前</h4><p>JDK1.8 之前 <code>HashMap</code> 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置(n是数组长度)<br>如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p><code>HashMap</code> 中的扰动函数（<code>hash</code> 方法）是用来优化哈希值的分布。通过对原始的 <code>hashCode()</code> 进行额外处理，扰动函数可以减小由于糟糕的 <code>hashCode()</code> 实现导致的碰撞，从而提高数据的分布均匀性。</p><p>JDK1.8的 hash 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><h4 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h4><p>当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><ol><li><code>putVal()</code> 方法中执行链表转红黑树的逻辑。</li></ol><p>链表的长度大于 8 的时候，就执行 <code>treeifyBin</code> （转换红黑树）的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 遍历链表</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>    <span class="hljs-comment">// 遍历到链表最后一个节点</span><br>    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 如果链表元素个数大于TREEIFY_THRESHOLD（8）</span><br>        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>            <span class="hljs-comment">// 红黑树转换（并不会直接转换成红黑树）</span><br>            treeifyBin(tab, hash);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>        <span class="hljs-keyword">break</span>;<br>    p = e;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><code>treeifyBin()</code> 方法中判断是否真的转换为红黑树。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">// 判断当前数组的长度是否小于 64</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        <span class="hljs-comment">// 如果当前数组的长度小于 64，那么会选择先进行数组扩容</span><br>        resize();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 否则才将列表转换为红黑树</span><br><br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)<br>                hd = p;<br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>)<br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树。</p><h3 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h3><ol><li><p>位运算效率更高：位运算(&amp;)比取余运算(%)更高效。当长度为 2 的幂次方时，<code>hash % length</code> 等价于 <code>hash &amp; (length - 1)</code>。</p></li><li><p>长度是 2 的幂次方，可以让 <code>HashMap</code> 在扩容的时候更均匀。<br>举例：</p></li></ol><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dns">假设有一个元素的哈希值为 <span class="hljs-number">10101100</span><br><br>旧数组元素位置计算：<br>hash        = <span class="hljs-number">10101100</span><br>length - <span class="hljs-number">1</span>  = <span class="hljs-number">00000111</span><br>&amp; -----------------<br>index       = <span class="hljs-number">00000100</span>  (<span class="hljs-number">4</span>)<br><br>新数组元素位置计算：<br>hash        = <span class="hljs-number">10101100</span><br>length - <span class="hljs-number">1</span>  = <span class="hljs-number">00001111</span><br>&amp; -----------------<br>index       = <span class="hljs-number">00001100</span>  (<span class="hljs-number">12</span>)<br><br>看第四位（从右数）：<br><span class="hljs-number">1</span>.高位为 <span class="hljs-number">0</span>：位置不变。<br><span class="hljs-number">2</span>.高位为 <span class="hljs-number">1</span>：移动到新位置（原索引位置+原容量）。<br></code></pre></td></tr></table></figure><h3 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h3><p>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。<br>为了解决这个问题，JDK1.8 版本的 <code>HashMap</code> 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。</p><h3 id="HashMap-为什么线程不安全"><a href="#HashMap-为什么线程不安全" class="headerlink" title="HashMap 为什么线程不安全"></a>HashMap 为什么线程不安全</h3><p>JDK 1.8 后，在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。<br>多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 判断是否出现 hash 碰撞</span><br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素（处理hash冲突）</span><br>    <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种情况是这两个线程同时 put 操作导致 size 的值不正确，进而导致数据覆盖的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="HashMap-几种遍历方式"><a href="#HashMap-几种遍历方式" class="headerlink" title="HashMap 几种遍历方式"></a>HashMap 几种遍历方式</h3><h3 id="ConcurrentHashMap-与-HashTable-的区别"><a href="#ConcurrentHashMap-与-HashTable-的区别" class="headerlink" title="ConcurrentHashMap 与 HashTable 的区别"></a>ConcurrentHashMap 与 HashTable 的区别</h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><p>底层数据结构：JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p></li><li><p>实现线程安全的方式</p><ul><li><p>JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p></li><li><p>JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 <code>CAS</code> 来操作。看起来就像是优化过且线程安全的 <code>HashMap</code>。</p></li><li><p>Hashtable(同一把锁) :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p></li></ul></li></ul><h3 id="ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><a href="#ConcurrentHashMap-线程安全的具体实现方式-底层具体实现" class="headerlink" title="ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现"></a>ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</h3><ol><li>JDK1.8以前</li></ol><p>首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。<br><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。<br><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p><p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦初始化就不能改变。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。<br><code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p><ol start="2"><li>JDK1.8之后</li></ol><p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。<br>数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。<br>Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p><h3 id="JDK1-7-和-JDK1-8的ConcurrentHashMap实现有什么不同？"><a href="#JDK1-7-和-JDK1-8的ConcurrentHashMap实现有什么不同？" class="headerlink" title="JDK1.7 和 JDK1.8的ConcurrentHashMap实现有什么不同？"></a>JDK1.7 和 JDK1.8的ConcurrentHashMap实现有什么不同？</h3><ul><li><p>线程安全实现方式：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p></li><li><p>Hash 碰撞解决方法 : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</p></li><li><p>并发度：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p></li></ul><h3 id="ConcurrentHashMap-为什么key和value不能为null"><a href="#ConcurrentHashMap-为什么key和value不能为null" class="headerlink" title="ConcurrentHashMap 为什么key和value不能为null"></a>ConcurrentHashMap 为什么key和value不能为null</h3><p><code>ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是为了避免二义性。</p><p>多线程环境下，存在一个线程操作该 <code>ConcurrentHashMap</code> 时，其他的线程将该 <code>ConcurrentHashMap</code> 修改的情况，所以无法通过 <code>containsKey(key)</code> 来判断否存在这个键值对，也就没办法解决二义性问题了。</p><p>与此形成对比的是，<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。单线程环境下，不存在一个线程操作该 HashMap 时，其他的线程将该 <code>HashMap</code> 修改的情况，所以可以通过 <code>contains(key)</code>来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能测试</title>
    <link href="/2025/01/22/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <url>/2025/01/22/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>性能测试是一种检查软件、应用或系统在特定负载下表现的方法。简单来说，就是看看它们能不能承受一定的工作量，并且还能正常运作。</p><p>相关术语</p><ul><li><p>并发用户：在性能测试工具中，一般称为虚拟用户（Virtual User，简称VU），指的是现实系统中操作业务的用户。</p></li><li><p>TPS：Transaction Per Second，每秒事务数，是衡量系统性能的一个非常重要的指标。</p></li><li><p>RPS：Request Per Second，每秒请求数。RPS模式适合用于容量规划和作为限流管控的参考依据。</p></li><li><p>RT：Response Time，响应时间，指的是业务从客户端发起到客户端接收的时间。</p></li><li><p>QPS (Queries Per Second)：每秒执行的查询次数。例如，如果一个网站的首页每秒可以响应 100 次用户请求，则该页面的 QPS 为 100。</p></li></ul><p>在性能测试中，通常有两种施压模式：并发模式和RPS模式。传统方式是使用并发用户数来衡量系统的性能（站在客户端视角）。此方法一般适用于一些网页站点的压测（例如H5页面）；而RPS（Requests per second）模式主要是为了方便直接衡量系统的吞吐能力TPS（Transaction Per Second，每秒事务数）而设计的（站在服务端视角），按照被压测端需要达到TPS等量设置相应的RPS，应用场景主要是一些动态的接口API，例如登录、提交订单等等。</p><p>易混点</p><ul><li><p>TPS vs. QPS:</p><ul><li><p>TPS 关注的是整个业务流程的完成情况，例如完成一笔订单交易。</p></li><li><p>QPS 更加细化，专注于单个数据库查询或 API 调用的速度。一个TPS可能包含多个QPS。</p></li></ul></li><li><p>QPS vs. RPS:</p><ul><li><p>QPS 通常特指数据库查询的频率，API 接口的调用速率。</p></li><li><p>RPS 是指 HTTP 请求的频率，可以包括GET、POST等不同类型的操作。</p></li></ul></li><li><p>TPS vs. RPS:</p><ul><li><p>TPS 关注的是业务层面的事务处理速度。</p></li><li><p>RPS 则是针对 HTTP 协议的请求处理速度，通常比 TPS 更加频繁。</p></li></ul></li></ul><p>VU和TPS换算<br>公式描述：TPS&#x3D;VU&#x2F;RT，（RT单位：秒）。</p><p>举例说明：假如1个虚拟用户在1秒内完成1笔事务，那么TPS明显就是1。如果某笔业务响应时间是1 ms，那么1个虚拟用户在1s内能完成1000笔事务，TPS就是1000了；如果某笔业务响应时间是1s，那么1个虚拟用户在1s内只能完成1笔事务，要想达到1000 TPS，就需要1000个虚拟用户。因此可以说1个虚拟用户可以产生1000 TPS，1000个虚拟用户也可以产生1000 TPS，无非是看响应时间快慢。</p><p>如何获取VU和TPS</p><ul><li>VU获取方式：</li></ul><p>已有系统：可选取高峰时刻，在一定时间内使用系统的人数，这些人数可认为是在线用户数，并发用户数可以取10%，例如在半个小时内，使用系统的用户数为10万，那么取10%（即1万）作为并发用户数基本就够了。</p><ul><li>TPS获取方式：</li></ul><p>已有系统：可选取高峰时刻，在一定时间内（如3分钟<del>10分钟），获取系统总业务量，计算单位时间（秒）内完成的笔数，乘以2</del>5倍作为峰值的TPS，例如峰值3分钟内处理订单18万笔，平均TPS是1000，峰值TPS可以是2000~5000。</p><p>Apache JMeter是Apache组织开发的基于Java的压力测试工具。Apache JMeter具备如下特性：</p><ul><li><p>支持分布式施压。</p></li><li><p>支持图形化界面，且支持流程编排，同时支持断言、逻辑控制器等高级指令，可满足复杂业务压测需求。</p></li><li><p>扩展性强，开发、测试人员可通过编写自己的插件，满足各种压测需求。</p></li><li><p>技术生态好，有强大的开源社区支持，开发者活跃度高。<br>支持查看资源监控、性能报告，但可查看的监控和报告指标较少。</p></li><li><p>基于并发模型，受限于JVM，单机无法支持超高并发。且只支持并发施压模型，不支持吞吐量施压模型。</p></li><li><p>开源支持的分布式能力无法大规模应用到生产环境，部署成本高。</p></li><li><p>不支持测试用例管理、压测脚本管理等功能。</p></li></ul><p>Jmeter介绍</p><p>JMeter 是 Apache 组织开发的一个开源的性能测试工具，主要用于对Web应用进行功能测试和性能测试。它最初是为了进行软件性能测试而设计的，但随着时间的发展，它的功能已经扩展到可以支持多种协议的测试，包括 HTTP、HTTPS、FTP、JDBC、JMS、SMTP 等。</p><p>主要特性如下：</p><ul><li><p>多协议支持： JMeter 可以用来测试各种协议的应用程序，这使得它成为一个非常灵活的工具，适用于多种场景。</p></li><li><p>负载测试和压力测试： 它能够模拟大量用户并发访问，用于评估系统的性能和稳定性。这对于识别系统瓶颈和优化系统至关重要。</p></li><li><p>可扩展性： 通过插件和脚本，JMeter 可以扩展其功能，以适应更复杂的应用环境和测试需求。</p></li><li><p>结果分析： JMeter 提供了丰富的图表和报告功能，帮助用户直观地理解测试结果，包括响应时间、吞吐量、错误率等关键指标。</p></li><li><p>脚本录制与回放： 使用 JMeter 的代理服务器功能，可以轻松地记录用户的浏览器操作，生成测试脚本，然后进行自动化测试。</p></li><li><p>分布式测试： 支持在多台机器上进行分布式测试，从而模拟更大的负载，测试大规模并发情况下的系统表现。</p></li><li><p>跨平台： JMeter 是基于 Java 编写的，因此可以在任何安装了Java运行环境的平台上运行。</p></li><li><p>免费开源： 作为 Apache 项目的一部分，JMeter 是完全免费且开源的，这意味着用户不仅可以使用它，还可以修改和扩展其功能。</p></li><li><p>社区支持： 拥有活跃的开发者和用户社区，提供持续的支持和更新，以及大量的教程和资源。</p></li><li><p>易于学习和使用： 尽管功能强大，但 JMeter 的界面直观，对于初学者来说相对容易上手。</p></li></ul><p>下载Jmeter</p><p>访问 Jmeter 官网：<a href="https://jmeter.apache.org/download_jmeter.cgi">https://jmeter.apache.org/download_jmeter.cgi</a> ，如下图所示，下载页中提供了各个系统的压缩包，这里是 Windows 系统，点击下载 .zip 后缀的压缩包。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122211442998.png" alt="Loading"></p><p>下载完成后，右键解压，无需安装即可使用。</p><p>启动Jmeter</p><p>进入 &#x2F;bin 文件夹下，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122211702631.png" alt="Loading"></p><ul><li><p>Windows 系统，双击 jmeter.bat 启动 Jmeter;</p></li><li><p>Linux、Mac 系统，进入到 &#x2F;bin 文件夹下，执行如下命令启动：</p></li></ul><p><code>sh jmeter.sh</code></p><p>主题修改</p><p>启动成功后，界面如下图所示，默认是暗黑主题，若想修改主题，点击 Options | Look and Feel, 有多种主题可供选择</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122211934808.png" alt="Loading"></p><p>如果喜欢明亮主题，勾选 Metal 即可，然后重启即可应用最新的设置。</p><p>语言设置<br>Jmeter 默认的语言是英文，如果想修改为中文，有两种方式。</p><p>临时设置<br>一种是临时性的设置，点击菜单 Options | Choose Lanuage | Chinese（Simplified）, 即可设置为简体中文。这种方式有个弊端，当重新打开 Jmeter 后，设置就会失效，必须得重新设置。</p><p>永久设置<br>要想永久设置 Jmeter 的语言为中文，可进入到 &#x2F;bin 目录下，找到 jmeter.properties 配置文件：<br>编辑它，将语言设置项的注释放开，并修改为 zh-CN 。</p><p>Jmeter 压测 K-V 存储服务接口</p><p>在测试计划上 右键 | 添加 | 线程 | 线程组</p><p>解释一下线程组的作用：</p><ul><li><p>模拟用户行为： 线程组用于模拟多个用户同时访问服务器或应用程序。每个线程代表一个虚拟用户。</p></li><li><p>控制并发数： 线程组允许你指定同时运行的线程数量，即虚拟用户的数量。这有助于模拟不同级别的并发负载，从而评估系统的性能和稳定性。</p></li><li><p>设置循环次数： 在线程组中，你可以设置采样器的执行次数。这意味着每个虚拟用户将按照设定的次数重复执行相同的请求序列，这对于长时间的压力测试尤其有用。</p></li></ul><p>线程组添加完成后，为了能够发送 HTTP 请求，还需要在线程组上右键 | 添加 | 取样器 | HTTP 请求</p><p>为了能够查看请求接口响应结果，在 HTTP 请求上 右键 | 添加 | 监听器 | 查看结果树</p><p>以上都配置完成后，一个简单的 GET 请求就配置好了。</p><p>请求结果可以点击 响应数据 | Response Body 来查看</p><p>POST 请求</p><p>为了能够发送 application&#x2F;json 请求，还需要为 HTTP 请求右键 | 添加 | 配置元件 | HTTP 信息头管理器</p><p>添加一个请求头，Key 值为 Content-Type , Value 值为 application&#x2F;json</p><p>点击 HTTP 请求，为其添加请求入参，点击消息体数据，填写接口的 JSON 入参</p><p>运行测试之前，可以对查看结果树 右键 | 清除 ， 把之前跑测试的结果全部删除</p><p>压测接口：笔记内容新增</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122212506419.png" alt="Loading"></p><p>压测接口：笔记内容查询</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122212600873.png" alt="Loading"></p><p>Jmeter 线程组间传递 Token</p><p>通过 Jmeter 测试接口时，有些接口需要先认证，才能够请求成功的，此时就需要在请求头中设置 Token 令牌。虽然测试的时候，如下图所示，可以编辑 HTTP 信息头管理器，来写死一个 Token 令牌来达到目的。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122212719681.jpg" alt="Loading"></p><p>新增线程组：用户登录接口</p><p>在测试计划上右键，新增一个线程组，并创建用户登录接口的 HTTP 请求。</p><p>禁用线程组</p><p>我们可以在不想要运行的线程组上右键 | 禁用，以禁止执行该线程组。</p><p>JSON 提取器</p><p>为了能够提取出返参中的 Token 令牌，需要对 HTTP 请求右键 | 添加 | 后置处理器 | JSON 提取器。</p><p>调试后置处理器</p><p>为了能够调试 Token 令牌是否提取成功了，可以对 HTTP 请求右键 | 添加 | 后置处理器 | Debug PostProcessor 。</p><p>BeanShell 后置处理器</p><p>为了能够实现跨线程组传递 Token 令牌，需要在 HTTP 请求右键 | 添加 | 后置处理器 | BeanShell PostProcessor。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cassandra安装与使用</title>
    <link href="/2025/01/22/Cassandra%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/01/22/Cassandra%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Cassandra"><a href="#什么是-Cassandra" class="headerlink" title="什么是 Cassandra ?"></a>什么是 Cassandra ?</h1><p>Apache Cassandra 是一个开源的分布式 NoSQL（Not Only SQL）数据库管理系统，专为处理大规模数据量和高写入频率的工作负载而设计。它最初由 Facebook 开发，后来贡献给了 Apache 软件基金会，成为了 Apache 的一个顶级项目。</p><p>Cassandra 结合了 Google Bigtable 的数据模型和 Amazon Dynamo 的完全分布式架构，提供了以下关键特性：</p><ul><li><p>高可用性：Cassandra 是一个无单点故障的系统，它通过数据复制和一致性级别选择，确保即使在节点失败的情况下数据仍然可访问。</p></li><li><p>水平可扩展性：Cassandra 能够通过添加更多节点到集群中轻松扩展，无需停机，这使得它能够处理不断增长的数据量和用户负载。</p></li><li><p>分布式数据存储：数据在集群中的多个节点上分布存储，每个节点都是平等的，没有主从之分，这有助于提高性能和可靠性。</p></li><li><p>最终一致性：Cassandra 允许开发者选择数据的一致性和可用性之间的权衡，通过可配置的一致性级别，可以在强一致性和高可用性之间找到合适的平衡点。</p></li><li><p>数据模型：Cassandra 使用列族（column-family）的数据模型，允许以宽列的方式存储数据，非常适合存储半结构化或非结构化数据。</p></li><li><p>数据压缩和索引：Cassandra 支持数据压缩和创建二级索引，以提高存储效率和查询性能。</p></li><li><p>多数据中心复制：Cassandra 支持跨多个地理区域的数据中心复制，以实现数据的地理分布和灾难恢复。</p></li></ul><p>Cassandra 被广泛应用于需要处理大量数据和高写入负载的场景，例如社交网络、物联网（IoT）、实时数据分析和推荐系统等。由于其强大的可扩展性和高可用性，Cassandra 成为了许多大型企业如 Netflix、Digg、Twitter 等的选择。</p><h2 id="Cassandra安装"><a href="#Cassandra安装" class="headerlink" title="Cassandra安装"></a>Cassandra安装</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>执行如下命令，开始拉取 <code>cassandra</code> 最新的镜像。</p><p><code>docker pull cassandra:latest</code></p><p>拉取成功后，可执行 <code>docker images</code> 命令查看本地已下载的镜像，确认一下 <code>cassandra</code> 是否下载成功。</p><h3 id="准备挂载的文件夹"><a href="#准备挂载的文件夹" class="headerlink" title="准备挂载的文件夹"></a>准备挂载的文件夹</h3><p>在 <code>E:/docker</code> 路径下，创建一个 <code>/cassandra</code> 文件夹，用于等会启动容器时，将需要持久化的数据挂载到宿主机中，防止容器重启时数据丢失。</p><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p>前置工作完成后，执行如下命令，运行一个 <code>cassandra</code> 容器：</p><p><code>docker run --name cassandra -d -p 9042:9042 -v E:\docker\cassandra\data:/var/lib/cassandra cassandra:latest</code></p><p>各参数含义：</p><ul><li><p><code>docker run</code>: 这是 Docker 用来启动一个新的容器的命令。</p></li><li><p><code>--name cassandra</code>: 这个选项指定了容器的名称为 “cassandra”。给容器命名可以帮助你在将来更容易地识别和管理它。</p></li><li><p><code>-d</code>: 这个标志表示在后台（守护进程模式）运行容器，不会阻塞你的终端会话。</p></li><li><p><code>-p 9042:9042</code>: 这个选项进行了端口映射，将宿主机的 9042 端口映射到容器内的 9042 端口。这意味着你可以在宿主机上通过 9042 端口访问 Cassandra 容器提供的服务。Cassandra 默认使用 9042 端口作为 CQL shell 的接入点。</p></li><li><p><code>-v E:\docker\cassandra\data:/var/lib/cassandra</code>: 这是一个卷（volume）映射，将宿主机上的目录 <code>E:\docker\cassandra\data</code> 挂载到容器内的 <code>/var/lib/cassandra</code> 目录。这个目录是 Cassandra 用来存储数据和日志的地方。通过这种方式，即使容器被删除，数据也会保留在宿主机上，因为数据存储在持久化的卷中。</p></li><li><p><code>cassandra:latest</code>: 这指定了要使用的 Docker 镜像。在这里，镜像是 Cassandra 的官方镜像，并且使用了 latest 标签，意味着拉取 Cassandra 的最新版本镜像。</p></li></ul><p>执行完毕后，执行 <code>docker ps</code> 命令，可查看本地正在运行中的 <code>Docker</code> 容器，确认一下 <code>cassandra</code> 是否启动成功了。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122202326486.png" alt="Loading"></p><h2 id="Cassandra使用"><a href="#Cassandra使用" class="headerlink" title="Cassandra使用"></a>Cassandra使用</h2><ol><li>打开cqlsh命令行</li></ol><p>cassandra 容器运行成功后，执行如下命令，可进入到容器中：</p><p><code>docker exec -it cassandra /bin/sh</code></p><p>接着，执行如下命令，可打开 cqlsh 命令行工具：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">cqlsh</span><br>或<br>cqlsh <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">9042</span><br></code></pre></td></tr></table></figure><p>什么是 cqlsh ?</p><p>cqlsh 是 Cassandra Query Language Shell 的缩写，它是一个命令行工具，允许你向 Cassandra 数据库发送查询、创建表、插入数据、检索数据等。</p><p>若如下图所示，提示 Connected to Test Cluster at 127.0.0.1:9042 , 则说明已经成功连接上了 cassandra。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122202537481.png" alt="Loading" title="cassandra"></p><h2 id="CQL基本命令"><a href="#CQL基本命令" class="headerlink" title="CQL基本命令"></a>CQL基本命令</h2><p>Cassandra 基本概念<br>在学习 CQL 命令之前，先理解一下 Cassandra 中几个基本概念：</p><ul><li><p>节点（Node）：Cassandra 集群中的每个服务器称为一个节点。每个节点都存储数据，并且相互之间没有主从关系，所有节点都是对等的。</p></li><li><p>集群（Cluster）：由多个节点组成的分布式系统称为集群。集群中的节点共同工作，处理读写请求并存储数据。</p></li><li><p>数据中心（Data Center）：集群中的节点可以分布在多个数据中心，每个数据中心包含若干个节点。数据中心的划分有助于实现跨地域的高可用性。</p></li><li><p>键空间（Keyspace）：键空间是一个逻辑容器，用于管理多个表，可以理解为 MySQL 中的库。另外，键空间定义了数据复制的策略。<br>表（Table）：表是数据存储的基本单位，由行和列组成。每张表都有一个唯一的名称和定义。</p></li><li><p>主键（Primary Key）：每行数据都有一个唯一的主键。主键由分区键和可选的列组成，用于唯一标识数据行。</p></li><li><p>分区键（Partition Key）：Cassandra 使用分区键的哈希值将数据分布到不同的节点上，从而实现负载均衡和数据的水平扩展。分区键可以是单个列或多列的组合（复合分区键）。</p></li></ul><ol><li>键空间（Keyspace）</li></ol><p>打开 cqlsh 命令行，执行下面语句，来创建一个 <code>Keyspace</code>。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">KEYSPACE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> test<br><span class="hljs-keyword">WITH</span> replication = &#123;<span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;SimpleStrategy&#x27;</span>, <span class="hljs-string">&#x27;replication_factor&#x27;</span>: <span class="hljs-number">1</span>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>CREATE KEYSPACE IF NOT EXISTS</code>: 这是创建 keyspace 的命令，<code>IF NOT EXISTS</code> 是一个条件语句，确保只有当 keyspace 还未创建时才执行创建操作。这样可以防止重复创建 keyspace 导致的错误。</p></li><li><p><code>test</code>: 这是即将创建的 keyspace 的名称。keyspace 类似于传统关系型数据库中的“数据库”，是 Cassandra 中数据的最高层级容器。</p></li><li><p><code>WITH replication</code>: 这里指定了 keyspace 的复制策略和配置。复制策略决定了数据如何在集群中复制和分布。</p></li><li><p><code>&#39;class&#39;: &#39;SimpleStrategy&#39;</code>: 这里指定了复制策略的类型为 <code>SimpleStrategy</code>。<code>SimpleStrategy</code> 是一种基本的复制策略，适用于单数据中心的部署。它将数据均匀地分布到集群中的节点上。</p></li><li><p><code>&#39;replication_factor&#39;</code>: 1: 这是复制因子，表示每个数据分区的副本数量。在这个例子中，<code>replication_factor</code> 设置为 1，意味着每个数据分区只有一个副本，这通常用于测试或开发环境，但在生产环境中可能不是最佳实践，因为缺乏冗余会导致数据丢失的风险增加。</p></li></ul><ol start="2"><li>键空间创建完成后，执行如下命令，可查看所有的 <code>Keyspace</code>。</li></ol><p><code>DESCRIBE KEYSPACES;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122203134492.png" alt="Loading"></p><ol start="3"><li>如果想删除某个键空间，以及其中的所有数据，可执行如下语句。</li></ol><p><code>DROP KEYSPACE IF EXISTS test;</code></p><ol start="4"><li>键空间创建完成后，可通过 USE 命令，选择该 Keyspace ，以便后续操作它。</li></ol><p><code> USE test;</code></p><ol start="5"><li>执行如下语句，创建一张 <code>note_content</code> 笔记内容表。这里注意，由于我们是拿 Cassandra 充当 K-V 键值存储数据库，所以表中只包含两个字段（实际可以支持多字段），<code>id</code> 主键充当 <code>Key</code> , 笔记内容 <code>content</code> 充当 <code>Value</code> :</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE TABLE</span> note_content (<br>    id UUID <span class="hljs-keyword">PRIMARY KEY</span>,<br>    content TEXT<br>);<br></code></pre></td></tr></table></figure><ul><li><p><code>CREATE TABLE</code>: 这是 Cassandra 中创建新表的命令。</p></li><li><p><code>note_content</code>: 表的名称。</p></li><li><p><code>(</code> 和 <code>)</code>：这些括号包含了表的列定义和主键定义。</p></li><li><p><code>id UUID PRIMARY KEY</code>: 这里定义了表中的一个列 <code>id</code>，其数据类型是 <code>UUID</code>（通用唯一标识符）。<code>PRIMARY KEY</code> 指示 id 列是表的主键。在 Cassandra 中，主键用于唯一标识表中的每一行，同时也是数据在集群中分区的依据。</p></li><li><p><code>content TEXT</code>: 这里定义了另一个列 content，其数据类型是 TEXT。TEXT 类型用于存储文本字符串。</p></li></ul><p>为什么这里要用 UUID? 而不是笔记本身的 ID?</p><p>UUID 生成的值具有较高的随机性，因此在集群中可以提供良好的数据分布，避免热点问题。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122203548357.png" alt="Loading"></p><ol start="6"><li>执行如下语句，查询 <code>note_content</code> 表中所有数据。</li></ol><p><code>SELECT * FROM note_content;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122203650219.png" alt="Loading"></p><ol start="7"><li>笔记内容表创建完成后，执行如下语句，插入一条数据。</li></ol><p><code>INSERT INTO note_content (id, content) VALUES (uuid(), &#39;这是一条测试笔记&#39;);</code></p><ol start="8"><li>执行如下语句，以 id 为条件来更新对应笔记内容。</li></ol><p><code>UPDATE note_content SET content = &#39;更新后的评论内容&#39; WHERE id = 7e1c4af6-9b12-4f89-a5d1-0e05f8a627c7;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122203905346.png" alt="Loading"></p><ol start="9"><li>执行如下语句，将 id 为 7e1c4af6-9b12-4f89-a5d1-0e05f8a627c7 的记录删除掉。</li></ol><p><code>DELETE FROM note_content WHERE id = 7e1c4af6-9b12-4f89-a5d1-0e05f8a627c7;</code></p><p>![Loading](<a href="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122204050982.png">https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122204050982.png</a> “)</p>]]></content>
    
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Cassandra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenFeign组件</title>
    <link href="/2025/01/22/OpenFeign%E7%BB%84%E4%BB%B6/"/>
    <url>/2025/01/22/OpenFeign%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-OpenFeign"><a href="#什么是-OpenFeign" class="headerlink" title="什么是 OpenFeign ?"></a>什么是 OpenFeign ?</h1><p>OpenFeign 是一个声明式的 HTTP 客户端，它使得我们可以非常方便地调用 HTTP 接口。OpenFeign 是 Netflix 开源的 Feign 项目的扩展，旨在与 Spring Cloud 紧密集成。它通过注解来定义接口，类似于 Spring MVC 的控制器，使得开发者可以专注于业务逻辑，而不需要关注 HTTP 请求的具体实现。</p><h2 id="OpenFeign-使用"><a href="#OpenFeign-使用" class="headerlink" title="OpenFeign 使用"></a>OpenFeign 使用</h2><ol><li>添加OpenFeign依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- OpenFeign --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 负载均衡 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>TIP : <code>OpenFeign</code> 通常和 <code>loadbalancer</code> 接口负载均衡组件搭配使用。</p><ol start="2"><li>声明 FeignClient 客户端接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = ApiConstants.SERVICE_NAME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FileFeignApi</span> &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/file&quot;</span>;<br><br>    <span class="hljs-meta">@PostMapping(value = PREFIX + &quot;/test&quot;)</span><br>    Response&lt;?&gt; test();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注：</p><ul><li><code>@FeignClient</code> 是用来标记这个接口是一个 Feign 客户端的注解。<ul><li><code>name = ApiConstants.SERVICE_NAME</code> 指定了这个 Feign 客户端所调用的服务名称。这个名称通常是在注册中心（如 Eureka 或 Nacos）中注册的服务名称。</li></ul></li><li><code>String PREFIX = &quot;/file&quot;</code> : 定义了一个前缀常量，用于接口中 URI 的路径前缀。</li><li><code>@PostMapping</code> 注解标记这个方法将执行一个 HTTP POST 请求。<ul><li><code>value = PREFIX + &quot;/test&quot;</code> 指定了这个 POST 请求的路径，这里是 <code>&quot;/file/test&quot;</code>。</li></ul></li></ul><p>2.1 创建 <code>ApiConstants</code> 常量类，定义一个服务名称常量，即本身注册到 Nacos 中的服务名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiConstants</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">SERVICE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xiaohashu-oss&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，对象存储服务就将 <code>/file/test</code> 接口的 <code>Feign</code> 客户端，封装到 <code>api</code> 模块中了，有其他服务想要调用对象存储服务的 <code>/file/test</code> 接口，只需引入 <code>xiaohashu-oss-api</code> 模块即可。</p><ol start="3"><li>启用Feign客户端<br>编辑 <code>XiaohashuUserBizApplication</code> 启动类，添加 <code>@EnableFeignClients</code> 注解，以启用引入的 <code>xiaohashu-oss-api</code> 模块中定义好的 <code>Feign</code> 客户端。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;com.quanxiaoha.xiaohashu&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaohashuUserBizApplication</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>服务间调用<br>以上工作完成后，就可以在用户服务中，注入 <code>FileFeignApi</code> 客户端，来调用对象存储服务的 <code>/file/test</code> 接口了。</li></ol><h2 id="OpenFeign-支持表单请求"><a href="#OpenFeign-支持表单请求" class="headerlink" title="OpenFeign 支持表单请求"></a>OpenFeign 支持表单请求</h2><p>针对于图片上传，普通的调用方式还不行，需要额外配置表单提交。</p><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Feign 表单提交 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign.form<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-form<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="feign-form-依赖是干嘛的？"><a href="#feign-form-依赖是干嘛的？" class="headerlink" title="feign-form 依赖是干嘛的？"></a>feign-form 依赖是干嘛的？</h3><p><code>feign-form</code> 是一个 Feign 扩展库，专门用于处理表单数据的编码。它提供了一些增强功能，使 Feign 客户端能够更方便地处理表单提交和文件上传等操作。</p><p>表单配置类<br>新建一个 <code>FeignFormConfig</code>表单配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignFormConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Encoder <span class="hljs-title function_">feignFormEncoder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringFormEncoder</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>SpringFormEncoder</code> 是 Feign 提供的一个编码器，用于处理表单提交。它将对象编码为表单数据格式（如 <code>application/x-www-form-urlencoded</code> 或 <code>multipart/form-data</code>），以便在 HTTP 请求中使用。</li></ul><h2 id="封装-Feign-调用"><a href="#封装-Feign-调用" class="headerlink" title="封装 Feign 调用"></a>封装 Feign 调用</h2><p>创建一个 <code>/rpc</code> 包，统一放置服务间调用代码，并新建 <code>OssRpcService</code> 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OssRpcService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> FileFeignApi fileFeignApi;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">uploadFile</span><span class="hljs-params">(MultipartFile file)</span> &#123;<br>        <span class="hljs-comment">// 调用对象存储服务上传文件</span><br>        Response&lt;?&gt; response = fileFeignApi.uploadFile(file);<br><br>        <span class="hljs-keyword">if</span> (!response.isSuccess()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回图片访问链接</span><br>        <span class="hljs-keyword">return</span> (String) response.getData();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将调用对象存储服务上传文件的逻辑，单独封装一层 <code>service</code>，并声明一个 <code>uploadFile()</code> 方法。方法中，若调用对象存储服务成功，则返回图片链接；否则，返回 <code>null</code> 。</p><h2 id="Feign-请求拦截器：实现-userId-服务间透传"><a href="#Feign-请求拦截器：实现-userId-服务间透传" class="headerlink" title="Feign 请求拦截器：实现 userId 服务间透传"></a>Feign 请求拦截器：实现 userId 服务间透传</h2><p>如果说，我们想在下游服务中获取当前请求对应的用户 ID , 比如，修改用户信息接口，会调用对象存储微服务，在对象存储微服务中，通过前面封装的上下文组件获取当前用户 ID，能拿的到吗？</p><p>为什么获取不到？</p><p>原因是网关路由转发到服务时，网关层会设置用户 ID 到请求头中，但是，服务之间调用是通过 <code>Feign</code> 来完成的，是没有经过网关的，下游服务再去从请求头中获取用户 ID，自然是拿不到。</p><p>如何解决上面这个问题呢？</p><p>可以为 <code>Feign</code> 单独配置一个请求拦截器，在调用其他服务时，将当前用户 ID 添加到请求头中，保证下游服务也能够通过上下文组件拿到用户 ID。</p><ol><li>配置 Feign 请求拦截器<br>将这个功能，一并放到上下文组件中。首先，编辑 <code>xiaoha-spring-boot-starter-biz-context</code> 上下文组件的 <code>pom.xml</code>, 添加 <code>feign</code> 核心依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上下文组件中，创建一个 <code>/interceptor</code> 包，用于放置拦截器，并新建 <code>FeignRequestInterceptor</code> 请求拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignRequestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RequestInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(RequestTemplate requestTemplate)</span> &#123;<br>        <span class="hljs-comment">// 获取当前上下文中的用户 ID</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> LoginUserContextHolder.getUserId();<br><br>        <span class="hljs-comment">// 若不为空，则添加到请求头中</span><br>        <span class="hljs-keyword">if</span> (Objects.nonNull(userId)) &#123;<br>            requestTemplate.header(GlobalConstants.USER_ID, String.valueOf(userId));<br>            log.info(<span class="hljs-string">&quot;########## feign 请求设置请求头 userId: &#123;&#125;&quot;</span>, userId);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>自定义 <code>Feign</code> 请求拦截器需继承自 <code>RequestInterceptor</code> 接口；</p></li><li><p>在 <code>apply()</code> 方法中，先通过 <code>LoginUserContextHolder.getUserId()</code>; 拿到当前请求对应的用户 ID;</p></li><li><p>判断若不为空，则将用户 ID 添加到请求头中，以便下游服务再次获取；</p></li></ul><ol start="2"><li>自动化配置</li></ol><p>在 <code>/config</code> 包下，新建一个 <code>FeignContextAutoConfiguration</code> 自动化配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfiguration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignContextAutoConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FeignRequestInterceptor <span class="hljs-title function_">feignRequestInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FeignRequestInterceptor</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将刚刚自定义的 <code>FeignRequestInterceptor</code> 请求拦截器，自动注入到 Spring 容器中。</li></ul><p>同时，别忘了在 <code>org.springframework.autoconfigure.AutoConfiguration.imports</code> 文件中，添加上 <code>FeignContextAutoConfiguration</code> 的完整包路径。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>OpenFeign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云OSS</title>
    <link href="/2025/01/22/%E9%98%BF%E9%87%8C%E4%BA%91OSS/"/>
    <url>/2025/01/22/%E9%98%BF%E9%87%8C%E4%BA%91OSS/</url>
    
    <content type="html"><![CDATA[<ol><li>开通服务<br>需要登录阿里云官网，并访问对象存储 OSS 产品首页：<a href="https://www.aliyun.com/product/oss">https://www.aliyun.com/product/oss</a> ，如下图所示，点击立即开通按钮，开通服务<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122170737048.png" alt="Loading" title="Aliyun OSS"><br>开通成功后，进入到对象存储 OSS 控制台， 点击 Bucket 列表，在 Bucket 列表中，点击上方的创建 Bucket 按钮，准备创建桶，填写 Bucket 相关配置项，如下：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122170900224.png" alt="Loading" title="配置"></li></ol><ul><li>模式选择：勾选自定义创建；</li><li>Bucket 名称： </li><li>地域：推荐选择离你产品使用者较近的地方，有助于提升访问速度。</li><li>阻止公共访问：关闭掉，并将读写权限修改为公共读；</li></ul><ol start="2"><li>获取 AccessKey 接入凭证<br>通过代码上传文件到 Bucket ，阿里云需要校验你的身份，还需要获取一下接入凭证。点击回到阿里云首页，将鼠标移动到登录用户的头像上，即可看到 AccessKey 选项，点击即可查看<br>将你的 AccessKeyID 以及 AccessKey Secret 复制出来</li></ol><p>编辑模块的 application-dev.yml 开发环境配置，修改一下 minio 配置项的结构，统一放置到 storage 节点下，方便统一维护。再额外加一下阿里云 OSS 需要用到的配置项，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#=================================================================</span><br><span class="hljs-comment"># 对象存储配置</span><br><span class="hljs-comment">#=================================================================</span><br><span class="hljs-attr">storage:</span><br>  <span class="hljs-attr">minio:</span><br>    <span class="hljs-attr">endpoint:</span> <span class="hljs-string">http://127.0.0.1:9000</span><br>    <span class="hljs-attr">accessKey:</span> <span class="hljs-string">xxx</span><br>    <span class="hljs-attr">secretKey:</span> <span class="hljs-string">xxx</span><br>  <span class="hljs-attr">aliyun-oss:</span><br>    <span class="hljs-attr">endpoint:</span> <span class="hljs-string">oss-cn-hangzhou.aliyuncs.com</span> <span class="hljs-comment"># 改成你自己的</span><br>    <span class="hljs-attr">accessKey:</span> <span class="hljs-string">xxx</span> <span class="hljs-comment"># 改成你自己的</span><br>    <span class="hljs-attr">secretKey:</span> <span class="hljs-string">xxx</span> <span class="hljs-comment"># 改成你自己的</span><br></code></pre></td></tr></table></figure><ol start="3"><li>添加阿里云OSS配置类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;storage.aliyun-oss&quot;)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunOSSProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> String endpoint;<br>    <span class="hljs-keyword">private</span> String accessKey;<br>    <span class="hljs-keyword">private</span> String secretKey;<br>&#125;```<br><br>添加依赖<br>```java<br> &lt;!-- 阿里云 OSS --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;<br>            &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;<br>            &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;javax.activation&lt;/groupId&gt;<br>            &lt;artifactId&gt;activation&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        &lt;!-- no more than <span class="hljs-number">2.3</span><span class="hljs-number">.3</span>--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;<br>            &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>阿里云配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunOSSConfig</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> AliyunOSSProperties aliyunOSSProperties;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构建 阿里云 OSS 客户端</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> OSS <span class="hljs-title function_">aliyunOSSClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 设置访问凭证</span><br>        <span class="hljs-type">DefaultCredentialProvider</span> <span class="hljs-variable">credentialsProvider</span> <span class="hljs-operator">=</span> CredentialsProviderFactory.newDefaultCredentialProvider(<br>                aliyunOSSProperties.getAccessKey(), aliyunOSSProperties.getSecretKey());<br><br>        <span class="hljs-comment">// 创建 OSSClient 实例</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClientBuilder</span>().build(aliyunOSSProperties.getEndpoint(), credentialsProvider);<br>    &#125;<br>&#125;```<br><br>阿里云策略实现类<br>```java<br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunOSSFileStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FileStrategy</span>  &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> AliyunOSSProperties aliyunOSSProperties;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> OSS ossClient;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">uploadFile</span><span class="hljs-params">(MultipartFile file, String bucketName)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;## 上传文件至阿里云 OSS ...&quot;</span>);<br><br>        <span class="hljs-comment">// 判断文件是否为空</span><br>        <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">null</span> || file.getSize() == <span class="hljs-number">0</span>) &#123;<br>            log.error(<span class="hljs-string">&quot;==&gt; 上传文件异常：文件大小为空 ...&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;文件大小不能为空&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 文件的原始名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFileName</span> <span class="hljs-operator">=</span> file.getOriginalFilename();<br><br>        <span class="hljs-comment">// 生成存储对象的名称（将 UUID 字符串中的 - 替换成空字符串）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString().replace(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// 获取文件的后缀，如 .jpg</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">suffix</span> <span class="hljs-operator">=</span> originalFileName.substring(originalFileName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><br>        <span class="hljs-comment">// 拼接上文件后缀，即为要存储的文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">objectName</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s%s&quot;</span>, key, suffix);<br><br>        log.info(<span class="hljs-string">&quot;==&gt; 开始上传文件至阿里云 OSS, ObjectName: &#123;&#125;&quot;</span>, objectName);<br><br>        <span class="hljs-comment">// 上传文件至阿里云 OSS</span><br>        ossClient.putObject(bucketName, objectName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(file.getInputStream().readAllBytes()));<br><br>        <span class="hljs-comment">// 返回文件的访问链接</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;https://%s.%s/%s&quot;</span>, bucketName, aliyunOSSProperties.getEndpoint(), objectName);<br>        log.info(<span class="hljs-string">&quot;==&gt; 上传文件至阿里云 OSS 成功，访问路径: &#123;&#125;&quot;</span>, url);<br>        <span class="hljs-keyword">return</span> url;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minio对象存储</title>
    <link href="/2025/01/22/Minio%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"/>
    <url>/2025/01/22/Minio%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<ol><li><p>什么是 MinIO？<br>MinIO 是一个开源的对象存储服务器。这意味着它允许你在互联网上存储大量数据，比如文件、图片、视频等，而不需要依赖传统的文件系统。MinIO 的特点在于它非常灵活、易于使用，同时也非常强大，可以在你的应用程序中方便地集成。</p></li><li><p>为什么使用 MinIO？</p></li></ol><ul><li><p>可伸缩性和性能： MinIO 允许你在需要时轻松地扩展存储容量，无需中断服务。它具有出色的性能，可以处理大量的并发读取和写入请求。</p></li><li><p>开源和自由： MinIO 是开源软件，遵循 Apache License 2.0 许可证，这意味着你可以自由地使用、修改和分发它。</p></li><li><p>容器化部署： MinIO 提供了容器化部署的支持，可以在各种平台上快速部署和运行，包括本地开发机、云服务器和容器编排环境（如 Docker）。</p></li><li><p>兼容性： MinIO 提供了 S3 兼容的 API，这意味着它可以与任何兼容 Amazon S3 的应用程序无缝集成，为你的应用程序提供强大的对象存储能力。</p></li><li><p>易用性： MinIO 的配置和管理非常简单，它提供了直观的Web控制台和命令行工具，帮助你方便地管理存储桶和对象。</p></li></ul><p>总的来说，MinIO 是一个灵活、高性能、易用且开源的对象存储解决方案，适用于各种规模的应用程序，特别是那些需要大规模数据存储和访问的项目。</p><ol start="3"><li>Docker搭建Minio服务<br>3.1 选择一个 Minio 镜像<br>然后，我们在浏览器中访问地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a> ， 输入关键词 minio&#x2F;minio, 找到 Minio 镜像：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122164023293.png" alt="Loading" title="Minio"></li></ol><p>点击进去，点击 Tags 标签选项，选择最新的一个发行版本：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122164100224.png" alt="Loading" title="Tags"></p><p>3.2 下载Minio镜像<br>打开命令行，执行该命令拉取镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull minio/minio:RELEASE.2023-09-30T07-02-29Z<br></code></pre></td></tr></table></figure><p>镜像下载成功后，执行 <code>docker images</code> , 如果列表中有 <code>minio/minio</code> 镜像，则表示镜像下载成功了：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122164239816.png" alt="Loading" title="images"></p><p>3.3 新建数据挂载目录<br>下载镜像成功后，我们在某个盘下，新建一个 &#x2F;docker 文件夹，然后在该文件夹中再新建一个 &#x2F;minio 文件夹。<br>新建该文件夹的目的是，后面通过镜像运行 Minio 容器时，可以将容器内的数据目录，挂载到宿主机的 E:\docker\minio 目录下，防止容器重启后，会导致数据丢失的问题。</p><p>3.4 运行 Docker Minio 容器<br>通过该镜像运行 <code>Minio</code> 容器，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d \<br>   -p 9000:9000 \<br>   -p 9090:9090 \<br>   --name minio \<br>   -v E:\docker\minio\data:/data \<br>   -e <span class="hljs-string">&quot;MINIO_ROOT_USER=xxx&quot;</span> \<br>   -e <span class="hljs-string">&quot;MINIO_ROOT_PASSWORD=xxx&quot;</span> \<br>   minio/minio:RELEASE.2023-09-30T07-02-29Z server /data --console-address <span class="hljs-string">&quot;:9090&quot;</span><br></code></pre></td></tr></table></figure><p>命令选型含义：</p><ul><li><code>docker run</code>: 运行 Docker 容器的命令。</li><li><code>-d</code> : 表示后台运行该容器；</li><li><code>-p 9000:9000</code>: 将宿主机的 9000 端口映射到容器的 9000 端口。MinIO 默认的 HTTP API 端口是 9000。</li><li><code>-p 9090:9090</code>: 将宿主机的 9090 端口映射到容器的 9090 端口。这是 MinIO 的 Web 控制台的端口。</li><li><code>--name minio</code>: 给容器取了一个名字，这里是 “minio”。</li><li><code>-v E:\docker\minio\data:/data</code>: 将宿主机上的 <code>E:\docker\minio\data</code> 目录映射到容器内的 <code>/data</code>目录。这是 MinIO 存储数据的地方。如果你希望数据在容器删除后仍然保存，可以将数据目录映射到宿主机。</li><li><code>-e &quot;MINIO_ROOT_USER=xxx&quot;</code>: 设置 MinIO 的管理员用户名为 “xxx”。这是用于 MinIO Web 控制台和 API 的初始管理员用户名。</li><li><code>-e &quot;MINIO_ROOT_PASSWORD=xxx&quot;</code>: 设置 MinIO 的管理员密码为 “xxx”。这是用于 MinIO Web 控制台和 API 的初始管理员密码。</li><li><code>minio/minio:RELEASE.2023-09-30T07-02-29Z</code>: 这是 MinIO 的 Docker 镜像版本。</li><li><code>server /data --console-address &quot;:9090&quot;</code>: 启动 MinIO 服务器，并将数据存储在容器内的<code>/data</code>目录。</li><li><code>--console-address &quot;:9090&quot;</code>表示 MinIO 的Web 控制台将在容器的 9090 端口上运行。</li></ul><p>执行该命令后，再执行 <code>docker ps</code> 命令，可查看正在运行的容器，若如下图所示，容器列表中出现了 <code>minio</code> ，则表示 <code>Minio</code> 后台运行成功了：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122164239344.png" alt="Loading" title="Minio"></p><ol start="4"><li><p>访问Minio控制台<br>浏览器访问地址 <a href="http://localhost:9090/">http://localhost:9090</a> ，可访问 MinIO 的 Web 控制台：<br>输入运行容器时，指定的用户名&#x2F;密码：xxx&#x2F;xxx , 进入到 Minio 的管理后台:<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122165043436.png" alt="Loading" title="后台页面"></p></li><li><p>新建一个Bucket桶<br>进入后台后，点击 Create a Bucket 创建一个 Bucket 桶，用于存储图片。<br>输入 Bucket Name, 我们将其命名为 xxx， 然后点击 Create Bucket 按钮，创建成功后，在 Buckets 列表中就可以看到刚刚新建的桶了：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122165043436.png" alt="Loading" title="创建Bucket"></p></li><li><p>设置 Bucket 为公共读<br>因为我们上传的图片需要被公网访问到，所以，还需要设置 Bucket 为公共读，默认为 Private 私有。点击想要设置的桶，然后编辑 Access Policy,将 Access Policy 选项选择为 Public 公共读，点击 Set 设置按钮,设置成功后，就可以看到 Access Policy 一栏变更为 Public 了，如下图所示:<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122165205868.png" alt="Loading"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Minio</tag>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos使用</title>
    <link href="/2025/01/22/Nacos%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/01/22/Nacos%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Nacos简介"><a href="#Nacos简介" class="headerlink" title="Nacos简介"></a>Nacos简介</h1><p>Nacos &#x2F;nɑ:kəʊs&#x2F; 是 Dynamic Naming and Configuration Service 的首字母简称，它是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p><p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p><p>Nacos主要特性：</p><ul><li><p>服务发现和服务健康检测。</p></li><li><p>动态配置服务。</p></li><li><p>动态DNS服务。</p></li><li><p>服务及其元数据管理。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122151352461.jpg" alt="Loading" title="Nacos地图"></p><h1 id="安装Nacos"><a href="#安装Nacos" class="headerlink" title="安装Nacos"></a>安装Nacos</h1><ol><li>安装包安装</li></ol><ul><li><p>Nacos 依赖 Java 环境来运行，所以，需要确保你的机器上已经安装好了 JDK 1.8+ 版本。</p></li><li><p>浏览器访问地址：<a href="https://nacos.io/download/release-history/">https://nacos.io/download/release-history/</a> ，找到 2.2.3 版本，点击并下载对应版本的安装包：</p></li><li><p>下载完成后，解压到某个文件夹下，然后进入 &#x2F;bin 目录下，打开终端：</p></li><li><p>在终端中，运行如下启动命令 ( standalone 代表着单机模式运行，非集群模式) :</p></li></ul><p><code>./startup.cmd -m standalone</code></p><ul><li>浏览器访问地址：<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> ，即可进入到 Nacos 的控制后台。</li></ul><ol start="2"><li>Docker安装Nacos</li></ol><ul><li><p>在拉取 Nacos 镜像之前，在 E:\docker 文件夹下，创建一个 &#x2F;nacos 文件夹，等会运行容器时，用于将 Nacos 容器中的配置文件、持久化文件挂载出来，防止容器重启时数据丢失的问题。</p></li><li><p>那么，下载 2.2.3 版本的 Nacos 镜像，运行命令如下：</p></li></ul><p><code>docker pull nacos/nacos-server:v2.2.3</code></p><ul><li>执行完成后，执行如下命令，查看本地已下载的镜像列表，确认一下镜像是否下载成功了：</li></ul><p><code>docker images</code></p><ul><li>镜像下载成功后，运行如下命令，运行一个 Nacos 容器：</li></ul><p><code>docker run -d --name nacos --env MODE=standalone -p 8848:8848 -p 9848:9848 nacos/nacos-server:v2.2.3</code></p><ul><li><p>命令执行完毕后，通过 docker ps 命令查看一下正在运行中的 Docker 容器，确认一下容器是否正常跑起来了。</p></li><li><p>浏览器访问地址：<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> ，即可进入到 Nacos 的控制后台。</p></li><li><p>Nacos 容器跑起来后，我们将容器中的配置文件，以及数据文件复制到宿主机中。</p></li></ul><p><code>docker cp nacos:/home/nacos/conf E:\docker\nacos</code></p><p><code>docker cp nacos:/home/nacos/data E:\docker\nacos</code></p><ul><li>最后，执行如下命令，强制删除正在运行中的 Nacos 容器：</li></ul><p><code>docker rm -f nacos</code></p><ul><li>重新跑一个正式的 Nacos 容器，运行命令如下：</li></ul><p><code>docker run -d --name nacos --privileged -e MODE=standalone -e JVM_XMX=300m -e JVM_XMS=300m -p 8848:8848 -p 9848:9848  -v E:\docker\nacos\conf:/home/nacos/conf -v E:\docker\nacos\data:/home/nacos/data -v E:\docker\nacos\logs:/home/nacos/logs nacos/nacos-server:v2.2.3</code></p><h2 id="整合-Nacos-配置中心：实现动态配置刷新"><a href="#整合-Nacos-配置中心：实现动态配置刷新" class="headerlink" title="整合 Nacos 配置中心：实现动态配置刷新"></a>整合 Nacos 配置中心：实现动态配置刷新</h2><p>什么是配置中心？</p><p>在微服务架构下，配置中心是一个专门用来集中管理和分发配置的服务。它通过提供统一的接口，帮助开发人员将所有微服务的配置项集中存储、管理和分发，确保微服务在不同环境下（如开发、测试、生产环境）能够方便地获取到对应的配置。</p><p>为什么需要配置中心？</p><ol><li><p>集中管理，简化运维： 在传统的单体应用中，配置项通常存储在本地文件中，管理和维护相对简单。但在微服务架构下，配置项分散在多个服务中，如果每个服务都单独管理自己的配置项，会导致管理复杂性增加。配置中心通过集中管理配置项，极大简化了运维工作。</p></li><li><p>环境隔离，配置灵活： 不同的环境（开发、测试、生产等）通常需要不同的配置项。配置中心支持按环境隔离配置项，使得相同的微服务在不同环境中可以方便地获取对应的配置，而无需手动修改配置文件。</p></li><li><p>动态更新，实时生效： 在业务需求变化较快的场景中，配置项的频繁修改是常态。配置中心支持配置项的动态更新和实时生效，减少了服务重启的次数，提高了系统的可用性和灵活性。</p></li><li><p>安全管理： 某些敏感配置项（如数据库密码、API 密钥等）不适合写在代码中或本地文件中。配置中心提供了安全的存储和访问机制，确保敏感信息的安全性。</p></li><li><p>统一监控，提升稳定性： 配置中心可以对所有配置项进行统一监控和管理，方便运维人员及时发现和处理配置问题，提升系统的稳定性和可靠性。</p></li></ol><p>使用Nacos配置中心</p><p>进入 Nacos 管理后台，创建配置</p><p>浏览器访问： <a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> ， 进入到 Nacos 控制台，点击创建配置按钮。</p><p>填写相关配置项：</p><p>①：Data Id : 配置的唯一标识，这里我们填写；</p><p>②：Group: 所属组，这里默认组即可；</p><p>③：配置格式：项目中使用的 YAML 格式配置， 这里也选择 YAML;</p><p>④：配置内容，将限流阈值配置复制进去；</p><p>⑤：点击发布按钮；</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122154510679.png" alt="Loading" title="创建配置"></p><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Nacos 配置中心 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>nacos-config-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.3.0-RC<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：版本 0.2.x.RELEASE 对应的是 Spring Boot 2.x 版本，版本 0.1.x.RELEASE 对应的是 Spring Boot 1.x 版本。我们是 Spring Boot 3.x, 故使用最新的 0.3.x 版本。</p><h2 id="项目配置Nacos"><a href="#项目配置Nacos" class="headerlink" title="项目配置Nacos"></a>项目配置Nacos</h2><p>依赖添加完毕后，编辑 applicaiton.yml 文件，准备添加 Nacos 相关配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">nacos:</span> <br>  <span class="hljs-attr">config:</span> <span class="hljs-comment"># Nacos 配置中心</span><br>    <span class="hljs-attr">access-key:</span> <span class="hljs-comment"># 身份验证</span><br>    <span class="hljs-attr">secret-key:</span> <span class="hljs-comment"># 身份验证</span><br>    <span class="hljs-attr">data-id:</span> <span class="hljs-string">xxx</span> <span class="hljs-comment"># 指定要加载的配置数据的 Data Id</span><br>    <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span> <span class="hljs-comment"># 指定配置数据所属的组</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 指定配置数据的格式</span><br>    <span class="hljs-attr">server-addr:</span> <span class="hljs-string">http://127.0.0.1:8848/</span> <span class="hljs-comment"># 指定 Nacos 配置中心的服务器地址</span><br>    <span class="hljs-attr">auto-refresh:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否自动刷新配置</span><br>    <span class="hljs-attr">remote-first:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否优先使用远程配置</span><br>    <span class="hljs-attr">bootstrap:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 启动时，预热配置</span><br></code></pre></td></tr></table></figure><h2 id="Nacos配置中心：动态加载Bean"><a href="#Nacos配置中心：动态加载Bean" class="headerlink" title="Nacos配置中心：动态加载Bean"></a>Nacos配置中心：动态加载Bean</h2><p>当系统发送异常时，需要给开发发送告警信息，提示开发速度修复系统问题。告警的形式可以是发送短信，也可以是发送邮件。至于具体使用哪种方式， 支持通过修改 Nacos 配置中心中的配置项来动态控制。</p><p>自定义配置</p><p>编辑 application.yml 文件，自定义一个告警类型的配置：<br>sms : 表示短信告警；<br>mail : 表示邮件告警；</p><p>添加Nacos配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">xxx</span> <span class="hljs-comment"># 应用名称</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 默认激活 dev 本地开发环境</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">http://127.0.0.1:8848</span> <span class="hljs-comment"># 指定 Nacos 配置中心的服务器地址</span><br>        <span class="hljs-attr">prefix:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span> <span class="hljs-comment"># 配置 Data Id 前缀，这里使用应用名称作为前缀</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span> <span class="hljs-comment"># 所属组</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">public</span> <span class="hljs-comment"># 命名空间</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 配置文件格式</span><br>        <span class="hljs-attr">refresh-enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否开启动态刷新</span><br></code></pre></td></tr></table></figure><p>使用<code>@RefreshScope</code> 注解<br>这个注解是干嘛的？</p><p>@RefreshScope 注解是 Spring Cloud 提供的一个注解，用于实现配置动态刷新功能。当配置中心的配置发生变化时，标注了 @RefreshScope 的 Bean 会重新加载最新的配置，而无需重启应用。</p><p>在 Nacos 配置中心的场景下，@RefreshScope 的主要功能包括：</p><ul><li><p>动态刷新配置：当 Nacos 配置中心的配置发生变化时，应用中的配置会自动更新，避免了手动重启应用的繁琐过程。</p></li><li><p>重新加载 Bean：标注了 @RefreshScope 的 Bean 会在配置变化后重新加载，确保 Bean 使用最新的配置。</p></li><li><p>与 Spring Cloud 集成：@RefreshScope 与 Spring Cloud 的配置管理机制紧密集成，能够无缝地处理配置更新事件。</p></li></ul><h2 id="Nacos命名空间应用：项目隔离"><a href="#Nacos命名空间应用：项目隔离" class="headerlink" title="Nacos命名空间应用：项目隔离"></a>Nacos命名空间应用：项目隔离</h2><p>命名空间（Namespace）是 Nacos 提供的一种逻辑隔离手段，用于对配置和服务进行分组和隔离。在 Nacos 中，命名空间通常被用于做业务隔离。</p><p>什么是业务隔离？<br>不同业务线的配置和服务可以放在不同的命名空间中，方便管理和维护。</p><p>创建命名空间</p><p>进入到 Nacos 管理后台：<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> ：点击命名空间菜单，点击新建命名空间按钮：</p><p>填写命名空间相关配置项，如下图所示：</p><p>①：命名空间 ID： 可不填，不填的话，会自动生成一长串的唯一 ID , 这里为了方便识别，手动填写；</p><p>②：命名空间名称：也可以写中文，这里填项目的拼音；</p><p>③：描述：命名空间描述性文字；</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122154611418.png" alt="Loading" title="创建命名空间"></p><h2 id="克隆配置"><a href="#克隆配置" class="headerlink" title="克隆配置"></a>克隆配置</h2><p>创建完成后，进入到配置管理 | 配置列表，在上方会发现除了 public 外，多出了一个咱们刚刚创建的 xxx 命名空间，选择该命名空间，会发现该命名空间下，还没有任何配置：<br>将 public 命名空间下的所有配置勾选，点击克隆，选择目标空间 | 开始克隆 ， 即可将 public 空间下的配置，一键复制到 xxx 命名空间下：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122154705649.png" alt="Loading" title="克隆配置"></p><h2 id="服务注册：将认证服务注册到-Nacos-上"><a href="#服务注册：将认证服务注册到-Nacos-上" class="headerlink" title="服务注册：将认证服务注册到 Nacos 上"></a>服务注册：将认证服务注册到 Nacos 上</h2><p>在微服务架构中，服务注册是一种机制，用于将服务实例的信息（如地址、端口、健康状态等）注册到服务注册中心。服务实例启动时，会向注册中心登记自己的信息，停止时则注销。</p><p>它的作用如下：</p><ul><li><p>提供服务元数据：注册中心保存了所有服务实例的元数据，供其他服务或负载均衡器查询。</p></li><li><p>健康检查：注册中心通常会定期检查注册的服务实例的健康状况，以确保它们可用并将不可用的实例从注册列表中移除。</p></li></ul><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 服务注册发现 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-string">//</span> <span class="hljs-string">省略</span> <span class="hljs-string">...</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br> <span class="hljs-string">//</span> <span class="hljs-string">省略...</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 启用服务发现</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span> <span class="hljs-comment"># 所属组</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">xxx#</span> <span class="hljs-string">命名空间</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># 指定 Nacos 配置中心的服务器地址</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RBAC权限设计模型</title>
    <link href="/2025/01/22/RBAC%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/01/22/RBAC%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-RBAC-模型？"><a href="#什么是-RBAC-模型？" class="headerlink" title="什么是 RBAC 模型？"></a>什么是 RBAC 模型？</h1><p>RBAC（Role-Based Access Control）是一种基于角色的访问控制。它通过角色来管理用户的权限。RBAC 的核心思想是将用户与角色进行关联，并将权限分配给角色，而不是直接分配给用户。这样，通过改变用户的角色，就可以灵活地控制用户的权限。<br>RBAC 的主要组成部分包括：<br>    - 用户（User）：系统的使用者。</p><pre><code class="hljs">- 角色（Role）：权限的集合，一个角色可以包含多个权限。- 权限（Permission）：对系统资源的访问操作，如读取、写入、删除等。</code></pre><h2 id="模型扩展"><a href="#模型扩展" class="headerlink" title="模型扩展"></a>模型扩展</h2><h3 id="RBAC0"><a href="#RBAC0" class="headerlink" title="RBAC0"></a>RBAC0</h3><p>即上面所讲的 RBAC 模型，基于用户-角色-权限的模型。</p><h3 id="RBAC1：基于角色的层次模型（Role-Hierarchies）"><a href="#RBAC1：基于角色的层次模型（Role-Hierarchies）" class="headerlink" title="RBAC1：基于角色的层次模型（Role Hierarchies）"></a>RBAC1：基于角色的层次模型（Role Hierarchies）</h3><p>RBAC 1 在 RBAC 0 的基础上增加了角色层次结构（Role Hierarchies）。角色层次结构允许角色之间存在继承关系，一个角色可以继承另一个角色的权限。</p><p>主要特点：</p><ul><li><p>角色继承：一个角色可以继承另一个角色的所有权限。比如，角色B继承角色 A 的权限，那么角色 B 不仅拥有自己定义的权限，还拥有角色 A 的所有权限。</p></li><li><p>权限传递：继承关系是传递的，如果角色 C 继承角色 B，而角色 B 继承角色 A，那么角色 C 将拥有角色 A 和角色 B 的所有权限。</p></li></ul><p>优点：</p><ul><li><p>简化权限管理：通过角色继承，可以减少重复定义权限的工作。</p></li><li><p>提高灵活性：可以方便地对角色进行分层管理，满足不同层次用户的权限需求。</p></li></ul><h3 id="RBAC2：基于约束的-RBAC-模型（Constraints）"><a href="#RBAC2：基于约束的-RBAC-模型（Constraints）" class="headerlink" title="RBAC2：基于约束的 RBAC 模型（Constraints）"></a>RBAC2：基于约束的 RBAC 模型（Constraints）</h3><p>RBAC 2 同样建立在 RBAC 0 基础之上，但是增加了约束（Constraints）。约束是用于加强访问控制策略的规则或条件，可以限制用户、角色和权限的关联方式。</p><p>主要特点：</p><ul><li><p>互斥角色：某些角色不能同时赋予同一个用户。例如，审计员和财务员角色不能同时赋予同一个用户，以避免暗黑交易。</p></li><li><p>先决条件：用户要获得某个角色，必须先拥有另一个角色。例如，公司研发人员要成为高级程序员，必须先成为中级程序员。</p></li><li><p>基数约束：限制某个角色可以被赋予的用户数量。例如，某个项目的经理角色只能赋予一个用户，以确保项目的唯一责任人。</p></li></ul><p>优点：</p><ul><li><p>加强安全性：通过约束规则，可以避免权限滥用和利益冲突。</p></li><li><p>精细化管理：可以更精细地控制用户的角色分配和权限管理。</p></li></ul><h3 id="RBAC3-统一模型（Consolidated-Model）"><a href="#RBAC3-统一模型（Consolidated-Model）" class="headerlink" title="RBAC3: 统一模型（Consolidated Model）"></a>RBAC3: 统一模型（Consolidated Model）</h3><p>RBAC 3 是最全面的 RBAC 模型，它结合了 RBAC1 的角色层次结构和 RBAC2 的约束，形成一个统一的模型，提供了最大程度的灵活性和安全性。</p><p>主要特点：</p><ul><li><p>包含RBAC 1的所有功能：角色层次结构，角色继承和权限传递。</p></li><li><p>包含RBAC 2的所有功能：互斥角色、先决条件角色和角色卡数限制等约束规则。</p></li><li><p>综合管理：可以同时利用角色继承和约束规则，提供最全面的权限管理解决方案。</p></li></ul><p>优点：</p><ul><li>高灵活性：可以满足各种复杂的权限管理需求。</li></ul><p>-高安全性：通过约束规则，进一步加强权限管理的安全性。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>设计思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SaToken使用</title>
    <link href="/2025/01/22/SaToken%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/01/22/SaToken%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ol><li>什么是SaToken？</li></ol><p>Sa-Token是一个轻量级Java权限认证框架，官网地址：<a href="https://sa-token.cc/">https://sa-token.cc/</a> ，主要解决：登录认证、权限认证、单点登录、OAuth2.0、分布式Session会话、微服务网关鉴权 等一系列权限相关问题。</p><ol start="2"><li>SaToken功能</li></ol><p>Sa-Token目前主要五大功能模块：登录认证、权限认证、单点登录、OAuth2.0、微服务鉴权。<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122132955471.png" alt="Loading" title="SaToken结构图"></p><ol start="3"><li>使用配置</li></ol><p>在<code>pom.xml</code>文件引入对应依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Sa-Token 权限认证，在线文档：https://sa-token.cc --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.dev33<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sa-token-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.39.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在application.yml中填写相关配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">############## Sa-Token 配置 (文档: https://sa-token.cc) ##############<br>sa-token:<br>  # token 名称（同时也是 cookie 名称）<br>  token-name: satoken<br>  # token 有效期（单位：秒） 默认30天，-1 代表永久有效<br>  timeout: 2592000<br>  # token 最低活跃频率（单位：秒），如果 token 超过此时间没有访问系统就会被冻结，默认-1 代表不限制，永不冻结<br>  active-timeout: -1<br>  # 是否允许同一账号多地同时登录 （为 true 时允许一起登录, 为 false 时新登录挤掉旧登录）<br>  is-concurrent: true<br>  # 在多人登录同一账号时，是否共用一个 token （为 true 时所有登录共用一个 token, 为 false 时每次登录新建一个 token）<br>  is-share: true<br>  # token 风格（默认可取值：uuid、simple-uuid、random-32、random-64、random-128、tik）<br>  token-style: uuid<br>  # 是否输出操作日志<br>  is-log: true<br></code></pre></td></tr></table></figure><ol start="4"><li>自定义 Token 生成风格与请求格式</li></ol><p>在 SaToken 中，Token 风格可以通过<code> sa-token.token-style</code> 配置项来定制，默认的生成策略是 uuid 风格，值类似于 <code>623368f0-ae5e-4475-a53f-93e4225f16ae</code></p><p>SaToken 内置支持的风格有多种，大致如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">/</span> <span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=uuid</span>    <span class="hljs-string">——</span> <span class="hljs-string">uuid风格</span> <span class="hljs-string">(默认风格)</span><br><span class="hljs-string">&quot;623368f0-ae5e-4475-a53f-93e4225f16ae&quot;</span><br><br><span class="hljs-string">//</span> <span class="hljs-number">2</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=simple-uuid</span>    <span class="hljs-string">——</span> <span class="hljs-string">同上，uuid风格,</span> <span class="hljs-string">只不过去掉了中划线</span><br><span class="hljs-string">&quot;6fd4221395024b5f87edd34bc3258ee8&quot;</span><br><br><span class="hljs-string">//</span> <span class="hljs-number">3</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=random-32</span>    <span class="hljs-string">——</span> <span class="hljs-string">随机32位字符串</span><br><span class="hljs-string">&quot;qEjyPsEA1Bkc9dr8YP6okFr5umCZNR6W&quot;</span><br><br><span class="hljs-string">//</span> <span class="hljs-number">4</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=random-64</span>    <span class="hljs-string">——</span> <span class="hljs-string">随机64位字符串</span><br><span class="hljs-string">&quot;v4ueNLEpPwMtmOPMBtOOeIQsvP8z9gkMgIVibTUVjkrNrlfra5CGwQkViDjO8jcc&quot;</span><br><br><span class="hljs-string">//</span> <span class="hljs-number">5</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=random-128</span>    <span class="hljs-string">——</span> <span class="hljs-string">随机128位字符串</span><br><span class="hljs-string">&quot;nojYPmcEtrFEaN0Otpssa8I8jpk8FO53UcMZkCP9qyoHaDbKS6dxoRPky9c6QlftQ0pdzxRGXsKZmUSrPeZBOD6kJFfmfgiRyUmYWcj4WU4SSP2ilakWN1HYnIuX0Olj&quot;</span><br><br><span class="hljs-string">//</span> <span class="hljs-number">6</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=tik</span>    <span class="hljs-string">——</span> <span class="hljs-string">tik风格</span><br><span class="hljs-string">&quot;gr_SwoIN0MC1ewxHX_vfCW3BothWDZMMtx__&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>自定义Token请求风格</li></ol><p>比较通用、规范的 Token 请求格式：<br><code>Authorization = Bearer + 空格 + 令牌值</code></p><p>修改SaToken配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sa-token:</span><br>  <span class="hljs-comment"># token 名称（同时也是 cookie 名称）</span><br>  <span class="hljs-attr">token-name:</span> <span class="hljs-string">Authorization</span><br>  <span class="hljs-comment"># token前缀</span><br>  <span class="hljs-attr">token-prefix:</span> <span class="hljs-string">Bearer</span><br></code></pre></td></tr></table></figure><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>在我们已经将 SaToken 权限认证框架整合进了项目。但是有个问题，当调用 <code>TestController</code> 中的登录接口 <code>/user/doLogin?username=zhang&amp;password=123456</code> ，登录成功后再重启项目，调用 <code>/user/isLogin</code> 接口，验证一下用户是否登录的时候，会发现登录已经失效了。</p><h2 id="登录失效的原因？"><a href="#登录失效的原因？" class="headerlink" title="登录失效的原因？"></a>登录失效的原因？</h2><p>Sa-Token 默认将数据保存在内存中，此模式读写速度最快，且避免了序列化与反序列化带来的性能消耗，但是此模式也有一些缺点，比如：</p><ul><li><p>重启后数据会丢失。</p></li><li><p>无法在分布式环境中共享数据。</p></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为此，Sa-Token 提供了扩展接口，你可以轻松将会话数据存储在一些专业的缓存中间件上（比如 Redis）， 做到重启数据不丢失，而且保证分布式环境下多节点的会话一致性。</p><p>项目<code>pom.xml</code>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-comment">&lt;!-- Sa-Token 整合 Redis （使用 jackson 序列化方式） --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.dev33<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sa-token-redis-jackson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;sa-token.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Sa-Token 整合 Redis （使用 jackson 序列化方式） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.dev33<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sa-token-redis-jackson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Redis 连接池 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github搭建个人图床</title>
    <link href="/2025/01/21/Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/"/>
    <url>/2025/01/21/Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="一、创建新的个人仓库"><a href="#一、创建新的个人仓库" class="headerlink" title="一、创建新的个人仓库"></a>一、创建新的个人仓库</h1><p>在Github中创建新的仓库，确保仓库为public，其他保持默认即可</p><h1 id="二、上传图片"><a href="#二、上传图片" class="headerlink" title="二、上传图片"></a>二、上传图片</h1><p>通过传统方式向Github上传图片比较麻烦，此处使用PicGO来进行图片上传。</p><h2 id="PicGO图片上传配置"><a href="#PicGO图片上传配置" class="headerlink" title="PicGO图片上传配置"></a>PicGO图片上传配置</h2><ol><li><p>在Github创建token，打开Settings -&gt; Developer settings -&gt; Personal access tokens，选择classic方式创建，最后点击 generate new token；<br> 填写相关信息时，勾选repo。<br> 注：token生成只会生成一次，需要自行记录备用。</p></li><li><p>配置PicGO。打开 图床设置 -&gt; Github 图床</p></li></ol><p><img src="https://github.com/Bloomivy/pic/blob/main/image-1.png?raw=true" alt="Loading" title="GitHub设置"></p><p>可能存在的问题：上传图片时报错：You must be logged in to use issue<br>解决方式：注册sm.ms账号，创建token，将token填入PicGO配置即可正常上传。</p><p><img src="https://github.com/Bloomivy/pic/blob/main/image-2.png?raw=true" alt="Loading" title="sm"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>差分数组</title>
    <link href="/2025/01/21/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    <url>/2025/01/21/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。<br>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 差分数组工具类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Difference</span> &#123;<br>    <span class="hljs-comment">// 差分数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] diff;<br>    <br>    <span class="hljs-comment">// 输入一个初始数组，区间操作将在这个数组上进行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Difference</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">assert</span> nums.length &gt; <span class="hljs-number">0</span>;<br>        diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-comment">// 根据初始数组构造差分数组</span><br>        diff[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            diff[i] = nums[i] - nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 给闭区间 [i, j] 增加 val（可以是负数）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> val)</span> &#123;<br>        diff[i] += val;<br>        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; diff.length) &#123;<br>            diff[j + <span class="hljs-number">1</span>] -= val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回结果数组</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] result() &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[diff.length];<br>        <span class="hljs-comment">// 根据差分数组构造结果数组</span><br>        res[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; diff.length; i++) &#123;<br>            res[i] = res[i - <span class="hljs-number">1</span>] + diff[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>差分数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和数组</title>
    <link href="/2025/01/21/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <url>/2025/01/21/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一维数组前缀和"><a href="#一维数组前缀和" class="headerlink" title="一维数组前缀和"></a>一维数组前缀和</h1><p>LeetCode 303.区域和检索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>    <span class="hljs-comment">// 前缀和数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] preSum;<br><br>    <span class="hljs-comment">// 输入一个数组，构造前缀和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// preSum[0] = 0，便于计算累加和</span><br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 计算 nums 的累加和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; preSum.length; i++) &#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 查询闭区间 [left, right] 的累加和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> preSum[right + <span class="hljs-number">1</span>] - preSum[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="矩阵前缀和"><a href="#矩阵前缀和" class="headerlink" title="矩阵前缀和"></a>矩阵前缀和</h1><p>LeetCode 304.二位区域和检索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br>    <span class="hljs-comment">// preSum[i][j] 记录矩阵 [0, 0, i-1, j-1] 的元素和</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] preSum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 构造前缀和矩阵</span><br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-comment">// 计算每个矩阵 [0, 0, i, j] 的元素和</span><br>                preSum[i][j] = preSum[i-<span class="hljs-number">1</span>][j] + preSum[i][j-<span class="hljs-number">1</span>] + matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - preSum[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算子矩阵 [x1, y1, x2, y2] 的元素和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span> &#123;<br>        <span class="hljs-comment">// 目标矩阵之和由四个相邻矩阵运算获得</span><br>        <span class="hljs-keyword">return</span> preSum[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] - preSum[x1][y2+<span class="hljs-number">1</span>] - preSum[x2+<span class="hljs-number">1</span>][y1] + preSum[x1][y1];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结-前缀和核心代码"><a href="#总结-前缀和核心代码" class="headerlink" title="总结 前缀和核心代码"></a>总结 前缀和核心代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrefixSum</span> &#123;<br>    <span class="hljs-comment">// 前缀和数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] preSum;<br><br>    <span class="hljs-comment">// 输入一个数组，构造前缀和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrefixSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// preSum[0] = 0，便于计算累加和</span><br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 计算 nums 的累加和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; preSum.length; i++) &#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 查询闭区间 [left, right] 的累加和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> preSum[right + <span class="hljs-number">1</span>] - preSum[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git相关</title>
    <link href="/2025/01/20/Git%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/01/20/Git%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h1><h1 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h1><h2 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h2><h3 id="本地创建"><a href="#本地创建" class="headerlink" title="本地创建"></a>本地创建</h3><p>在需要创建仓库的地方执行指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> demo<br><span class="hljs-built_in">cd</span> demo<br></code></pre></td></tr></table></figure><p>初始化Git仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><p>执行指令 ls -a，控制台显示.git目录。<br>进入.git目录下，执行ls -altr查看到以下文件。<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122111103994.png" alt="Loading" title="命令回显"></p><h3 id="远程获取"><a href="#远程获取" class="headerlink" title="远程获取"></a>远程获取</h3><p>使用git clone 命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/git/git.git<br></code></pre></td></tr></table></figure><h2 id="Git工作区域和文件状态"><a href="#Git工作区域和文件状态" class="headerlink" title="Git工作区域和文件状态"></a>Git工作区域和文件状态</h2><p>Git主要存在三种区域。<br>在.git目录层即为工作区，通常在这一层编写代码。<br>代码编写完成后使用 git add 命令提交，提交到暂存区。<br>在暂存区的代码使用 git commit 提交到本地仓库。</p><p>Git中文件的几种状态</p><ul><li>untrack </li><li>unmodified</li><li>modified</li><li>committed<br><img src="https://github.com/Bloomivy/pic/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_21-1-2025_9212_www.bilibili.com.jpeg?raw=true" alt="Loading" title="Git文件四种状态"></li></ul><h2 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h2><p> git status 查看当前状态。<br> git add 将文件添加到暂存区，等待后续操作。<br> git commit 提交暂存区中的文件，并不提交工作区中的文件。可以使用 -m 指定提交的信息。如果不使用-m参数，git会自动进入一个交互式界面，默认使用nano编辑。<br> git log 命令查看提交记录。可以使用 – online 查看简洁的提交信息，只显示作者和提交时间。</p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>git reset </p><ul><li>git reset –soft：回退到上一个版本时，工作区和暂存区都不清空。</li><li>git reset –hard：回退到上一个版本时，工作区和暂存区会清空。</li><li>git reset –mixed：回退到上一个版本时，清空暂存区，不清空工作区。</li><li>git reflog：查看所有操作及对应的版本号，便于进行回退。</li></ul><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>git diff，默认比较工作区和暂存区的内容。<br>git diff commit，比较工作区和指定提交版本的区别。<br>git diff cached commit，比较暂存区与指定提交版本区别。<br>git diff commit1 commit2，比较两个提交的版本区别。</p><h2 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h2><p>应该忽略哪些文件：</p><ul><li>系统或软件自动生成的代码。</li><li>编译产生的中间文件和结果文件。</li><li>运行时生成的日志文件、缓存文件和临时文件。</li><li>涉及敏感信息的文件。</li></ul><h2 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h2><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>git branch xx 创建新的分支。<br>git checkout xx 切换到不同分支上。也可以用于恢复文件，存在歧义，默认切换分支。<br>git switch xx 切换不同分支。<br>git merge xx 合并分支到当前位置。</p><p>切换分支时，工作区也会随之变化。</p><h2 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h2><p>两个分支如果存在对同一文件进行不同修改，此时会发生冲突。<br>可以使用 git diff 命令查看冲突的具体内容。<br>手动修改文件再提交即可。</p><h2 id="回退和rebase"><a href="#回退和rebase" class="headerlink" title="回退和rebase"></a>回退和rebase</h2><ul><li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li><li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分搜索</title>
    <link href="/2025/01/20/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    <url>/2025/01/20/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找框架"><a href="#二分查找框架" class="headerlink" title="二分查找框架"></a>二分查找框架</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = ...;<br><br>    <span class="hljs-keyword">while</span>(...) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            ...<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = ...<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = ...<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ...;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。计算 mid 时需要防止溢出，代码中 left + (right - left) &#x2F; 2 就和 (left + right) &#x2F; 2 的结果相同，但是有效防止了 left 和 right 太大，直接相加导致溢出的情况。</p><h1 id="寻找一个数"><a href="#寻找一个数" class="headerlink" title="寻找一个数"></a>寻找一个数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 标准的二分搜索框架，搜索目标元素的索引，若不存在则返回 -1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 注意</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;   <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                <span class="hljs-comment">// 注意</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                <span class="hljs-comment">// 注意</span><br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个算法存在局限性。<br>比如说给你有序数组 nums &#x3D; [1,2,2,2,3]，target 为 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。</p><p>为什么while中left&lt;&#x3D;right，而不是&lt;？<br>因为right初始化为nums.length-1而不是nums.length。</p><h1 id="寻找左侧边界的二分搜索"><a href="#寻找左侧边界的二分搜索" class="headerlink" title="寻找左侧边界的二分搜索"></a>寻找左侧边界的二分搜索</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">left_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 注意</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>    <br>    <span class="hljs-comment">// 注意</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            <span class="hljs-comment">// 注意</span><br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用双闭区间的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">left_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 搜索区间为 [left, right]</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            <span class="hljs-comment">// 搜索区间变为 [mid+1, right]</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            <span class="hljs-comment">// 搜索区间变为 [left, mid-1]</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 收缩右侧边界</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 判断 target 是否存在于 nums 中</span><br>    <span class="hljs-comment">// 如果越界，target 肯定不存在，返回 -1</span><br>    <span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">0</span> || left &gt;= nums.length) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 判断一下 nums[left] 是不是 target</span><br>    <span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="寻找右侧边界的二分查找"><a href="#寻找右侧边界的二分查找" class="headerlink" title="寻找右侧边界的二分查找"></a>寻找右侧边界的二分查找</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">right_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 注意</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 注意</span><br>    <span class="hljs-keyword">return</span> left - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用双闭区间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">right_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 这里改成收缩左侧边界即可</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后改成返回 right</span><br>    <span class="hljs-keyword">if</span> (right &lt; <span class="hljs-number">0</span> || right &gt;= nums.length) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[right] == target ? right : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="逻辑统一"><a href="#逻辑统一" class="headerlink" title="逻辑统一"></a>逻辑统一</h1><ul><li>基本的二分查找</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">因为我们初始化 right = nums.length - 1<br>所以决定了我们的「搜索区间」是 [left, right]<br>所以决定了 <span class="hljs-keyword">while</span> (left &lt;= right)<br>同时也决定了 left = mid+1 和 right = mid-1<br><br>因为我们只需找到一个 target 的索引即可<br>所以当 nums[mid] == target 时可以立即返回<br></code></pre></td></tr></table></figure><ul><li>查找左侧边界的二分查找</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">因为我们初始化 right = nums.length<br>所以决定了我们的「搜索区间」是 [left, right)<br>所以决定了 <span class="hljs-keyword">while</span> (left &lt; right)<br>同时也决定了 left = mid + 1 和 right = mid<br><br>因为我们需找到 target 的最左侧索引<br>所以当 nums[mid] == target 时不要立即返回<br>而要收紧右侧边界以锁定左侧边界<br></code></pre></td></tr></table></figure><ul><li>查找右侧边界的二分查找</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">因为我们初始化 right = nums.length<br>所以决定了我们的「搜索区间」是 [left, right)<br>所以决定了 <span class="hljs-keyword">while</span> (left &lt; right)<br>同时也决定了 left = mid + 1 和 right = mid<br><br>因为我们需找到 target 的最右侧索引<br>所以当 nums[mid] == target 时不要立即返回<br>而要收紧左侧边界以锁定右侧边界<br><br>又因为收紧左侧边界时必须 left = mid + 1<br>所以最后无论返回 left 还是 right，必须减一<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2025/01/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2025/01/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口框架"><a href="#滑动窗口框架" class="headerlink" title="滑动窗口框架"></a>滑动窗口框架</h1><p>滑动窗口就是简单维护一个窗口，不断滑动，然后更新答案，代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (right &lt; nums.size()) &#123;<br>    <span class="hljs-comment">// 增大窗口</span><br>    window.addLast(nums[right]);<br>    right++;<br>    <br>    <span class="hljs-keyword">while</span> (window needs shrink) &#123;<br>        <span class="hljs-comment">// 缩小窗口</span><br>        window.removeFirst(nums[left]);<br>        left++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>滑动窗口的伪框架实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 滑动窗口算法伪码框架</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">slidingWindow</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">// 用合适的数据结构记录窗口中的数据，根据具体场景变通</span><br>    <span class="hljs-comment">// 比如说，我想记录窗口中元素出现的次数，就用 map</span><br>    <span class="hljs-comment">// 如果我想记录窗口中的元素和，就可以只用一个 int</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">window</span> <span class="hljs-operator">=</span> ...<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>        <span class="hljs-comment">// c 是将移入窗口的字符</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s[right];<br>        window.add(c)<br>        <span class="hljs-comment">// 增大窗口</span><br>        right++;<br>        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>        ...<br><br>        <span class="hljs-comment">// *** debug 输出的位置 ***</span><br>        <span class="hljs-comment">// 注意在最终的解法代码中不要 print</span><br>        <span class="hljs-comment">// 因为 IO 操作很耗时，可能导致超时</span><br>        printf(<span class="hljs-string">&quot;window: [%d, %d)\n&quot;</span>, left, right);<br>        <span class="hljs-comment">// ***********************</span><br><br>        <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; window needs shrink) &#123;<br>            <span class="hljs-comment">// d 是将移出窗口的字符</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s[left];<br>            window.remove(d)<br>            <span class="hljs-comment">// 缩小窗口</span><br>            left++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于滑动窗口实现的代码，时间复杂度是O(N)。</p><h2 id="LeetCode76-最小覆盖子串"><a href="#LeetCode76-最小覆盖子串" class="headerlink" title="LeetCode76.最小覆盖子串"></a>LeetCode76.最小覆盖子串</h2><p>滑动窗口实现的简单思路：<br>1.在字符串s中使用双指针中的左右指针技巧，初始化left&#x3D;right&#x3D;0，将索引左闭右开区间[left,right)称为一个窗口。<br>2.不断增大right指针扩大窗口，[left,right)，直至窗口中字符串符合要求。<br>3.此时，停止增加right，转而不断增大left缩小窗口[left,right)，直至窗口中字符串不再符合要求。同时，每次增加left，都更新结果。<br>4.重复第二、三步，直至left到达s末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>            need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 记录最小覆盖子串的起始索引及长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, len = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-comment">// c 是将移入窗口的字符</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            <span class="hljs-comment">// 扩大窗口</span><br>            right++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            <span class="hljs-keyword">if</span> (need.containsKey(c)) &#123;<br>                window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (window.get(c).equals(need.get(c)))<br>                    valid++;<br>            &#125;<br><br>            <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span> (valid == need.size()) &#123;<br>                <span class="hljs-comment">// 在这里更新最小覆盖子串</span><br>                <span class="hljs-keyword">if</span> (right - left &lt; len) &#123;<br>                    start = left;<br>                    len = right - left;<br>                &#125;<br>                <span class="hljs-comment">// d 是将移出窗口的字符</span><br>                <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left);<br>                <span class="hljs-comment">// 缩小窗口</span><br>                left++;<br>                <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>                <span class="hljs-keyword">if</span> (need.containsKey(d)) &#123;<br>                    <span class="hljs-keyword">if</span> (window.get(d).equals(need.get(d)))<br>                        valid--;<br>                    window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>                &#125;                    <br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回最小覆盖子串</span><br>        <span class="hljs-keyword">return</span> len == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(start, start + len);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-567-字符串排列"><a href="#LeetCode-567-字符串排列" class="headerlink" title="LeetCode 567.字符串排列"></a>LeetCode 567.字符串排列</h2><p>滑动窗口典型：给你一个 S 和一个 T，请问你 S 中是否存在一个子串，包含 T 中所有字符且不包含其他字符？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 判断 s 中是否存在 t 的排列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkInclusion</span><span class="hljs-params">(String t, String s)</span> &#123;<br>        Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>            need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            right++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            <span class="hljs-keyword">if</span> (need.containsKey(c)) &#123;<br>                window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (window.get(c).intValue() == need.get(c).intValue())<br>                    valid++;<br>            &#125;<br><br>            <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span> (right - left &gt;= t.length()) &#123;<br>                <span class="hljs-comment">// 在这里判断是否找到了合法的子串</span><br>                <span class="hljs-keyword">if</span> (valid == need.size())<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left);<br>                left++;<br>                <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>                <span class="hljs-keyword">if</span> (need.containsKey(d)) &#123;<br>                    <span class="hljs-keyword">if</span> (window.get(d).intValue() == need.get(d).intValue())<br>                        valid--;<br>                    window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 未找到符合条件的子串</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-438-找到字符串中所有字母异位词"><a href="#LeetCode-438-找到字符串中所有字母异位词" class="headerlink" title="LeetCode 438.找到字符串中所有字母异位词"></a>LeetCode 438.找到字符串中所有字母异位词</h2><p>相当于，输入一个串 S，一个串 T，找到 S 中所有 T 的排列，返回它们的起始索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>            need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 记录结果</span><br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            right++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            <span class="hljs-keyword">if</span> (need.containsKey(c)) &#123;<br>                window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (window.get(c).equals(need.get(c))) &#123;<br>                    valid++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span> (right - left &gt;= t.length()) &#123;<br>                <span class="hljs-comment">// 当窗口符合条件时，把起始索引加入 res</span><br>                <span class="hljs-keyword">if</span> (valid == need.size())<br>                    res.add(left);<br>                <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left);<br>                left++;<br>                <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>                <span class="hljs-keyword">if</span> (need.containsKey(d)) &#123;<br>                    <span class="hljs-keyword">if</span> (window.get(d).equals(need.get(d))) &#123;<br>                        valid--;<br>                    &#125;<br>                    window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-3-最长无重复子串"><a href="#LeetCode-3-最长无重复子串" class="headerlink" title="LeetCode 3.最长无重复子串"></a>LeetCode 3.最长无重复子串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 记录结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            right++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span> (window.get(c) &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left);<br>                left++;<br>                <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>                window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">// 在这里更新答案</span><br>            res = Math.max(res, right - left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ安装配置</title>
    <link href="/2025/01/20/RocketMQ%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/01/20/RocketMQ%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ-基本概念"><a href="#RocketMQ-基本概念" class="headerlink" title="RocketMQ 基本概念"></a>RocketMQ 基本概念</h1><p>关于 RocketMQ 相关的基本概念，可翻阅官网：<a href="https://rocketmq.apache.org/zh/docs/4.x/producer/01concept1%E3%80%82">https://rocketmq.apache.org/zh/docs/4.x/producer/01concept1。</a></p><h1 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h1><ol><li><p>下载 RocketMQ 二进制包<br>浏览器访问地址：<a href="https://archive.apache.org/dist/rocketmq/4.9.4/rocketmq-all-4.9.4-bin-release.zip">https://archive.apache.org/dist/rocketmq/4.9.4/rocketmq-all-4.9.4-bin-release.zip</a> ， 下载 RocketMQ 编译完成后的二进制包：</p></li><li><p>下载完成后，进行解压。</p></li></ol><p>3.设置环境变量<br>解压完成后放着，先把相关环境变量设置一下</p><p>添加一个 ROCKETMQ_HOME 变量，值为刚刚我们二进制包解压的具体路径：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123110105133.png" alt="Loading"></p><p>另外，将 JAVA_HOME 系统变量修改为 jdk1.8</p><ol start="4"><li>设置完成后保存，打开一个新的命令窗口，执行 java -version 命令，确认当前使用的版本是 Java 8</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123110201377.png" alt="Loading"></p><ol start="5"><li><p>启动 RocketMQ<br>接着，准备正式启动 RocketMQ。</p></li><li><p>启动 namesrv<br>打开 cmd 命令行工具，进入到 RocketMQ 安装包的 &#x2F;bin 文件夹下，执行如下命令，先将 namesrv 启动起来:</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">start .\mqnamesrv.cmd<br></code></pre></td></tr></table></figure><p>命令执行完成后，会打开一个新的窗口，若提示 The Name Server boot sucess. , 则表示 namesrv 启动成功了。</p><p>注意：窗口打开后，不要关闭，关闭后 namesrv 也会随之关闭。</p><ol start="7"><li>启动 broker<br>接着，执行如下命令，准备启动 broker :</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">.\mqbroker -n 127.0.0.1:9876 autoCreateTopicEnable=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>解释一下启动参数的含义：</p><ul><li><p><code>-n 127.0.0.1:9876</code>：用来指定网络连接参数的标志，绑定到本地 IP 地址 127.0.0.1 并监听端口 9876。</p></li><li><p><code>autoCreateTopicEnable=true</code>：当发送的消息主题（topic）不存在时，则自动创建。</p></li></ul><p>命令执行完成后，若提示 The broker .. boot success. , 则表示运行成功了。同样的，窗口不要关闭。</p><ol start="8"><li>RocketMQ 控制台<br>为了更方便的管控 RocketMQ, 还需要一个控制台。浏览器访问：<a href="https://github.com/apache/rocketmq-dashboard">https://github.com/apache/rocketmq-dashboard</a> ， 如下图所示，下载 zip 源码：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123105805180.png"></p><p>下载完成后解压，并使用 IDEA 打开项目。</p><p>运行 App 启动类，将项目跑起来。启动成功后，浏览器访问 localhost:8080, 即可打开 RocketMQ 的控制台了</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK安装与配置</title>
    <link href="/2025/01/20/JDK%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/01/20/JDK%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="JDK下载-基于window11系统"><a href="#JDK下载-基于window11系统" class="headerlink" title="JDK下载(基于window11系统)"></a>JDK下载(基于window11系统)</h1><p>打开官网链接，根据自己的系统，按需选择下载JDK。会跳转到Oracle登录页，如果有账号直接登录即可，没账号的话点击创建账户，填写信息（邮箱填写正确，其余随便填均可）后点击创建账户，邮箱验证即可，再次登录，登录成功即开始下载。</p><h2 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h2><p>打开下载的对应文件.exe，单击下一步安装。<br>安装时可自选安装路径<br>JDK安装完成后会弹出JRE安装，同样流程完成。</p><h2 id="JDK环境配置"><a href="#JDK环境配置" class="headerlink" title="JDK环境配置"></a>JDK环境配置</h2><p>安装完JDK之后，需要设置JAVA_HOME的环境变量。其中JAVA_HOME需要指向的是JDK的安装目录。<br>JAVA_HOME设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 变量名：</span><br>JAVA_HOME<br><span class="hljs-comment"># 变量值：例如我设置的是如下，所以指向的是此地址，此处根据你自己设置的来。</span><br>D:\codeConfiguration\JAVA\jdk1.8<br></code></pre></td></tr></table></figure><p>更改path环境变量设置<br>PATH是什么？</p><ul><li>PATH 是操作系统用于查找来自命令行或终端窗口的必需可执行文件的系统变量。</li><li>PATH 系统变量可使用控制面板中的“系统”实用程序设置（在 Windows 上），或在 shell 的启动文件内设置（在 Linux 和 Solaris 上）。<br>Window下环境变量设置：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Windows：%JAVA_HOME%\bin<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker相关</title>
    <link href="/2025/01/19/Docker%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/01/19/Docker%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础常见面试题</title>
    <link href="/2025/01/19/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2025/01/19/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>Java中有8种基本数据类型，分别为：</p><p>6 种数字类型：</p><ul><li>4 种整数型：byte，short，int，long</li><li>2 种浮点型：float，double<br>1 种字符类型：char<br>1 种布尔型：boolean</li></ul><table><thead><tr><th>基本类型</th><th>位数</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>8</td><td>1</td><td>0</td></tr><tr><td>short</td><td>16</td><td>2</td><td>0</td></tr><tr><td>int</td><td>32</td><td>4</td><td>0</td></tr><tr><td>long</td><td>64</td><td>8</td><td>0L</td></tr><tr><td>char</td><td>16</td><td>2</td><td>‘u0000’</td></tr><tr><td>float</td><td>32</td><td>4</td><td>0.0f</td></tr><tr><td>double</td><td>64</td><td>8</td><td>0.0d</td></tr><tr><td>boolean</td><td>1</td><td>1</td><td>false</td></tr></tbody></table><p>这八种类型对应的包装类型分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean。</p><p>基本类型和包装类型的区别？</p><ol><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少使用基本数据类型来定义变量，并且，包装类型可以有多个值，而基本类型不可以。</li><li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机的局部变量表中，基本数据类型的成员变量（未做 static 修饰）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型），基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量是包装类型时默认值是 <code>null</code>，而基本数据类型默认值不是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值， 对于包装类型来说，<code>==</code> 比较的是对象的内存地址。所有包装类对象之间的比较，都应该使用 <code>equals()</code> 方法。</li></ol><p><strong>注</strong>：基本数据类型存储位置取决于其作用域及生命周期。</p><p>包装类的缓存机制？<br>Byte、Short、Integer、Long 这 4 种包装类默认创建数值 [-128，127] 的相应类型的缓存数据，<br>Character 创建了数值在 [0，127] 范围的缓存数据，Boolean 直接返回 True 或 False。<br>如果超出对应范围仍会创建新对象，缓存的范围区间大小只是在性能和资源之间权衡。<br>两种浮点类型的包装类Float、Double并未实现缓存机制。</p><p>Integer缓存源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerCache</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> -<span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> high;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// high value may be configured by property</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自动装箱与拆箱原理？<br>什么是自动拆装箱？</p><ul><li>装箱：将基本类型用对应的有引用类型包装起来。</li><li>拆箱：将包装类型转换为基本数据类型。</li></ul><p>装箱就是调用包装类的valueOf()方法，拆箱就是调用xxxValue()方法。</p><p>为什么浮点数运算会有精度丢失的风险？<br>计算机是二进制的，计算机在表示一个数字时，宽度是有限的，无限循环小数存储在计算机中会被截断导致小数精度丢失问题。</p><p>如何解决浮点数精度丢失问题？</p><p><code>BigDecimal</code>可以实现对浮点数的运算，不会导致精度丢失。</p><p>超过long整型的数字如何表示？</p><p><code>BigInteger</code>内部使用<code>int[]</code>数组来储存，运算效率较低。在使用 <code>BigDecimal</code> 时，为了防止精度丢失，推荐使用它的<code>BigDecimal(String val)</code>构造方法或者 <code>BigDecimal.valueOf(double val)</code> 静态方法来创建对象。</p><h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类可以增加新的数据和功能，也可以使用父类的功能，但不能选择性继承。继承可以提高代码的复用性，程序的可维护性。</p><p>继承的三大特点：</p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，只有拥有。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以拥有自己的方法形式定义父类的方法。（以后介绍）</li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>一个对象具有多种状态，具体表现为父类的引用指向子类的实例。<br>多态的特点：</p><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型是从其方法调用的返回值类型来决定哪个方法，必须在程序运行时才能确定；</li><li>多态不能单用，只在子类存在任意父类方法不存在的时候；</li><li>如果子类没有重写父类方法，具体执行的是父类的写的方法，执行的就是父类的。</li></ul><h2 id="接口和抽象类异同？"><a href="#接口和抽象类异同？" class="headerlink" title="接口和抽象类异同？"></a>接口和抽象类异同？</h2><p>接口和抽象类的共同点</p><p>实例化: 接口和抽象类都不能直接实例化对象，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。<br>抽象方法: 接口和抽象类可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。</p><p>接口和抽象类的区别</p><ul><li><p>设计目的: 接口主要用于对类的行为进行约束，接口就拥有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</p></li><li><p>继承和实现： 一个类只能继承一个类（包括抽象类），因为 Java 不支持多继承。一个接口可以继承多个其他接口。</p></li><li><p>成员变量： 接口中的成员变量只能是 <code>public static final</code>，不能被修改且必须有初始值。抽象类的成员变量可以有任意修饰符，可以在子类被重新定义或赋值。</p></li><li><p>方法: </p><ul><li><p>在 Java 8 之前，接口中的方法默认是 <code>public abstract</code>，也就是只有方法声明。自 Java 8 起，可以在接口中定义 <code>default</code>（默认）方法和 <code>static</code>（静态）方法。自 Java 9 起，接口也可以包含 <code>private</code> 方法。</p></li><li><p>抽象类可以包含抽象方法和具体方法。抽象类方法有具体实现，可以直接在抽象类中使用或在子类中实现。非抽象方法具有具体实现。</p></li></ul></li></ul><p>在 Java 8 以及以后的版本中，接口可以拥有新的方法声明：default 方法、static 方法和 private 方法。这些方法被接口的实现类使用时必须满足一定规则。</p><h2 id="深拷贝和浅拷贝的区别？什么是引用拷贝？"><a href="#深拷贝和浅拷贝的区别？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝的区别？什么是引用拷贝？"></a>深拷贝和浅拷贝的区别？什么是引用拷贝？</h2><ul><li><p>浅拷贝: 浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的引用类型的变量，浅拷贝会直接复制内部对象的引用地址，也就是说浅拷贝对象和原对象共用一个内部对象。</p></li><li><p>深拷贝: 深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p></li><li><p>引用拷贝：两个不同的引用指向同一个对象。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250127142153772.png" alt="Loading"></p><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p><code>Object</code>类是一个特殊的类，是所有java类的父类，主要提供以下11种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实例被垃圾回收器回收的时候触发的操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="与-equals-的区别？"><a href="#与-equals-的区别？" class="headerlink" title="&#x3D;&#x3D; 与 equals() 的区别？"></a>&#x3D;&#x3D; 与 equals() 的区别？</h3><p>&#x3D;&#x3D; 对基本类型与引用类型是不同的：</p><ul><li><p>对基本类型是比较值。</p></li><li><p>对引用类型是比较对象的地址。</p></li></ul><p>注：java只有值传递，对于 &#x3D;&#x3D; 而言，不论是对于基本数据类型还是引用类型都是比较值。</p><p><code>equals()</code>不能用于判断基本类型，只能用于判断对象是否相对。</p><p><code>equals()</code>方法存在两种使用方法：</p><ul><li><p>类没有重写<code>equals()</code>：等价于 &#x3D;&#x3D; 。</p></li><li><p>类重写<code>equals()</code>：比较两个对象中属性是否相等。</p></li></ul><h3 id="hashcode-有什么用？"><a href="#hashcode-有什么用？" class="headerlink" title="hashcode() 有什么用？"></a>hashcode() 有什么用？</h3><p><code>hashcode</code>的作用是获取对象的hash码。有了 hashCode() 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进HashSet的过程）。</p><h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h4><ul><li><p>可变性： <code>String</code> 是不可变的。<code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p></li><li><p>线程安全：<code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 S<code>tringBuffer</code> 的公共父类。<code>StringBuffe</code>r 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p></li><li><p>性能：每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p></li></ul><h4 id="string-类为什么是不可变的？"><a href="#string-类为什么是不可变的？" class="headerlink" title="string 类为什么是不可变的？"></a>string 类为什么是不可变的？</h4><ul><li><p>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</p></li><li><p><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</p></li></ul><h4 id="字符串拼接使用-还是-StringBuilder？"><a href="#字符串拼接使用-还是-StringBuilder？" class="headerlink" title="字符串拼接使用 + 还是 StringBuilder？"></a>字符串拼接使用 + 还是 StringBuilder？</h4><p>Java自身并不支持运算符重载， + 与 +&#x3D; 是专门为 <code>String</code>类重载的，也是Java仅有的重载运算符。</p><p>字符串对象通过调用 + 拼接字符串的方式，本质上是通过<code>StringBuilder</code>调用<code>append()</code>方法，拼接完成后调用<code>toString()</code>得到<code>String</code>对象。</p><h4 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h4><p>会创建 1 或 2 个字符串对象。</p><ul><li><p>字符串常量池中不存在 “abc”：会创建 2 个 字符串对象。一个在字符串常量池中，由 <code>ldc</code> 指令触发创建。一个在堆中，由 <code>new String()</code> 创建，并使用常量池中的 “abc” 进行初始化。</p></li><li><p>字符串常量池中已存在 “abc”：会创建 1 个 字符串对象。该对象在堆中，由 <code>new String()</code> 创建，并使用常量池中的 “abc” 进行初始化。</p></li></ul><h4 id="String-intern-方法有什么作用"><a href="#String-intern-方法有什么作用" class="headerlink" title="String#intern 方法有什么作用?"></a>String#intern 方法有什么作用?</h4><p><code>String.intern()</code> 是一个 <code>native</code> (本地) 方法，用来处理字符串常量池中的字符串对象引用。</p><ul><li><p><code>intern()</code> 方法的主要作用是确保字符串引用在常量池中的唯一性。</p></li><li><p>当调用 <code>intern()</code> 时，如果常量池中已经存在相同内容的字符串，则返回常量池中已有对象的引用；否则，将该字符串添加到常量池并返回其引用。</p></li></ul><h1 id="Java的反射机制"><a href="#Java的反射机制" class="headerlink" title="Java的反射机制"></a>Java的反射机制</h1><h2 id="何为反射？"><a href="#何为反射？" class="headerlink" title="何为反射？"></a>何为反射？</h2><p>通过反射可以获取任意一个类的所有属性和方法，还可以调用。</p><h2 id="反射的运用场景"><a href="#反射的运用场景" class="headerlink" title="反射的运用场景"></a>反射的运用场景</h2><p>Spring&#x2F;Spring Boot、Mybatis框架都使用到了反射。</p><p>JDK动态代理的实现也依赖于反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代理类中的真实对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DebugInvocationHandler</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;<br>        System.out.println(<span class="hljs-string">&quot;before method &quot;</span> + method.getName());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        System.out.println(<span class="hljs-string">&quot;after method &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java中的注解也运用到了反射。</p><h2 id="反射机制的优缺点"><a href="#反射机制的优缺点" class="headerlink" title="反射机制的优缺点"></a>反射机制的优缺点</h2><p>优点：使代码更加灵活，为各种框架提供便利。</p><p>缺点：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点。</p><h2 id="获取Java对象的方式"><a href="#获取Java对象的方式" class="headerlink" title="获取Java对象的方式"></a>获取Java对象的方式</h2><ol><li>知道具体类的情况：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass</span> <span class="hljs-operator">=</span> TargetObject.class;<br></code></pre></td></tr></table></figure><ol start="2"><li>通过 <code>Class.forName()</code> 方法传入类的全路径获取</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;cn.test.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="3"><li>通过对象实例 <code>Instance.getClass()</code> 获取</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TargetObject</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TargetObject</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass2</span> <span class="hljs-operator">=</span> o.getClass();<br></code></pre></td></tr></table></figure><ol start="4"><li>通过类加载器 <code>xxxClassLoader.loadClass()</code> 传入类路径获取:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure><p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组遍历技巧</title>
    <link href="/2025/01/19/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%8A%80%E5%B7%A7/"/>
    <url>/2025/01/19/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="顺-逆时针旋转矩阵"><a href="#顺-逆时针旋转矩阵" class="headerlink" title="顺&#x2F;逆时针旋转矩阵"></a>顺&#x2F;逆时针旋转矩阵</h1><h2 id="LeetCode-48-旋转图像"><a href="#LeetCode-48-旋转图像" class="headerlink" title="LeetCode 48.旋转图像"></a>LeetCode 48.旋转图像</h2><p>常规的思路就是去寻找原始坐标和旋转后坐标的映射规律，但我们是否可以让思维跳跃跳跃，尝试把矩阵进行反转、镜像对称等操作，可能会出现新的突破口。</p><p>我们可以先将 n x n 矩阵 matrix 按照左上到右下的对角线进行镜像对称，然后再对矩阵的每一行进行反转，结果就是 matrix 顺时针旋转 90 度的结果：。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 将二维矩阵原地顺时针旋转 90 度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 先沿对角线镜像对称二维矩阵</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++) &#123;<br>                <span class="hljs-comment">// swap(matrix[i][j], matrix[j][i]);</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 然后反转二维矩阵的每一行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : matrix) &#123;<br>            reverse(row);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 反转一维数组</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = arr.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt; i) &#123;<br>            <span class="hljs-comment">// swap(arr[i], arr[j]);</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>扩展：如何将矩阵逆时针旋转90度<br>思路是类似的，只要通过另一条对角线镜像对称矩阵，然后再反转每一行，就得到了逆时针旋转矩阵的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// 将二维矩阵原地逆时针旋转 90 度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate2</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 沿左下到右上的对角线镜像对称二维矩阵</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n - i; j++) &#123;<br>                <span class="hljs-comment">// swap(matrix[i][j], matrix[n-j-1][n-i-1])</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[n - j - <span class="hljs-number">1</span>][n - i - <span class="hljs-number">1</span>];<br>                matrix[n - j - <span class="hljs-number">1</span>][n - i - <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 然后反转二维矩阵的每一行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : matrix) &#123;<br>            reverse(row);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-comment">// ···</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解法2：先翻转再对称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">//先翻转数组，再对称即可</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : matrix) &#123;<br>            reverse(arr);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[left];<br>            nums[left] = nums[right];<br>            nums[right] = tmp;<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="矩阵的螺旋遍历"><a href="#矩阵的螺旋遍历" class="headerlink" title="矩阵的螺旋遍历"></a>矩阵的螺旋遍历</h1><h2 id="LeetCode-54-螺旋矩阵"><a href="#LeetCode-54-螺旋矩阵" class="headerlink" title="LeetCode 54.螺旋矩阵"></a>LeetCode 54.螺旋矩阵</h2><p>解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界,随着螺旋遍历，相应的边界会收缩，直到螺旋遍历完整个数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">upper_bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lower_bound = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left_bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right_bound = n - <span class="hljs-number">1</span>;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// res.size() == m * n 则遍历完整个数组</span><br>        <span class="hljs-keyword">while</span> (res.size() &lt; m * n) &#123;<br>            <span class="hljs-keyword">if</span> (upper_bound &lt;= lower_bound) &#123;<br>                <span class="hljs-comment">// 在顶部从左向右遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> left_bound; j &lt;= right_bound; j++) &#123;<br>                    res.add(matrix[upper_bound][j]);<br>                &#125;<br>                <span class="hljs-comment">// 上边界下移</span><br>                upper_bound++;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (left_bound &lt;= right_bound) &#123;<br>                <span class="hljs-comment">// 在右侧从上向下遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> upper_bound; i &lt;= lower_bound; i++) &#123;<br>                    res.add(matrix[i][right_bound]);<br>                &#125;<br>                <span class="hljs-comment">// 右边界左移</span><br>                right_bound--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (upper_bound &lt;= lower_bound) &#123;<br>                <span class="hljs-comment">// 在底部从右向左遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> right_bound; j &gt;= left_bound; j--) &#123;<br>                    res.add(matrix[lower_bound][j]);<br>                &#125;<br>                <span class="hljs-comment">// 下边界上移</span><br>                lower_bound--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (left_bound &lt;= right_bound) &#123;<br>                <span class="hljs-comment">// 在左侧从下向上遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lower_bound; i &gt;= upper_bound; i--) &#123;<br>                    res.add(matrix[i][left_bound]);<br>                &#125;<br>                <span class="hljs-comment">// 左边界右移</span><br>                left_bound++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-59-螺旋矩阵Ⅱ"><a href="#LeetCode-59-螺旋矩阵Ⅱ" class="headerlink" title="LeetCode 59.螺旋矩阵Ⅱ"></a>LeetCode 59.螺旋矩阵Ⅱ</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">upper_bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lower_bound = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left_bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right_bound = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 需要填入矩阵的数字</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span> (num &lt;= n * n) &#123;<br>            <span class="hljs-keyword">if</span> (upper_bound &lt;= lower_bound) &#123;<br>                <span class="hljs-comment">// 在顶部从左向右遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> left_bound; j &lt;= right_bound; j++) &#123;<br>                    matrix[upper_bound][j] = num++;<br>                &#125;<br>                <span class="hljs-comment">// 上边界下移</span><br>                upper_bound++;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (left_bound &lt;= right_bound) &#123;<br>                <span class="hljs-comment">// 在右侧从上向下遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> upper_bound; i &lt;= lower_bound; i++) &#123;<br>                    matrix[i][right_bound] = num++;<br>                &#125;<br>                <span class="hljs-comment">// 右边界左移</span><br>                right_bound--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (upper_bound &lt;= lower_bound) &#123;<br>                <span class="hljs-comment">// 在底部从右向左遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> right_bound; j &gt;= left_bound; j--) &#123;<br>                    matrix[lower_bound][j] = num++;<br>                &#125;<br>                <span class="hljs-comment">// 下边界上移</span><br>                lower_bound--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (left_bound &lt;= right_bound) &#123;<br>                <span class="hljs-comment">// 在左侧从下向上遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lower_bound; i &gt;= upper_bound; i--) &#123;<br>                    matrix[i][left_bound] = num++;<br>                &#125;<br>                <span class="hljs-comment">// 左边界右移</span><br>                left_bound++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二维数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针相关算法</title>
    <link href="/2025/01/19/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/19/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、快慢指针"><a href="#一、快慢指针" class="headerlink" title="一、快慢指针"></a>一、快慢指针</h1><h2 id="原地修改"><a href="#原地修改" class="headerlink" title="原地修改"></a>原地修改</h2><h3 id="LeetCode-26-删除有序数组中的重复项"><a href="#LeetCode-26-删除有序数组中的重复项" class="headerlink" title="LeetCode 26. 删除有序数组中的重复项"></a>LeetCode 26. 删除有序数组中的重复项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fast] != nums[slow]) &#123;<br>                slow++;<br>                <span class="hljs-comment">// 维护 nums[0..slow] 无重复</span><br>                nums[slow] = nums[fast];<br>            &#125;<br>            fast++;<br>        &#125;<br>        <span class="hljs-comment">// 数组长度为索引 + 1</span><br>        <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LeetCode-27-移除元素"><a href="#LeetCode-27-移除元素" class="headerlink" title="LeetCode 27.移除元素"></a>LeetCode 27.移除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fast] != val) &#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>            fast++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与26题存在差别：先给 nums[slow] 赋值然后再给 slow++，这样可以保证 nums[0..slow-1] 是不包含值为 val 的元素的，最后的结果数组长度就是 slow。</p><h3 id="LeetCode-283-移动零"><a href="#LeetCode-283-移动零" class="headerlink" title="LeetCode 283.移动零"></a>LeetCode 283.移动零</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 去除 nums 中的所有 0，返回不含 0 的数组长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> removeElement(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 将 nums[p..] 的元素赋值为 0</span><br>        <span class="hljs-keyword">for</span> (; p &lt; nums.length; p++) &#123;<br>            nums[p] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 见27.代码实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口代码框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 滑动窗口算法框架伪码</span><br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (right &lt; nums.size()) &#123;<br>    <span class="hljs-comment">// 增大窗口</span><br>    window.addLast(nums[right]);<br>    right++;<br>    <br>    <span class="hljs-keyword">while</span> (window needs shrink) &#123;<br>        <span class="hljs-comment">// 缩小窗口</span><br>        window.removeFirst(nums[left]);<br>        left++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、左右指针"><a href="#二、左右指针" class="headerlink" title="二、左右指针"></a>二、左右指针</h1><p>二分方法下左右指针：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right + left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-167-两数之和Ⅱ"><a href="#LeetCode-167-两数之和Ⅱ" class="headerlink" title="LeetCode 167.两数之和Ⅱ"></a>LeetCode 167.两数之和Ⅱ</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = numbers.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> numbers[left] + numbers[right];<br>            <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                <span class="hljs-comment">// 题目要求的索引是从 1 开始的</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>                <span class="hljs-comment">// 让 sum 大一点</span><br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>                <span class="hljs-comment">// 让 sum 小一点</span><br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-344-反转字符串"><a href="#Leetcode-344-反转字符串" class="headerlink" title="Leetcode 344.反转字符串"></a>Leetcode 344.反转字符串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>    <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 交换 s[left] 和 s[right]</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s[left];<br>        s[left] = s[right];<br>        s[right] = temp;<br>        left++;<br>        right--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-5-最长回文子串"><a href="#Leetcode-5-最长回文子串" class="headerlink" title="Leetcode 5.最长回文子串"></a>Leetcode 5.最长回文子串</h2><p>判断回文串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        left++;<br>        right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>找回文串关键点在于，回文串长度可能为奇数也可能是偶数，解决问题核心在于从回文串中心向两边扩散的双指针技巧。<br>如果回文串长度为奇数，则它有一个中心字符；如果回文串长度为偶数，则有两个中心字符。<br>函数实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串</span><br>String <span class="hljs-title function_">palindrome</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-comment">// 防止索引越界</span><br>    <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.length()<br>            &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;<br>        <span class="hljs-comment">// 双指针，向两边展开</span><br>        l--; r++;<br>    &#125;<br>    <span class="hljs-comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span><br>    <span class="hljs-keyword">return</span> s.substring(l + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><p>整体解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-comment">// 以 s[i] 为中心的最长回文子串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> palindrome(s, i, i);<br>        <span class="hljs-comment">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> palindrome(s, i, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// res = longest(res, s1, s2)</span><br>        res = res.length() &gt; s1.length() ? res : s1;<br>        res = res.length() &gt; s2.length() ? res : s2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br>String <span class="hljs-title function_">palindrome</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-comment">// 防止索引越界</span><br>    <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.length()<br>            &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;<br>        <span class="hljs-comment">// 双指针，向两边展开</span><br>        l--; r++;<br>    &#125;<br>    <span class="hljs-comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span><br>    <span class="hljs-keyword">return</span> s.substring(l + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOC&amp;AOP</title>
    <link href="/2025/01/19/Spring-IOC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/01/19/Spring-IOC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="什么是IOC？"><a href="#什么是IOC？" class="headerlink" title="什么是IOC？"></a>什么是IOC？</h2><p>IOC即控制反转。是一种思想，将创建对象的权力交给外部容器(IOC容器)</p><h2 id="IOC解决的问题："><a href="#IOC解决的问题：" class="headerlink" title="IOC解决的问题："></a>IOC解决的问题：</h2><p>1.降低对象之间的耦合度；<br>2.使资源管理更简单。</p><h2 id="IOC与DI有什么区别？"><a href="#IOC与DI有什么区别？" class="headerlink" title="IOC与DI有什么区别？"></a>IOC与DI有什么区别？</h2><p>IOC是一种设计思想，即将本来在程序中手动创建对象的控制权交给第三方比如IOC容器。对于Spring框架而言，IOC就是一个Map(key,value)，Mao中存放各种对象。IOC并非Spring独有。<br>IOC最常见、最合理的实现方法即DI(依赖注入)。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h2><p>AOP即面向切面编程，AOP是OOP的一种延伸，二者互相补充。核心思想是将横切关注点从业务逻辑中抽离出来，形成一个个切面。</p><h2 id="AOP关键术语："><a href="#AOP关键术语：" class="headerlink" title="AOP关键术语："></a>AOP关键术语：</h2><ul><li>切点 (PointCut)：一个切点即一个表达式，用来匹配需要增强被切面增强的连接点。</li><li>切面(Aspect)：对横切关注点进行封装的类，一个切面是一个类。一个切面可以定义多个通知，实现具体的功能。</li><li>连接点(JoinPoint)：连接点是方法调用或方法执行的某个特定时刻(方法调用、异常抛出等)。</li><li>通知(Advice)：通知即切面在某个连接点要执行的操作。通知分为五种类型。分别是前置通知(Before)、后置通知(After)、返回通知(AfterReturning)、异常通知(AfterThrowing)和环绕通知(Around)。</li><li>织入(Weaving)：织入是将切面和目标对象连接起来的过程，即将通知应用到切点匹配的连接点上。常见的织入时期：编译器织入和运行期织入。</li></ul><h2 id="AOP常见的通知类型："><a href="#AOP常见的通知类型：" class="headerlink" title="AOP常见的通知类型："></a>AOP常见的通知类型：</h2><ul><li>Before（前置通知）：目标对象的方法调用在前触发。</li><li>After（后置通知）：目标对象的方法调用之后触发。</li><li>AfterReturning（返回通知）：目标对象的方法调用完成后触发，返回结果值之后触发。</li><li>AfterThrowing（异常通知）：目标对象的方法执行中抛出异常时触发。如果方法调用成功且无异常，则返回值不受影响。</li><li>Around（环绕通知）：可以在方法调用的前后执行自定义逻辑，甚至可以控制方法的执行，具有完全的控制权。</li></ul><h2 id="AOP解决了什么问题？"><a href="#AOP解决了什么问题？" class="headerlink" title="AOP解决了什么问题？"></a>AOP解决了什么问题？</h2><p>OOP不能很好的处理分散在多个类或对象中的公共行为，即横切关注点。而AOP可以将横切关注点从核心业务逻辑中分离出来，实现关注点的分离。</p><h2 id="AOP常见应用场景？"><a href="#AOP常见应用场景？" class="headerlink" title="AOP常见应用场景？"></a>AOP常见应用场景？</h2><ul><li>日志记录：自定义日志记录注解，利用 AOP，行代码即可实现日志记录。</li><li>性能统计：利用 AOP 在目标方法的执行前后进行统计，方便优化和分析。</li><li>事务管理：@Transactional 注解可以让 Spring 为我们进行事务管理，避免了重复的事务管理逻辑。@Transactional 注解是基于 AOP 实现的。</li><li>权限控制：利用 AOP 在目标方法执行前判断用户是否具备所需的权限，如果具备，就执行目标方法，否则就不执行。例如，SpringSecurity 利用 @PreAuthorize 注解一行代码即可自定义权限校验。</li><li>接入限制：利用 AOP 在目标方法执行前进行请求参数的校验和实现请求排队限流处理。</li><li>缓存管理：利用 AOP 在目标方法执行后进行缓存的读取和更新。</li></ul><h1 id="AOP实现方式有哪些？"><a href="#AOP实现方式有哪些？" class="headerlink" title="AOP实现方式有哪些？"></a>AOP实现方式有哪些？</h1><p>AOP常见实现方式有动态代理和字节码操作两种方式。</p><h2 id="Spring-AOP与AspectJ-AOP有什么区别？"><a href="#Spring-AOP与AspectJ-AOP有什么区别？" class="headerlink" title="Spring AOP与AspectJ AOP有什么区别？"></a>Spring AOP与AspectJ AOP有什么区别？</h2><p>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。Spring AOP 基于代理 (Proxy)，而 AspectJ 基于字节码操作（Bytecode Manipulation）。<br>Spring AOP 已经集成了 AspectJ，AspectJ 应该算的是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单。<br>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的时候，最好选择 AspectJ，它比 Spring AOP 快很多。</p>]]></content>
    
    
    <categories>
      
      <category>Spring框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo主题搭建</title>
    <link href="/2025/01/18/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
    <url>/2025/01/18/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1. 安装依赖包"></a>1. 安装依赖包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><h1 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br>npm install<br></code></pre></td></tr></table></figure><h1 id="3-关联Github"><a href="#3-关联Github" class="headerlink" title="3. 关联Github"></a>3. 关联Github</h1><h2 id="上传文章封面图不显示"><a href="#上传文章封面图不显示" class="headerlink" title="上传文章封面图不显示"></a>上传文章封面图不显示</h2><p>设置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">tags: [fluid, js, css,Hexo]<br>categories: [Hexo]<br>index_img: /source/img/cover/fluid.png<br></code></pre></td></tr></table></figure><p>问题：<br>设置路径错误，修正如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">categories: [Hexo]<br>index_img: /img/cover/fluid.png<br></code></pre></td></tr></table></figure><p>TODO：文章底部生成链接修正<br>TODO：头像旋转<br>TODO：引入一言<br>TODO：引入PV UV</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fluid</tag>
      
      <tag>js</tag>
      
      <tag>css</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>场景算法</title>
    <link href="/2025/01/18/%E5%9C%BA%E6%99%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/18/%E5%9C%BA%E6%99%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题-16-25-LRU缓存"><a href="#LeetCode-面试题-16-25-LRU缓存" class="headerlink" title="LeetCode 面试题 16.25. LRU缓存"></a>LeetCode 面试题 16.25. LRU缓存</h2><p>设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。<br>它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p>示例：</p><p>LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );</p><p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       &#x2F;&#x2F; 返回  1<br>cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得密钥 2 作废<br>cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)<br>cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得密钥 1 作废<br>cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)<br>cache.get(3);       &#x2F;&#x2F; 返回  3<br>cache.get(4);       &#x2F;&#x2F; 返回  4</p><p>思路：使用双向链表实现，每个节点包括k，v数据以及前驱、后继节点。此外，链表中还有虚拟节点dummy，让每个节点的pre和next均不为空，简化操作。<br>为什么要保存key？<br>在删除链表末尾节点时，需要删除哈希表中的记录，需要查找末尾节点的key。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> key, value;<br>        Node pre, next;<br><br>        Node(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v) &#123;<br>            key = k;<br>            value = v;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer,Node&gt; keyToNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        dummy.pre = dummy;<br>        dummy.next = dummy;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNode(key);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> ? node.value : -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNode(key);<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            node.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value);<br>        keyToNode.put(key,node);<br>        pushFront(node);<br>        <span class="hljs-keyword">if</span> (keyToNode.size() &gt; capacity) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">backNode</span> <span class="hljs-operator">=</span> dummy.pre;<br>            keyToNode.remove(backNode.key);<br>            remove(backNode);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (! keyToNode.containsKey(key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> keyToNode.get(key);<br>        remove(node);<br>        pushFront(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Node x)</span> &#123;<br>        x.pre.next = x.next;<br>        x.next.pre = x.pre;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushFront</span><span class="hljs-params">(Node x)</span> &#123;<br>        x.pre = dummy;<br>        x.next = dummy.next;<br>        x.pre.next = x;<br>        x.next.pre = x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手写单例模式的实现"><a href="#手写单例模式的实现" class="headerlink" title="手写单例模式的实现"></a>手写单例模式的实现</h2><h3 id="1-懒汉式"><a href="#1-懒汉式" class="headerlink" title="1.懒汉式"></a>1.懒汉式</h3><p>懒汉式单例是在第一次使用时创建实例，但这种方式在多线程环境下不安全，可能导致多个实例的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态变量，保存唯一的实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <span class="hljs-comment">// 这里是懒加载</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1懒汉式的线程安全模式"><a href="#1-1懒汉式的线程安全模式" class="headerlink" title="1.1懒汉式的线程安全模式"></a>1.1懒汉式的线程安全模式</h4><p>通过在 getInstance() 方法加锁来实现线程安全，但由于每次都加锁，可能会影响性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态变量，保存唯一的实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2双重检查锁"><a href="#1-2双重检查锁" class="headerlink" title="1.2双重检查锁"></a>1.2双重检查锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 使用 volatile 确保可见性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3静态内部类"><a href="#1-3静态内部类" class="headerlink" title="1.3静态内部类"></a>1.3静态内部类</h4><p>这种方式是线程安全的，并且延迟加载，推荐使用。JVM 确保了静态内部类只会加载一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态内部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHelper</span> &#123;<br>        <span class="hljs-comment">// 静态变量，保存唯一的实例</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHelper.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-饿汉式"><a href="#2-饿汉式" class="headerlink" title="2.饿汉式"></a>2.饿汉式</h3><p>这种方式在类加载时就创建实例，不会等到需要的时候才创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态变量，保存唯一的实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三个线程循环打印斐波那契数列"><a href="#三个线程循环打印斐波那契数列" class="headerlink" title="三个线程循环打印斐波那契数列"></a>三个线程循环打印斐波那契数列</h2><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FibonacciPrinter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <span class="hljs-comment">// 用于线程间同步</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">fib1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 斐波那契数列的第一个数字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">fib2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 斐波那契数列的第二个数字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 控制打印的次数</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建三个线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(<span class="hljs-number">2</span>));<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(<span class="hljs-number">3</span>));<br><br>        <span class="hljs-comment">// 启动线程</span><br>        thread1.start();<br>        thread2.start();<br>        thread3.start();<br>    &#125;<br><br>    <span class="hljs-comment">// 斐波那契数列打印任务</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FibonacciTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threadId;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">FibonacciTask</span><span class="hljs-params">(<span class="hljs-type">int</span> threadId)</span> &#123;<br>            <span class="hljs-built_in">this</span>.threadId = threadId;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">30</span>) &#123;  <span class="hljs-comment">// 打印30个斐波那契数列</span><br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    <span class="hljs-comment">// 判断当前线程是否轮到它打印</span><br>                    <span class="hljs-keyword">if</span> (count % <span class="hljs-number">3</span> == threadId - <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">nextFib</span> <span class="hljs-operator">=</span> fib1 + fib2;<br>                        System.out.println(<span class="hljs-string">&quot;Thread &quot;</span> + threadId + <span class="hljs-string">&quot; prints: &quot;</span> + fib1);<br>                        fib1 = fib2;<br>                        fib2 = nextFib;<br>                        count++;<br>                        lock.notifyAll();  <span class="hljs-comment">// 唤醒其他线程</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            lock.wait();  <span class="hljs-comment">// 当前线程等待</span><br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            Thread.currentThread().interrupt();<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script><div id="posts-chart"style="border-radius: 8px; height: 190px; padding: 10px;"></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>面经</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>lru</tag>
      
      <tag>JUC</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/01/18/hello-world/"/>
    <url>/2025/01/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script><div id="posts-chart"style="border-radius: 8px; height: 190px; padding: 10px;"></div>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
