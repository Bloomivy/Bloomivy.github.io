<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>单调队列结构</title>
    <link href="/2025/01/23/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84/"/>
    <url>/2025/01/23/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>为啥要发明「单调队列」这种结构呢，主要是为了解决下面这个场景：</p><p>给你一个数组 window，已知其最值为 A，如果给 window 中添加一个数 B，那么比较一下 A 和 B 就可以立即算出新的最值；但如果要从 window 数组中减少一个数，就不能直接得到最值了，因为如果减少的这个数恰好是 A，就需要遍历 window 中的所有元素重新寻找新的最值。</p><p>LeetCode 139.滑动窗口最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 单调队列的实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MonotonicQueue</span> &#123;<br>    LinkedList&lt;Integer&gt; maxq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 将小于 n 的元素全部删除</span><br>        <span class="hljs-keyword">while</span> (!maxq.isEmpty() &amp;&amp; maxq.getLast() &lt; n) &#123;<br>            maxq.pollLast();<br>        &#125;<br>        <span class="hljs-comment">// 然后将 n 加入尾部</span><br>        maxq.addLast(n);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> maxq.getFirst();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == maxq.getFirst()) &#123;<br>            maxq.pollFirst();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">MonotonicQueue</span> <span class="hljs-variable">window</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MonotonicQueue</span>();<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; k - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 先填满窗口的前 k - 1</span><br>                window.push(nums[i]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 窗口向前滑动，加入新数字</span><br>                window.push(nums[i]);<br>                <span class="hljs-comment">// 记录当前窗口的最大值</span><br>                res.add(window.max());<br>                <span class="hljs-comment">// 移出旧数字</span><br>                window.pop(nums[i - k + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 需要转成 int[] 数组再返回</span><br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; res.size(); i++) &#123;<br>            arr[i] = res.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2025/01/23/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2025/01/23/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a>单调栈模板</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] calculateGreaterElement(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-comment">// 存放答案的数组</span><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <br>    <span class="hljs-comment">// 倒着往栈里放</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 判定个子高矮</span><br>        <span class="hljs-keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &lt;= nums[i]) &#123;<br>            <span class="hljs-comment">// 矮个起开，反正也被挡着了。。。</span><br>            s.pop();<br>        &#125;<br>        <span class="hljs-comment">// nums[i] 身后的更大元素</span><br>        res[i] = s.isEmpty() ? -<span class="hljs-number">1</span> : s.peek();<br>        s.push(nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是单调队列解决问题的模板。for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个「个子高」元素之间的元素排除，因为他们的存在没有意义，前面挡着个「更高」的元素，所以他们不可能被作为后续进来的元素的下一个更大元素了。</p><p>分析它的时间复杂度，要从整体来看：总共有 n 个元素，每个元素都被 push 入栈了一次，而最多会被 pop 一次，没有任何冗余操作。所以总的计算规模是和元素规模 n 成正比的，也就是 O(n) 的复杂度。</p><h2 id="LeetCode-496-下一个更大的元素Ⅰ"><a href="#LeetCode-496-下一个更大的元素Ⅰ" class="headerlink" title="LeetCode 496.下一个更大的元素Ⅰ"></a>LeetCode 496.下一个更大的元素Ⅰ</h2><p>题目说 nums1 是 nums2 的子集，那么我们先把 nums2 中每个元素的下一个更大元素算出来存到一个映射里，然后再让 nums1 中的元素去查表即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] nextGreaterElement(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        <span class="hljs-comment">// 记录 nums2 中每个元素的下一个更大元素</span><br>        <span class="hljs-type">int</span>[] greater = calculateGreaterElement(nums2);<br>        <span class="hljs-comment">// 转化成映射：元素 x -&gt; x 的下一个最大元素</span><br>        HashMap&lt;Integer, Integer&gt; greaterMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums2.length; i++) &#123;<br>            greaterMap.put(nums2[i], greater[i]);<br>        &#125;<br>        <span class="hljs-comment">// nums1 是 nums2 的子集，所以根据 greaterMap 可以得到结果</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums1.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; i++) &#123;<br>            res[i] = greaterMap.get(nums1[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] calculateGreaterElement(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-comment">// 见上文</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-739-每日温度"><a href="#LeetCode-739-每日温度" class="headerlink" title="LeetCode 739.每日温度"></a>LeetCode 739.每日温度</h2><p>这个问题本质上也是找下一个更大元素，只不过现在不是问你下一个更大元素的值是多少，而是问你当前元素距离下一个更大元素的索引距离而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> temperatures.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 这里放元素索引，而不是元素</span><br>        Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <br>        <span class="hljs-comment">// 单调栈模板</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">while</span> (!s.isEmpty() &amp;&amp; temperatures[s.peek()] &lt;= temperatures[i]) &#123;<br>                s.pop();<br>            &#125;<br>            <span class="hljs-comment">// 得到索引间距</span><br>            res[i] = s.isEmpty() ? <span class="hljs-number">0</span> : (s.peek() - i); <br>            <span class="hljs-comment">// 将索引入栈，而不是元素</span><br>            s.push(i); <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-503-下一个更大的元素Ⅱ"><a href="#LeetCode-503-下一个更大的元素Ⅱ" class="headerlink" title="LeetCode 503.下一个更大的元素Ⅱ"></a>LeetCode 503.下一个更大的元素Ⅱ</h2><p>这个问题肯定还是要用单调栈的解题模板，但难点在于，比如输入是 [2,1,2,4,3]，对于最后一个元素 3，如何找到元素 4 作为下一个更大元素。</p><p>对于这种需求，常用套路就是将数组长度翻倍：</p><p>这样，元素 3 就可以找到元素 4 作为下一个更大元素了，而且其他的元素都可以被正确地计算。</p><p>有了思路，最简单的实现方式当然可以把这个双倍长度的数组构造出来，然后套用算法模板。但是，我们可以不用构造新数组，而是利用循环数组的技巧来模拟数组长度翻倍的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] nextGreaterElements(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">// 数组长度加倍模拟环形数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">// 索引 i 要求模，其他的和模板一样</span><br>            <span class="hljs-keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &lt;= nums[i % n]) &#123;<br>                s.pop();<br>            &#125;<br>            res[i % n] = s.isEmpty() ? -<span class="hljs-number">1</span> : s.peek();<br>            s.push(nums[i % n]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-1019-链表中的下一个更大节点"><a href="#LeetCode-1019-链表中的下一个更大节点" class="headerlink" title="LeetCode 1019.链表中的下一个更大节点"></a>LeetCode 1019.链表中的下一个更大节点</h2><p>这道题输入的是一条单链表，我们把它转化成数组，方便用索引访问即可直接套用<br>单调栈模板 中的 nextGreaterElement 函数逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] nextLargerNodes(ListNode head) &#123;<br>        <span class="hljs-comment">// 把单链表转化成数组，方便通过索引访问</span><br>        ArrayList&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>            nums.add(p.val);<br>        &#125;<br>        <span class="hljs-comment">// 存放答案的数组</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.size()];<br>        Stack&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">// 单调栈模板，求下一个更大元素，从后往前遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; stk.peek() &lt;= nums.get(i)) &#123;<br>                stk.pop();<br>            &#125;<br>            <span class="hljs-comment">// 本题要求没有下一个更大元素时返回 0</span><br>            res[i] = stk.isEmpty() ? <span class="hljs-number">0</span> : stk.peek();<br>            stk.push(nums.get(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-1944-队列中可以看到的人数"><a href="#LeetCode-1944-队列中可以看到的人数" class="headerlink" title="LeetCode 1944.队列中可以看到的人数"></a>LeetCode 1944.队列中可以看到的人数</h2><p>这道题显然要用到<br>单调栈技巧：靠左的高个子可以把靠右相邻的矮个子都「挤掉」，相当于计算下一个更大元素，即<br>单调栈的几种模板实现 中的 nextGreaterElement 函数。</p><p>只不过这道题不是问你下一个更大元素是多少，而是问你当前元素和下一个更大元素之间的元素个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] canSeePersonsCount(<span class="hljs-type">int</span>[] heights) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// int[] 记录 &#123;身高，小于等于该身高的人数&#125; 二元组</span><br>        Stack&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">// 记录右侧比自己矮的人</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 单调栈模板，计算下一个更大或相等元素（身高）</span><br>            <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; heights[i] &gt; stk.peek()) &#123;<br>                stk.pop();<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// 不仅可以看到比自己矮的人，如果后面存在更高的的人，也可以看到这个高人</span><br>            res[i] = stk.isEmpty() ? count : count + <span class="hljs-number">1</span>;<br>            stk.push(heights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-1475-商品折扣后的最终价格"><a href="#LeetCode-1475-商品折扣后的最终价格" class="headerlink" title="LeetCode 1475.商品折扣后的最终价格"></a>LeetCode 1475.商品折扣后的最终价格</h2><p>这道题就用到了<br>单调栈的几种模板实现 中讲到的一个单调栈模板：计算下一个更小或相等的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] finalPrices(<span class="hljs-type">int</span>[] prices) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 下一个小于等于 price[i] 的价格就是优惠券折扣</span><br>        <span class="hljs-type">int</span>[] nextElement = nextLessOrEqualElement(prices);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>            <span class="hljs-comment">// 如果存在优惠券，则减少相应的价格</span><br>            <span class="hljs-keyword">if</span> (nextElement[i] != -<span class="hljs-number">1</span>) &#123;<br>                res[i] = prices[i] - nextElement[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res[i] = prices[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 单调栈模板：计算 nums 中每个元素的下一个更小或相等的元素</span><br>    <span class="hljs-type">int</span>[] nextLessOrEqualElement(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 存放答案的数组</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">// 倒着往栈里放</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">// 删掉 nums[i] 后面较大的元素</span><br>            <span class="hljs-keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &gt; nums[i]) &#123;<br>                s.pop();<br>            &#125;<br>            <span class="hljs-comment">// 现在栈顶就是 nums[i] 身后的更小或相等元素</span><br>            res[i] = s.isEmpty() ? -<span class="hljs-number">1</span> : s.peek();<br>            s.push(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown基本语法</title>
    <link href="/2025/01/23/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2025/01/23/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Guava令牌桶</title>
    <link href="/2025/01/23/Guava%E4%BB%A4%E7%89%8C%E6%A1%B6/"/>
    <url>/2025/01/23/Guava%E4%BB%A4%E7%89%8C%E6%A1%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Guava-令牌桶"><a href="#Guava-令牌桶" class="headerlink" title="Guava 令牌桶"></a>Guava 令牌桶</h1><p>Guava 是 Google 提供的一个开源 Java 库，RateLimiter 是 Guava 中实现令牌桶限流机制的核心工具。Guava 的令牌桶实现基于 RateLimiter 类，它通过令牌的生成来控制并限制请求的速率，确保系统在一定时间窗口内不会被过多请求淹没，从而起到保护系统和保证服务质量的作用。</p><h2 id="Guava-令牌桶的特点"><a href="#Guava-令牌桶的特点" class="headerlink" title="Guava 令牌桶的特点"></a>Guava 令牌桶的特点</h2><ul><li><p>平滑限流：Guava 通过令牌的生成速率来确保流量的平滑度。RateLimiter 默认采用的是“平滑突发限流”（Smooth Bursty），它允许一定的流量突发。</p></li><li><p>平滑预热限流：Guava 还提供了一种“平滑预热限流”（Smooth Warming Up），当系统启动时，令牌生成速度逐渐增加，适用于服务在冷启动或需要预热阶段的场景。</p></li><li><p>灵活配置：可以根据实际需求设置令牌的生成速率，并提供灵活的参数配置。</p></li></ul><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="RateLimiter-使用"><a href="#RateLimiter-使用" class="headerlink" title="RateLimiter 使用"></a>RateLimiter 使用</h2><p>在 onMessage() 消息消费方法中，通过 acquire() 方法可获取令牌，若成功获取了令牌，则正常执行后续代码；如果没有令牌可用，将阻塞，直到获得为止。</p><h2 id="搭配-Nacos-动态配置"><a href="#搭配-Nacos-动态配置" class="headerlink" title="搭配 Nacos 动态配置"></a>搭配 Nacos 动态配置</h2><p>在生产环境中，服务往往是以集群的方式部署，假设 3 个服务实例构建成一个最基础的集群，数据库每秒能够承受 5000 的并发访问，则平摊到每个服务实例，应该配置为每秒生成 1666 个令牌：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123141829627.jpg" alt="Loading"></p><p>但是生产环境中，集群的实例数往往随时会发生变动，如果集群压力过大，顶不住目前的流量，运维可能会加机器，比如将 3 实例的集群扩展为 5 实例的集群，那么代码中写死的每秒令牌生成数就不对了，应该变更为 5000 &#x2F; 5 &#x3D; 1000，即每秒生成 1000 个令牌，以维持数据库每秒最大能够承受的访问量。</p><p>关于每秒生成的令牌数，完全可以添加到 Nacos 配置中心中。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Guava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Caffeine</title>
    <link href="/2025/01/23/Caffeine/"/>
    <url>/2025/01/23/Caffeine/</url>
    
    <content type="html"><![CDATA[<h1 id="Caffeine-介绍"><a href="#Caffeine-介绍" class="headerlink" title="Caffeine 介绍"></a>Caffeine 介绍</h1><p>Caffeine 是一个高性能、轻量级的 Java 缓存库，旨在提供简单易用的 API 和强大的功能集合。它由 Google 的工程师 Ben Manes 开发，并在多个 Google 内部项目中广泛使用。Caffeine 作为 Java 应用程序中的缓存解决方案，旨在提高应用程序的性能和响应速度，通过减少对外部系统的依赖来加快数据访问的速度。</p><p>Caffeine 的特性如下：</p><ul><li><p>高性能：Caffeine 优化了内部结构，使得缓存操作非常快速。它使用了高效的数据结构和算法，如哈希表和跳表，以及并发友好的实现策略。</p></li><li><p>内存效率：Caffeine 采用了一种称为 Window TinyLFU (W-TinyLFU) 的淘汰策略，它综合了 LRU 和 LFU 的优点，能够更智能地管理缓存中的条目。这种策略可以有效地利用有限的内存资源，同时保持较高的缓存命中率。</p></li><li><p>易于使用：Caffeine 提供了一个简洁的 API，允许开发者轻松地集成缓存逻辑到现有的应用程序中。它还支持多种配置选项，可以根据具体需求进行定制。</p></li><li><p>丰富的功能：除了基本的缓存功能外，Caffeine 还提供了许多高级特性，如定时清理、异步加载、统计报告等。</p></li><li><p>高度可配置：用户可以通过多种方式来调整缓存的行为，包括设置最大容量、TTL（Time To Live，存活时间）、TID（Time To Idle，空闲时间）等参数。</p></li></ul><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Caffeine 本地缓存 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="初始化缓存"><a href="#初始化缓存" class="headerlink" title="初始化缓存"></a>初始化缓存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用户信息本地缓存</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Cache&lt;Long, FindUserByIdRspDTO&gt; LOCAL_CACHE = Caffeine.newBuilder()<br>           .initialCapacity(<span class="hljs-number">10000</span>) <span class="hljs-comment">// 设置初始容量为 10000 个条目</span><br>           .maximumSize(<span class="hljs-number">10000</span>) <span class="hljs-comment">// 设置缓存的最大容量为 10000 个条目</span><br>           .expireAfterWrite(<span class="hljs-number">1</span>, TimeUnit.HOURS) <span class="hljs-comment">// 设置缓存条目在写入后 1 小时过期</span><br>           .build();<br></code></pre></td></tr></table></figure><p>代码解释：</p><ul><li><p><code>initialCapacity</code>: 指定缓存的初始容量。这里初始容量设置为 10000。这意味着缓存最初会预留足够的空间来容纳大约 10000 个条目。这有助于减少缓存扩容的次数，提高性能。</p></li><li><p><code>maximumSize</code>: 指定缓存的最大容量。这里最大容量同样设置为 10000。当缓存中的条目数量超过这个限制时，缓存将开始根据淘汰策略来移除旧条目。这里使用的是 W-TinyLFU 淘汰策略。</p></li><li><p><code>expireAfterWrite</code>: 这个配置指定了缓存条目写入后多久过期。在上面代码中，设置为 1 小时。这意味着一旦一个条目被写入缓存，它将在 1 小时后自动过期并被清除。这有助于防止缓存中存放过时的数据。</p></li></ul><p>再通过 Jmeter 压测一波，看看对比上小节，引入了二级缓存后，性能提升了多少：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123103536839.jpg" alt="Loading"></p><p>如上图所示，吞吐量提升了 2000&#x2F;s 左右，接口响应耗时平均减少了 1ms。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Caffeine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式ID生成</title>
    <link href="/2025/01/23/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90/"/>
    <url>/2025/01/23/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是分布式ID？"><a href="#什么是分布式ID？" class="headerlink" title="什么是分布式ID？"></a>什么是分布式ID？</h1><p>分布式 ID 是指在一个分布式系统中，为每一个数据项或事件生成一个全局唯一标识符的过程。 这个标识符通常是一个长整型数字或字符串，能够跨多个服务实例和数据库集群唯一识别每一个实体，是实现数据关联和跟踪的基础。</p><p>在传统的单体应用中，ID 生成相对简单，可以通过数据库的自增字段来实现。但在微服务架构下，每个服务可能运行在不同的服务器上，甚至可能有多个实例，这就意味着每个服务都需要独立生成 ID，并且保证全局唯一性。此外，分布式 ID 还需要解决以下几个关键问题：</p><ul><li><p>一致性：所有生成的 ID 必须在分布式环境中保持一致，避免重复和冲突。</p></li><li><p>高性能：在高并发场景下，ID 生成机制不能成为系统的瓶颈。</p></li><li><p>可扩展性：随着业务的增长，ID 生成策略应该易于扩展，适应更大的负载。</p></li><li><p>容错性：即使部分服务出现故障，ID 生成也不能中断。</p></li></ul><h1 id="分布式-ID-生成方案"><a href="#分布式-ID-生成方案" class="headerlink" title="分布式 ID 生成方案"></a>分布式 ID 生成方案</h1><p>目前，业界已经发展出了多种分布式 ID 生成算法和技术，以下是常见的几种方案：</p><ol><li><p>UUID ： UUID (Universally Unique Identifier) 是一种常用的分布式 ID 生成方式, 它的标准型式包含 32 个 16 进制数字，以连字号分为五段，形式为 8-4-4-4-12 的 36 个字符，示例：550e8400-e29b-41d4-a716-446655440000。</p><p> 优点:</p><ul><li>生成性能非常高：直接本地生成，不依赖其他中间件，无网络 &#x2F; 磁盘 IO 消耗；</li></ul><p> 缺点：</p><ul><li><p>不易于存储：UUID 太长，16 字节 128 位，通常以 36 长度的字符串表示。在海量数据场景下，会消耗较大的存储空间。</p></li><li><p>信息不安全：基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</p></li><li><p>充当主键时，在特定场景下，会存在问题。如作为 MySQL 数据库的主键时，UUID 就非常不合适。</p></li><li><p>基于数据库（DB）的自增 ID ：可以单独创建一张共享的 ID 生成表，使用自增字段来生成 ID，再存到业务表主键字段中。</p></li></ul></li><li><p>基于数据库（DB）的自增 ID ：可以单独创建一张共享的 ID 生成表，使用自增字段来生成 ID，再存到业务表主键字段中。<br> 优点：</p><ul><li><p>实现非常简单，利用现有的数据库即可搞定；</p></li><li><p>ID 单调递增；</p></li></ul><p> 缺点：</p><ul><li><p>强依赖 DB，当 DB 异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。</p></li><li><p>ID 发号性能瓶颈限制在单台 MySQL 的读写性能。</p></li></ul></li><li><p>基于分布式协调服务： 利用 Zookeeper、Etcd 等分布式协调服务，可以实现 ID 的有序分配。虽然这种方法可以保证 ID 的顺序性，但引入了外部依赖，增加了系统的复杂度。</p></li><li><p>基于分布式缓存：使用 Redis 的 INCRBY 命令，可以为键 （Key）的数字增加指定增量。如果键不存在，则数值会被初始化为 0，然后再执行增量操作。</p></li><li><p>基于 Snowflake 算法（雪花算法）： Snowflake 算法由 Twitter 开发，它结合了时间戳、机器 ID 和序列号，生成 64 位的 ID，如下图所示：</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123085339179.png" alt="Loading" title="snowflake"></p><ul><li><p>1bit: 符号位（标识正负），不作使用，始终为 0，代表生成的 ID 为正数。</p></li><li><p>41-bit 时间戳: 一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）</p></li><li><p>datacenter id + worker id (10 bits): 一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（项目中可以根据实际需求来调整）。这样就可以区分不同集群&#x2F;机房的节点。</p></li><li><p>12-bit 序列号: 一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 &#x3D; 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。理论上 snowflake 方案的QPS约为 409.6w &#x2F;s，这种分配方式可以保证在任何一个 IDC 的任何一台机器在任意毫秒内生成的 ID 都是不同的。</p></li></ul><p>snowflake 雪花算法优缺点如下：</p><p>优点：</p><ul><li><p>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</p></li><li><p>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</p></li><li><p>可以根据自身业务特性分配bit位，非常灵活。</p></li></ul><p>缺点：</p><ul><li>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</li></ul><h1 id="Leaf-介绍"><a href="#Leaf-介绍" class="headerlink" title="Leaf 介绍"></a>Leaf 介绍</h1><p>Leaf 这个名字是来自德国哲学家、数学家莱布尼茨的一句话： There are no two identical leaves in the world</p><p>—— “世界上没有两片相同的树叶”</p><p>美团 Leaf 基于数据库生成以及 snowflake 雪花算法方案之上，做了进一步的优化，提供了如下两种方案：</p><ol><li>第一种：Leaf-segment 数据库方案:</li></ol><p>在使用数据库的方案上，做了如下改变：</p><p>原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用proxy server批量获取，每次获取一个segment(step决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。<br>各个业务不同的发号需求用biz_tag字段来区分，每个biz-tag的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对biz_tag分库分表就行。</p><ol start="2"><li>第二种：Leaf-snowflake 雪花算法方案:</li></ol><p>Leaf-snowflake方案完全沿用snowflake方案的bit位设计，即是“1+41+10+12”的方式组装ID号。对于workerID的分配，当服务集群数量较小的情况下，完全可以手动配置。Leaf服务规模较大，动手配置成本太高。所以使用Zookeeper持久顺序节点的特性自动对snowflake节点配置wokerID。Leaf-snowflake是按照下面几个步骤启动的：</p><p>启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。<br>如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。<br>如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。</p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>Leaf 的 GitHub 地址是：<a href="https://github.com/Meituan-Dianping/Leaf">https://github.com/Meituan-Dianping/Leaf</a> ，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123085611256.png" alt="Loading"></p><ul><li>①：leaf-core : 核心模块，包括两种方案的核心代码；</li><li>②：leaf-server : 服务端工程，用于对外提供接口获取分布式 ID，以及监控页面;</li><li>③：scripts : 数据库脚本；</li></ul><p>打开命令行工具，进入到想要存放工程的文件夹下，执行如下命令，拉取 Leaf 源码。</p><p><code>git clone https://github.com/Meituan-Dianping/Leaf.git</code></p><h2 id="准备数据库"><a href="#准备数据库" class="headerlink" title="准备数据库"></a>准备数据库</h2><p>源码拉取完毕后，还有一些前置工作。由于 Leaf-segment 方案依赖于数据库，所以还需提前将数据库、表创建好。新建一个名为 leaf 的数据库。库创建完毕后，执行如下 SQL :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE TABLE</span> `leaf_alloc` (<br>  `biz_tag` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>)  <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  `max_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1&#x27;</span>,<br>  `step` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT NULL</span>,<br>  `description` <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>)  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `update_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`biz_tag`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB;<br><br><span class="hljs-keyword">insert into</span> leaf_alloc(biz_tag, max_id, step, description) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;leaf-segment-test&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;Test leaf Segment Mode Get Id&#x27;</span>)<br></code></pre></td></tr></table></figure><p>表设计</p><ul><li><p>biz_tag : 用来区分业务，例如生成用户 ID、生成笔记 ID通过此标识隔离开来;</p></li><li><p>max_id: 表示该 biz_tag 目前所被分配的 ID 号段的最大值;</p></li><li><p>step: 表示每次分配的号段长度。</p></li></ul><p>基于数据库生成 ID, 最原始的方案是，获取 ID 每次都需要写数据库，现在只需要把 step 设置得足够大，比如 1000。那么只有当 1000 个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从1减小到了 1&#x2F;step 。</p><p>表创建完成后，再插入一条业务标识为 leaf-segment-test 的记录，step 为 2000，表示号段长度为 2000， 即每次生成 2000 个 ID 。</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>数据库准备好后，通过 IDE 打开 Leaf 源码工程，并编辑 leaf-server 模块 &#x2F;resources 资源目录中的 leaf.properties 配置文件</p><p>将 leaf.segment.enable 配置为 true , 表示开启号段模式，并配置数据库连接等信息。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">leaf.name</span>=<span class="hljs-string">com.sankuai.leaf.opensource.test</span><br><span class="hljs-attr">leaf.segment.enable</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">leaf.jdbc.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/leaf?useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="hljs-attr">leaf.jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">leaf.jdbc.password</span>=<span class="hljs-string">123456</span><br><br><span class="hljs-attr">leaf.snowflake.enable</span>=<span class="hljs-string">false</span><br><span class="hljs-comment">#leaf.snowflake.zk.address=</span><br><span class="hljs-comment">#leaf.snowflake.port=</span><br></code></pre></td></tr></table></figure><h2 id="启动-Leaf"><a href="#启动-Leaf" class="headerlink" title="启动 Leaf"></a>启动 Leaf</h2><p>数据库连接配置完毕后，运行 leaf-server 模块下的启动类，看看能否启动成功。不出意外，你会发现控制台报错如下</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123085941651.jpg" alt="Loading" title="启动时报错"></p><p>因为我们目前使用的是 8.0 版本的 MySQL, 需要对 leaf-seaver 模块的 pom.xml 添加最新的驱动</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MySQL 驱动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.29<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加完依赖后，刷新一下 Maven。 然后，编辑 &#x2F;service 包下的 SegmentService 类，在初始化数据源的时候，指定一下驱动路径，以及连接池中连接检查 SQL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">         <span class="hljs-comment">// Config dataSource</span><br>         dataSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>         dataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br><span class="hljs-comment">// 省略...</span><br>         dataSource.setValidationQuery(<span class="hljs-string">&quot;select 1&quot;</span>);<br>         dataSource.init();<br></code></pre></td></tr></table></figure><h3 id="号段模式获取分布式-ID-测试"><a href="#号段模式获取分布式-ID-测试" class="headerlink" title="号段模式获取分布式 ID 测试"></a>号段模式获取分布式 ID 测试</h3><p>测试一下号段模式获取分布式 ID。两种方案的接口地址，可在 LeafController 类中找到<br>号段模式的接口地址为<br><code>http://localhost:8080/api/segment/get/&#123;key&#125;</code></p><p>key 表示业务标识，即表中的 biz_tag 字段。比如我们想要获取 biz_tag 为 leaf-segment-test 的下一个分布式 ID, 访问接口如下<br><code>http://localhost:8080/api/segment/get/leaf-segment-test</code></p><p>浏览器访问，如下图所示，成功拿到了 ID 值, 并且每次刷新，都会一直递增下去</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123090306186.jpg" alt="Loading"></p><h3 id="监控页"><a href="#监控页" class="headerlink" title="监控页"></a>监控页</h3><p>如果想获取一些监控数据，LeafMonitorController 类中定义了对应的接口，路径如下<br><code>http://localhost:8080/cache</code></p><p>浏览器访问，效果图如下：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123090419001.jpg" alt="Loading"></p><h2 id="Docker-安装-Zookeeper"><a href="#Docker-安装-Zookeeper" class="headerlink" title="Docker 安装 Zookeeper"></a>Docker 安装 Zookeeper</h2><p>我们已经测试了美团 Leaf-segment 号段模式（依赖数据库）来获取分布式 ID , 除了该模式外，还有 Leaf-snowflake （基于雪花算法）模式，它依赖于 Zookeeper。</p><h3 id="Zookeeper-介绍"><a href="#Zookeeper-介绍" class="headerlink" title="Zookeeper 介绍"></a>Zookeeper 介绍</h3><p>Apache ZooKeeper 是一个开源的分布式协调服务，用于大型分布式系统的开发和管理。它提供了一种简单而统一的方法来解决分布式应用中常见的协调问题，如命名服务、配置管理、集群管理、组服务、分布式锁、队列管理等。ZooKeeper 通过提供一种类似文件系统的结构来存储数据，并允许客户端通过简单的 API 进行读写操作，从而简化了分布式系统的复杂度。</p><p>Zookeeper 的核心特性如下：</p><ul><li><p>一致性：对于任何更新，所有客户端都将看到相同的数据视图。这是通过 ZooKeeper 的原子性保证的，意味着所有更新要么完全成功，要么完全失败。</p></li><li><p>可靠性：一旦数据被提交，它将被持久化存储，即使在某些服务器出现故障的情况下，数据也不会丢失。</p></li><li><p>实时性：ZooKeeper 支持事件通知机制，允许客户端实时接收到数据变化的通知。</p></li><li><p>高可用性：ZooKeeper 通常以集群形式部署，可以容忍部分节点的故障，只要集群中超过半数的节点是可用的，ZooKeeper 就能继续提供服务。</p></li></ul><p>ZooKeeper 的数据模型：</p><p>ZooKeeper 使用一个层次化的命名空间来组织数据，类似于文件系统中的目录树。每个节点（称为 znode）都可以有子节点，形成树状结构。每个 znode 可以存储一定量的数据，并且可以设置访问控制列表（ACL）来控制谁可以读取或修改数据。</p><p>ZooKeeper 的应用场景：</p><ul><li><p>配置管理：ZooKeeper 可以用来集中存储和管理分布式系统中的配置信息，当配置发生变化时，可以实时通知到所有客户端。</p></li><li><p>命名服务：ZooKeeper 可以作为服务发现的注册中心，帮助客户端查找和定位服务。</p></li><li><p>集群管理：ZooKeeper 可以用于选举主节点、检测集群成员的变化、以及监控集群的健康状况。</p></li><li><p>分布式锁：ZooKeeper 提供了一种机制来实现分布式环境下的互斥访问，保证多个进程之间数据操作的正确性。</p></li><li><p>队列管理：ZooKeeper 可以用来实现分布式队列，如任务调度队列或消息队列。</p></li></ul><ol><li>下载镜像</li></ol><p>打开命令行工具，执行如下命令，拉取 Zookeeper 镜像</p><p><code>docker pull zookeeper:3.5.6</code></p><ol start="2"><li>创建挂载文件夹</li></ol><p>镜像下载完成后，在 E:&#x2F;docker&#x2F; 目录下创建 &#x2F;zookeeper 文件夹，用于存放等会启动容器时，挂载出容器内 Zookeeper 的相关配置文件，以及相关持久化数据</p><ol start="3"><li>运行容器</li></ol><p>执行如下命令，运行一个 Zookeeper 容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --name zookeeper -p <span class="hljs-number">2181</span>:<span class="hljs-number">2181</span> -e TZ=<span class="hljs-string">&quot;Asia/Shanghai&quot;</span> -v E:\docker\zookeeper\data:/data -v E:\docker\zookeeper\conf:/conf zookeeper:<span class="hljs-number">3</span>.<span class="hljs-number">5</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>参数解释</p><ul><li><p>docker run: 这是启动一个新的 Docker 容器的命令。</p></li><li><p>-d: 这个选项表示以守护进程模式（即后台）运行容器。</p></li><li><p>–name zookeeper: 给容器指定一个名字叫做 zookeeper。这可以帮助你更容易地识别和管理这个容器。</p></li><li><p>-p 2181:2181: 这是一个端口映射选项，它将宿主机的 2181 端口映射到容器内的 2181 端口。这意味着在宿主机上，你可以通过访问 localhost:2181 来连接到运行在容器内的 ZooKeeper 服务。</p></li><li><p>-e TZ&#x3D;”Asia&#x2F;Shanghai”: 这个环境变量设置将容器内部的时间区域设为上海时区（亚洲&#x2F;上海）。这样可以确保容器内的时间与你的本地时区一致。</p></li><li><p>-v E:\docker\zookeeper\data:&#x2F;data: 这是一个卷挂载选项，将宿主机上的 E:\docker\zookeeper\data 目录挂载到容器内的 &#x2F;data 目录。通常，ZooKeeper 将数据存储在 &#x2F;data 目录下，因此这个挂载点可以让你在宿主机上持久化 ZooKeeper 的数据。</p></li><li><p>-v E:\docker\zookeeper\conf:&#x2F;conf: 类似于上面的挂载，这里将宿主机上的 E:\docker\zookeeper\conf 目录挂载到容器内的 &#x2F;conf 目录。ZooKeeper 的配置文件一般位于 &#x2F;conf 目录下，这样你可以在宿主机上编辑配置文件，而不会影响到容器重启后的配置。</p></li><li><p>zookeeper:3.5.6: 这是指定使用的 Docker 镜像，这里是 ZooKeeper 版本 3.5.6 的镜像。</p></li></ul><ol start="4"><li>容器运行成功后，可通过 docker ps 命令查看正在运行中的容器，确认一下 Zookeeper 是否启动成功了</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123090748174.png" alt="Loading"></p><ol start="5"><li>进入 Zookeeper</li></ol><p>执行如下命令，进入到 Zookeeper 容器中</p><p><code>docker exec -it zookeeper bash</code></p><p>接着，执行如下命令，来启动 ZooKeeper 的命令行界面（CLI），它允许用户直接与 ZooKeeper 服务器进行交互</p><p><code>./bin/zkCli.sh</code></p><p>连接成功后，效果图如下</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123090915828.png" alt="Loading"></p><ol start="6"><li>zk 基本命令</li></ol><p>ZooKeeper CLI (zkCli) 是 ZooKeeper 分布式协调服务附带的一个命令行工具，它提供了与 ZooKeeper 服务器交互的方式。使用 zkCli，你可以执行诸如查看、创建、修改和删除 ZooKeeper 中的数据节点（znodes）的操作。</p><ul><li>ls：列出当前路径下的子节点。如：查看根节点的子节点，命令如下</li></ul><p><code>ls /</code></p><ul><li>create：创建一个新的节点 （znode）</li></ul><p><code>create /myNode &quot;hello&quot;</code></p><p>以上命令，将创建一个名为 &#x2F;myNode 的节点，并初始化其数据为 “hello”。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123091016808.png" alt="Loading"></p><ul><li>get：获取指定节点的数据和状态信息。命令如下</li></ul><p><code>get /myNode</code></p><ul><li>set：设置指定节点的数据。命令如下</li></ul><p><code>set /myNode &quot;fresh&quot;</code></p><ul><li>delete：删除指定的节点（znode） 。命令如下</li></ul><p><code>delete /myNode</code></p><p>以上命令，将删除 &#x2F;myNode 节点，注意，只有当该节点没有子节点时才有效。</p><ul><li>quit：退出 zkCli 命令行工具。效果如下：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123091241534.png" alt="Loading"></p><p>美团 Leaf-snowflake 雪花算法模式测试</p><p>编辑配置<br>首先，编辑 leaf-server 模块中的 leaf.properties 配置文件，将 snowflake 模式开启，并配置好 Zookeeper 连接地址，如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 是否开启 snowflake 模式</span><br><span class="hljs-attr">leaf.snowflake.enable</span>=<span class="hljs-literal">true</span><br><span class="hljs-comment"># snowflake 模式下的 zk 地址</span><br><span class="hljs-attr">leaf.snowflake.zk.address</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2181</span><br><span class="hljs-comment"># snowflake 模式下的服务注册端口</span><br><span class="hljs-attr">leaf.snowflake.port</span>=<span class="hljs-number">2222</span><br></code></pre></td></tr></table></figure><p>运行 Leaf<br>运行 leaf-server 项目，若控制台中提示 Snowflake Service Init Successfully , 则表示 Leaf-snowflake 模式初始化成功了</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123091358519.jpg" alt="Loading"></p><p>接口测试<br>项目启动成功后，访问如下接口，即可获取雪花算法 ID</p><p><code>/api/snowflake/get/&#123;key&#125;</code></p><p>关于参数 key , 随便填一个就行。阅读源码，查看 SnowflakeIDGenImpl 类，即可得知 key 实际并没有使用到</p><p>浏览器访问此接口，即可获取基于雪花算法生成的 ID 了，如下图所示，每次刷新结果都会不同，而且值是趋势递增的</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123091535799.jpg" alt="Loading"></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>ZooKeeper</tag>
      
      <tag>leaf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2025/01/22/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/01/22/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合类</title>
    <link href="/2025/01/22/Java%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <url>/2025/01/22/Java%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能测试</title>
    <link href="/2025/01/22/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <url>/2025/01/22/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>性能测试是一种检查软件、应用或系统在特定负载下表现的方法。简单来说，就是看看它们能不能承受一定的工作量，并且还能正常运作。</p><p>相关术语</p><ul><li><p>并发用户：在性能测试工具中，一般称为虚拟用户（Virtual User，简称VU），指的是现实系统中操作业务的用户。</p></li><li><p>TPS：Transaction Per Second，每秒事务数，是衡量系统性能的一个非常重要的指标。</p></li><li><p>RPS：Request Per Second，每秒请求数。RPS模式适合用于容量规划和作为限流管控的参考依据。</p></li><li><p>RT：Response Time，响应时间，指的是业务从客户端发起到客户端接收的时间。</p></li><li><p>QPS (Queries Per Second)：每秒执行的查询次数。例如，如果一个网站的首页每秒可以响应 100 次用户请求，则该页面的 QPS 为 100。</p></li></ul><p>在性能测试中，通常有两种施压模式：并发模式和RPS模式。传统方式是使用并发用户数来衡量系统的性能（站在客户端视角）。此方法一般适用于一些网页站点的压测（例如H5页面）；而RPS（Requests per second）模式主要是为了方便直接衡量系统的吞吐能力TPS（Transaction Per Second，每秒事务数）而设计的（站在服务端视角），按照被压测端需要达到TPS等量设置相应的RPS，应用场景主要是一些动态的接口API，例如登录、提交订单等等。</p><p>易混点</p><ul><li><p>TPS vs. QPS:</p><ul><li><p>TPS 关注的是整个业务流程的完成情况，例如完成一笔订单交易。</p></li><li><p>QPS 更加细化，专注于单个数据库查询或 API 调用的速度。一个TPS可能包含多个QPS。</p></li></ul></li><li><p>QPS vs. RPS:</p><ul><li><p>QPS 通常特指数据库查询的频率，API 接口的调用速率。</p></li><li><p>RPS 是指 HTTP 请求的频率，可以包括GET、POST等不同类型的操作。</p></li></ul></li><li><p>TPS vs. RPS:</p><ul><li><p>TPS 关注的是业务层面的事务处理速度。</p></li><li><p>RPS 则是针对 HTTP 协议的请求处理速度，通常比 TPS 更加频繁。</p></li></ul></li></ul><p>VU和TPS换算<br>公式描述：TPS&#x3D;VU&#x2F;RT，（RT单位：秒）。</p><p>举例说明：假如1个虚拟用户在1秒内完成1笔事务，那么TPS明显就是1。如果某笔业务响应时间是1 ms，那么1个虚拟用户在1s内能完成1000笔事务，TPS就是1000了；如果某笔业务响应时间是1s，那么1个虚拟用户在1s内只能完成1笔事务，要想达到1000 TPS，就需要1000个虚拟用户。因此可以说1个虚拟用户可以产生1000 TPS，1000个虚拟用户也可以产生1000 TPS，无非是看响应时间快慢。</p><p>如何获取VU和TPS</p><ul><li>VU获取方式：</li></ul><p>已有系统：可选取高峰时刻，在一定时间内使用系统的人数，这些人数可认为是在线用户数，并发用户数可以取10%，例如在半个小时内，使用系统的用户数为10万，那么取10%（即1万）作为并发用户数基本就够了。</p><ul><li>TPS获取方式：</li></ul><p>已有系统：可选取高峰时刻，在一定时间内（如3分钟<del>10分钟），获取系统总业务量，计算单位时间（秒）内完成的笔数，乘以2</del>5倍作为峰值的TPS，例如峰值3分钟内处理订单18万笔，平均TPS是1000，峰值TPS可以是2000~5000。</p><p>Apache JMeter是Apache组织开发的基于Java的压力测试工具。Apache JMeter具备如下特性：</p><ul><li><p>支持分布式施压。</p></li><li><p>支持图形化界面，且支持流程编排，同时支持断言、逻辑控制器等高级指令，可满足复杂业务压测需求。</p></li><li><p>扩展性强，开发、测试人员可通过编写自己的插件，满足各种压测需求。</p></li><li><p>技术生态好，有强大的开源社区支持，开发者活跃度高。<br>支持查看资源监控、性能报告，但可查看的监控和报告指标较少。</p></li><li><p>基于并发模型，受限于JVM，单机无法支持超高并发。且只支持并发施压模型，不支持吞吐量施压模型。</p></li><li><p>开源支持的分布式能力无法大规模应用到生产环境，部署成本高。</p></li><li><p>不支持测试用例管理、压测脚本管理等功能。</p></li></ul><p>Jmeter介绍</p><p>JMeter 是 Apache 组织开发的一个开源的性能测试工具，主要用于对Web应用进行功能测试和性能测试。它最初是为了进行软件性能测试而设计的，但随着时间的发展，它的功能已经扩展到可以支持多种协议的测试，包括 HTTP、HTTPS、FTP、JDBC、JMS、SMTP 等。</p><p>主要特性如下：</p><ul><li><p>多协议支持： JMeter 可以用来测试各种协议的应用程序，这使得它成为一个非常灵活的工具，适用于多种场景。</p></li><li><p>负载测试和压力测试： 它能够模拟大量用户并发访问，用于评估系统的性能和稳定性。这对于识别系统瓶颈和优化系统至关重要。</p></li><li><p>可扩展性： 通过插件和脚本，JMeter 可以扩展其功能，以适应更复杂的应用环境和测试需求。</p></li><li><p>结果分析： JMeter 提供了丰富的图表和报告功能，帮助用户直观地理解测试结果，包括响应时间、吞吐量、错误率等关键指标。</p></li><li><p>脚本录制与回放： 使用 JMeter 的代理服务器功能，可以轻松地记录用户的浏览器操作，生成测试脚本，然后进行自动化测试。</p></li><li><p>分布式测试： 支持在多台机器上进行分布式测试，从而模拟更大的负载，测试大规模并发情况下的系统表现。</p></li><li><p>跨平台： JMeter 是基于 Java 编写的，因此可以在任何安装了Java运行环境的平台上运行。</p></li><li><p>免费开源： 作为 Apache 项目的一部分，JMeter 是完全免费且开源的，这意味着用户不仅可以使用它，还可以修改和扩展其功能。</p></li><li><p>社区支持： 拥有活跃的开发者和用户社区，提供持续的支持和更新，以及大量的教程和资源。</p></li><li><p>易于学习和使用： 尽管功能强大，但 JMeter 的界面直观，对于初学者来说相对容易上手。</p></li></ul><p>下载Jmeter</p><p>访问 Jmeter 官网：<a href="https://jmeter.apache.org/download_jmeter.cgi">https://jmeter.apache.org/download_jmeter.cgi</a> ，如下图所示，下载页中提供了各个系统的压缩包，这里是 Windows 系统，点击下载 .zip 后缀的压缩包。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122211442998.png" alt="Loading"></p><p>下载完成后，右键解压，无需安装即可使用。</p><p>启动Jmeter</p><p>进入 &#x2F;bin 文件夹下，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122211702631.png" alt="Loading"></p><ul><li><p>Windows 系统，双击 jmeter.bat 启动 Jmeter;</p></li><li><p>Linux、Mac 系统，进入到 &#x2F;bin 文件夹下，执行如下命令启动：</p></li></ul><p><code>sh jmeter.sh</code></p><p>主题修改</p><p>启动成功后，界面如下图所示，默认是暗黑主题，若想修改主题，点击 Options | Look and Feel, 有多种主题可供选择</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122211934808.png" alt="Loading"></p><p>如果喜欢明亮主题，勾选 Metal 即可，然后重启即可应用最新的设置。</p><p>语言设置<br>Jmeter 默认的语言是英文，如果想修改为中文，有两种方式。</p><p>临时设置<br>一种是临时性的设置，点击菜单 Options | Choose Lanuage | Chinese（Simplified）, 即可设置为简体中文。这种方式有个弊端，当重新打开 Jmeter 后，设置就会失效，必须得重新设置。</p><p>永久设置<br>要想永久设置 Jmeter 的语言为中文，可进入到 &#x2F;bin 目录下，找到 jmeter.properties 配置文件：<br>编辑它，将语言设置项的注释放开，并修改为 zh-CN 。</p><p>Jmeter 压测 K-V 存储服务接口</p><p>在测试计划上 右键 | 添加 | 线程 | 线程组</p><p>解释一下线程组的作用：</p><ul><li><p>模拟用户行为： 线程组用于模拟多个用户同时访问服务器或应用程序。每个线程代表一个虚拟用户。</p></li><li><p>控制并发数： 线程组允许你指定同时运行的线程数量，即虚拟用户的数量。这有助于模拟不同级别的并发负载，从而评估系统的性能和稳定性。</p></li><li><p>设置循环次数： 在线程组中，你可以设置采样器的执行次数。这意味着每个虚拟用户将按照设定的次数重复执行相同的请求序列，这对于长时间的压力测试尤其有用。</p></li></ul><p>线程组添加完成后，为了能够发送 HTTP 请求，还需要在线程组上右键 | 添加 | 取样器 | HTTP 请求</p><p>为了能够查看请求接口响应结果，在 HTTP 请求上 右键 | 添加 | 监听器 | 查看结果树</p><p>以上都配置完成后，一个简单的 GET 请求就配置好了。</p><p>请求结果可以点击 响应数据 | Response Body 来查看</p><p>POST 请求</p><p>为了能够发送 application&#x2F;json 请求，还需要为 HTTP 请求右键 | 添加 | 配置元件 | HTTP 信息头管理器</p><p>添加一个请求头，Key 值为 Content-Type , Value 值为 application&#x2F;json</p><p>点击 HTTP 请求，为其添加请求入参，点击消息体数据，填写接口的 JSON 入参</p><p>运行测试之前，可以对查看结果树 右键 | 清除 ， 把之前跑测试的结果全部删除</p><p>压测接口：笔记内容新增</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122212506419.png" alt="Loading"></p><p>压测接口：笔记内容查询</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122212600873.png" alt="Loading"></p><p>Jmeter 线程组间传递 Token</p><p>通过 Jmeter 测试接口时，有些接口需要先认证，才能够请求成功的，此时就需要在请求头中设置 Token 令牌。虽然测试的时候，如下图所示，可以编辑 HTTP 信息头管理器，来写死一个 Token 令牌来达到目的。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122212719681.jpg" alt="Loading"></p><p>新增线程组：用户登录接口</p><p>在测试计划上右键，新增一个线程组，并创建用户登录接口的 HTTP 请求。</p><p>禁用线程组</p><p>我们可以在不想要运行的线程组上右键 | 禁用，以禁止执行该线程组。</p><p>JSON 提取器</p><p>为了能够提取出返参中的 Token 令牌，需要对 HTTP 请求右键 | 添加 | 后置处理器 | JSON 提取器。</p><p>调试后置处理器</p><p>为了能够调试 Token 令牌是否提取成功了，可以对 HTTP 请求右键 | 添加 | 后置处理器 | Debug PostProcessor 。</p><p>BeanShell 后置处理器</p><p>为了能够实现跨线程组传递 Token 令牌，需要在 HTTP 请求右键 | 添加 | 后置处理器 | BeanShell PostProcessor。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cassandra安装与使用</title>
    <link href="/2025/01/22/Cassandra%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/01/22/Cassandra%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Cassandra"><a href="#什么是-Cassandra" class="headerlink" title="什么是 Cassandra ?"></a>什么是 Cassandra ?</h1><p>Apache Cassandra 是一个开源的分布式 NoSQL（Not Only SQL）数据库管理系统，专为处理大规模数据量和高写入频率的工作负载而设计。它最初由 Facebook 开发，后来贡献给了 Apache 软件基金会，成为了 Apache 的一个顶级项目。</p><p>Cassandra 结合了 Google Bigtable 的数据模型和 Amazon Dynamo 的完全分布式架构，提供了以下关键特性：</p><ul><li><p>高可用性：Cassandra 是一个无单点故障的系统，它通过数据复制和一致性级别选择，确保即使在节点失败的情况下数据仍然可访问。</p></li><li><p>水平可扩展性：Cassandra 能够通过添加更多节点到集群中轻松扩展，无需停机，这使得它能够处理不断增长的数据量和用户负载。</p></li><li><p>分布式数据存储：数据在集群中的多个节点上分布存储，每个节点都是平等的，没有主从之分，这有助于提高性能和可靠性。</p></li><li><p>最终一致性：Cassandra 允许开发者选择数据的一致性和可用性之间的权衡，通过可配置的一致性级别，可以在强一致性和高可用性之间找到合适的平衡点。</p></li><li><p>数据模型：Cassandra 使用列族（column-family）的数据模型，允许以宽列的方式存储数据，非常适合存储半结构化或非结构化数据。</p></li><li><p>数据压缩和索引：Cassandra 支持数据压缩和创建二级索引，以提高存储效率和查询性能。</p></li><li><p>多数据中心复制：Cassandra 支持跨多个地理区域的数据中心复制，以实现数据的地理分布和灾难恢复。</p></li></ul><p>Cassandra 被广泛应用于需要处理大量数据和高写入负载的场景，例如社交网络、物联网（IoT）、实时数据分析和推荐系统等。由于其强大的可扩展性和高可用性，Cassandra 成为了许多大型企业如 Netflix、Digg、Twitter 等的选择。</p><h2 id="Cassandra安装"><a href="#Cassandra安装" class="headerlink" title="Cassandra安装"></a>Cassandra安装</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>执行如下命令，开始拉取 <code>cassandra</code> 最新的镜像。</p><p><code>docker pull cassandra:latest</code></p><p>拉取成功后，可执行 <code>docker images</code> 命令查看本地已下载的镜像，确认一下 <code>cassandra</code> 是否下载成功。</p><h3 id="准备挂载的文件夹"><a href="#准备挂载的文件夹" class="headerlink" title="准备挂载的文件夹"></a>准备挂载的文件夹</h3><p>在 <code>E:/docker</code> 路径下，创建一个 <code>/cassandra</code> 文件夹，用于等会启动容器时，将需要持久化的数据挂载到宿主机中，防止容器重启时数据丢失。</p><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p>前置工作完成后，执行如下命令，运行一个 <code>cassandra</code> 容器：</p><p><code>docker run --name cassandra -d -p 9042:9042 -v E:\docker\cassandra\data:/var/lib/cassandra cassandra:latest</code></p><p>各参数含义：</p><ul><li><p><code>docker run</code>: 这是 Docker 用来启动一个新的容器的命令。</p></li><li><p><code>--name cassandra</code>: 这个选项指定了容器的名称为 “cassandra”。给容器命名可以帮助你在将来更容易地识别和管理它。</p></li><li><p><code>-d</code>: 这个标志表示在后台（守护进程模式）运行容器，不会阻塞你的终端会话。</p></li><li><p><code>-p 9042:9042</code>: 这个选项进行了端口映射，将宿主机的 9042 端口映射到容器内的 9042 端口。这意味着你可以在宿主机上通过 9042 端口访问 Cassandra 容器提供的服务。Cassandra 默认使用 9042 端口作为 CQL shell 的接入点。</p></li><li><p><code>-v E:\docker\cassandra\data:/var/lib/cassandra</code>: 这是一个卷（volume）映射，将宿主机上的目录 <code>E:\docker\cassandra\data</code> 挂载到容器内的 <code>/var/lib/cassandra</code> 目录。这个目录是 Cassandra 用来存储数据和日志的地方。通过这种方式，即使容器被删除，数据也会保留在宿主机上，因为数据存储在持久化的卷中。</p></li><li><p><code>cassandra:latest</code>: 这指定了要使用的 Docker 镜像。在这里，镜像是 Cassandra 的官方镜像，并且使用了 latest 标签，意味着拉取 Cassandra 的最新版本镜像。</p></li></ul><p>执行完毕后，执行 <code>docker ps</code> 命令，可查看本地正在运行中的 <code>Docker</code> 容器，确认一下 <code>cassandra</code> 是否启动成功了。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122202326486.png" alt="Loading"></p><h2 id="Cassandra使用"><a href="#Cassandra使用" class="headerlink" title="Cassandra使用"></a>Cassandra使用</h2><ol><li>打开cqlsh命令行</li></ol><p>cassandra 容器运行成功后，执行如下命令，可进入到容器中：</p><p><code>docker exec -it cassandra /bin/sh</code></p><p>接着，执行如下命令，可打开 cqlsh 命令行工具：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">cqlsh</span><br>或<br>cqlsh <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">9042</span><br></code></pre></td></tr></table></figure><p>什么是 cqlsh ?</p><p>cqlsh 是 Cassandra Query Language Shell 的缩写，它是一个命令行工具，允许你向 Cassandra 数据库发送查询、创建表、插入数据、检索数据等。</p><p>若如下图所示，提示 Connected to Test Cluster at 127.0.0.1:9042 , 则说明已经成功连接上了 cassandra。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122202537481.png" alt="Loading" title="cassandra"></p><h2 id="CQL基本命令"><a href="#CQL基本命令" class="headerlink" title="CQL基本命令"></a>CQL基本命令</h2><p>Cassandra 基本概念<br>在学习 CQL 命令之前，先理解一下 Cassandra 中几个基本概念：</p><ul><li><p>节点（Node）：Cassandra 集群中的每个服务器称为一个节点。每个节点都存储数据，并且相互之间没有主从关系，所有节点都是对等的。</p></li><li><p>集群（Cluster）：由多个节点组成的分布式系统称为集群。集群中的节点共同工作，处理读写请求并存储数据。</p></li><li><p>数据中心（Data Center）：集群中的节点可以分布在多个数据中心，每个数据中心包含若干个节点。数据中心的划分有助于实现跨地域的高可用性。</p></li><li><p>键空间（Keyspace）：键空间是一个逻辑容器，用于管理多个表，可以理解为 MySQL 中的库。另外，键空间定义了数据复制的策略。<br>表（Table）：表是数据存储的基本单位，由行和列组成。每张表都有一个唯一的名称和定义。</p></li><li><p>主键（Primary Key）：每行数据都有一个唯一的主键。主键由分区键和可选的列组成，用于唯一标识数据行。</p></li><li><p>分区键（Partition Key）：Cassandra 使用分区键的哈希值将数据分布到不同的节点上，从而实现负载均衡和数据的水平扩展。分区键可以是单个列或多列的组合（复合分区键）。</p></li></ul><ol><li>键空间（Keyspace）</li></ol><p>打开 cqlsh 命令行，执行下面语句，来创建一个 <code>Keyspace</code>。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">KEYSPACE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> test<br><span class="hljs-keyword">WITH</span> replication = &#123;<span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;SimpleStrategy&#x27;</span>, <span class="hljs-string">&#x27;replication_factor&#x27;</span>: <span class="hljs-number">1</span>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>CREATE KEYSPACE IF NOT EXISTS</code>: 这是创建 keyspace 的命令，<code>IF NOT EXISTS</code> 是一个条件语句，确保只有当 keyspace 还未创建时才执行创建操作。这样可以防止重复创建 keyspace 导致的错误。</p></li><li><p><code>test</code>: 这是即将创建的 keyspace 的名称。keyspace 类似于传统关系型数据库中的“数据库”，是 Cassandra 中数据的最高层级容器。</p></li><li><p><code>WITH replication</code>: 这里指定了 keyspace 的复制策略和配置。复制策略决定了数据如何在集群中复制和分布。</p></li><li><p><code>&#39;class&#39;: &#39;SimpleStrategy&#39;</code>: 这里指定了复制策略的类型为 <code>SimpleStrategy</code>。<code>SimpleStrategy</code> 是一种基本的复制策略，适用于单数据中心的部署。它将数据均匀地分布到集群中的节点上。</p></li><li><p><code>&#39;replication_factor&#39;</code>: 1: 这是复制因子，表示每个数据分区的副本数量。在这个例子中，<code>replication_factor</code> 设置为 1，意味着每个数据分区只有一个副本，这通常用于测试或开发环境，但在生产环境中可能不是最佳实践，因为缺乏冗余会导致数据丢失的风险增加。</p></li></ul><ol start="2"><li>键空间创建完成后，执行如下命令，可查看所有的 <code>Keyspace</code>。</li></ol><p><code>DESCRIBE KEYSPACES;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122203134492.png" alt="Loading"></p><ol start="3"><li>如果想删除某个键空间，以及其中的所有数据，可执行如下语句。</li></ol><p><code>DROP KEYSPACE IF EXISTS test;</code></p><ol start="4"><li>键空间创建完成后，可通过 USE 命令，选择该 Keyspace ，以便后续操作它。</li></ol><p><code> USE test;</code></p><ol start="5"><li>执行如下语句，创建一张 <code>note_content</code> 笔记内容表。这里注意，由于我们是拿 Cassandra 充当 K-V 键值存储数据库，所以表中只包含两个字段（实际可以支持多字段），<code>id</code> 主键充当 <code>Key</code> , 笔记内容 <code>content</code> 充当 <code>Value</code> :</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE TABLE</span> note_content (<br>    id UUID <span class="hljs-keyword">PRIMARY KEY</span>,<br>    content TEXT<br>);<br></code></pre></td></tr></table></figure><ul><li><p><code>CREATE TABLE</code>: 这是 Cassandra 中创建新表的命令。</p></li><li><p><code>note_content</code>: 表的名称。</p></li><li><p><code>(</code> 和 <code>)</code>：这些括号包含了表的列定义和主键定义。</p></li><li><p><code>id UUID PRIMARY KEY</code>: 这里定义了表中的一个列 <code>id</code>，其数据类型是 <code>UUID</code>（通用唯一标识符）。<code>PRIMARY KEY</code> 指示 id 列是表的主键。在 Cassandra 中，主键用于唯一标识表中的每一行，同时也是数据在集群中分区的依据。</p></li><li><p><code>content TEXT</code>: 这里定义了另一个列 content，其数据类型是 TEXT。TEXT 类型用于存储文本字符串。</p></li></ul><p>为什么这里要用 UUID? 而不是笔记本身的 ID?</p><p>UUID 生成的值具有较高的随机性，因此在集群中可以提供良好的数据分布，避免热点问题。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122203548357.png" alt="Loading"></p><ol start="6"><li>执行如下语句，查询 <code>note_content</code> 表中所有数据。</li></ol><p><code>SELECT * FROM note_content;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122203650219.png" alt="Loading"></p><ol start="7"><li>笔记内容表创建完成后，执行如下语句，插入一条数据。</li></ol><p><code>INSERT INTO note_content (id, content) VALUES (uuid(), &#39;这是一条测试笔记&#39;);</code></p><ol start="8"><li>执行如下语句，以 id 为条件来更新对应笔记内容。</li></ol><p><code>UPDATE note_content SET content = &#39;更新后的评论内容&#39; WHERE id = 7e1c4af6-9b12-4f89-a5d1-0e05f8a627c7;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122203905346.png" alt="Loading"></p><ol start="9"><li>执行如下语句，将 id 为 7e1c4af6-9b12-4f89-a5d1-0e05f8a627c7 的记录删除掉。</li></ol><p><code>DELETE FROM note_content WHERE id = 7e1c4af6-9b12-4f89-a5d1-0e05f8a627c7;</code></p><p>![Loading](<a href="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122204050982.png">https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122204050982.png</a> “)</p>]]></content>
    
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Cassandra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenFeign组件</title>
    <link href="/2025/01/22/OpenFeign%E7%BB%84%E4%BB%B6/"/>
    <url>/2025/01/22/OpenFeign%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-OpenFeign"><a href="#什么是-OpenFeign" class="headerlink" title="什么是 OpenFeign ?"></a>什么是 OpenFeign ?</h1><p>OpenFeign 是一个声明式的 HTTP 客户端，它使得我们可以非常方便地调用 HTTP 接口。OpenFeign 是 Netflix 开源的 Feign 项目的扩展，旨在与 Spring Cloud 紧密集成。它通过注解来定义接口，类似于 Spring MVC 的控制器，使得开发者可以专注于业务逻辑，而不需要关注 HTTP 请求的具体实现。</p><h2 id="OpenFeign-使用"><a href="#OpenFeign-使用" class="headerlink" title="OpenFeign 使用"></a>OpenFeign 使用</h2><ol><li>添加OpenFeign依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- OpenFeign --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 负载均衡 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>TIP : <code>OpenFeign</code> 通常和 <code>loadbalancer</code> 接口负载均衡组件搭配使用。</p><ol start="2"><li>声明 FeignClient 客户端接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = ApiConstants.SERVICE_NAME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FileFeignApi</span> &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/file&quot;</span>;<br><br>    <span class="hljs-meta">@PostMapping(value = PREFIX + &quot;/test&quot;)</span><br>    Response&lt;?&gt; test();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注：</p><ul><li><code>@FeignClient</code> 是用来标记这个接口是一个 Feign 客户端的注解。<ul><li><code>name = ApiConstants.SERVICE_NAME</code> 指定了这个 Feign 客户端所调用的服务名称。这个名称通常是在注册中心（如 Eureka 或 Nacos）中注册的服务名称。</li></ul></li><li><code>String PREFIX = &quot;/file&quot;</code> : 定义了一个前缀常量，用于接口中 URI 的路径前缀。</li><li><code>@PostMapping</code> 注解标记这个方法将执行一个 HTTP POST 请求。<ul><li><code>value = PREFIX + &quot;/test&quot;</code> 指定了这个 POST 请求的路径，这里是 <code>&quot;/file/test&quot;</code>。</li></ul></li></ul><p>2.1 创建 <code>ApiConstants</code> 常量类，定义一个服务名称常量，即本身注册到 Nacos 中的服务名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiConstants</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">SERVICE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xiaohashu-oss&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，对象存储服务就将 <code>/file/test</code> 接口的 <code>Feign</code> 客户端，封装到 <code>api</code> 模块中了，有其他服务想要调用对象存储服务的 <code>/file/test</code> 接口，只需引入 <code>xiaohashu-oss-api</code> 模块即可。</p><ol start="3"><li>启用Feign客户端<br>编辑 <code>XiaohashuUserBizApplication</code> 启动类，添加 <code>@EnableFeignClients</code> 注解，以启用引入的 <code>xiaohashu-oss-api</code> 模块中定义好的 <code>Feign</code> 客户端。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;com.quanxiaoha.xiaohashu&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaohashuUserBizApplication</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>服务间调用<br>以上工作完成后，就可以在用户服务中，注入 <code>FileFeignApi</code> 客户端，来调用对象存储服务的 <code>/file/test</code> 接口了。</li></ol><h2 id="OpenFeign-支持表单请求"><a href="#OpenFeign-支持表单请求" class="headerlink" title="OpenFeign 支持表单请求"></a>OpenFeign 支持表单请求</h2><p>针对于图片上传，普通的调用方式还不行，需要额外配置表单提交。</p><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Feign 表单提交 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign.form<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-form<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="feign-form-依赖是干嘛的？"><a href="#feign-form-依赖是干嘛的？" class="headerlink" title="feign-form 依赖是干嘛的？"></a>feign-form 依赖是干嘛的？</h3><p><code>feign-form</code> 是一个 Feign 扩展库，专门用于处理表单数据的编码。它提供了一些增强功能，使 Feign 客户端能够更方便地处理表单提交和文件上传等操作。</p><p>表单配置类<br>新建一个 <code>FeignFormConfig</code>表单配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignFormConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Encoder <span class="hljs-title function_">feignFormEncoder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringFormEncoder</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>SpringFormEncoder</code> 是 Feign 提供的一个编码器，用于处理表单提交。它将对象编码为表单数据格式（如 <code>application/x-www-form-urlencoded</code> 或 <code>multipart/form-data</code>），以便在 HTTP 请求中使用。</li></ul><h2 id="封装-Feign-调用"><a href="#封装-Feign-调用" class="headerlink" title="封装 Feign 调用"></a>封装 Feign 调用</h2><p>创建一个 <code>/rpc</code> 包，统一放置服务间调用代码，并新建 <code>OssRpcService</code> 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OssRpcService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> FileFeignApi fileFeignApi;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">uploadFile</span><span class="hljs-params">(MultipartFile file)</span> &#123;<br>        <span class="hljs-comment">// 调用对象存储服务上传文件</span><br>        Response&lt;?&gt; response = fileFeignApi.uploadFile(file);<br><br>        <span class="hljs-keyword">if</span> (!response.isSuccess()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回图片访问链接</span><br>        <span class="hljs-keyword">return</span> (String) response.getData();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将调用对象存储服务上传文件的逻辑，单独封装一层 <code>service</code>，并声明一个 <code>uploadFile()</code> 方法。方法中，若调用对象存储服务成功，则返回图片链接；否则，返回 <code>null</code> 。</p><h2 id="Feign-请求拦截器：实现-userId-服务间透传"><a href="#Feign-请求拦截器：实现-userId-服务间透传" class="headerlink" title="Feign 请求拦截器：实现 userId 服务间透传"></a>Feign 请求拦截器：实现 userId 服务间透传</h2><p>如果说，我们想在下游服务中获取当前请求对应的用户 ID , 比如，修改用户信息接口，会调用对象存储微服务，在对象存储微服务中，通过前面封装的上下文组件获取当前用户 ID，能拿的到吗？</p><p>为什么获取不到？</p><p>原因是网关路由转发到服务时，网关层会设置用户 ID 到请求头中，但是，服务之间调用是通过 <code>Feign</code> 来完成的，是没有经过网关的，下游服务再去从请求头中获取用户 ID，自然是拿不到。</p><p>如何解决上面这个问题呢？</p><p>可以为 <code>Feign</code> 单独配置一个请求拦截器，在调用其他服务时，将当前用户 ID 添加到请求头中，保证下游服务也能够通过上下文组件拿到用户 ID。</p><ol><li>配置 Feign 请求拦截器<br>将这个功能，一并放到上下文组件中。首先，编辑 <code>xiaoha-spring-boot-starter-biz-context</code> 上下文组件的 <code>pom.xml</code>, 添加 <code>feign</code> 核心依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上下文组件中，创建一个 <code>/interceptor</code> 包，用于放置拦截器，并新建 <code>FeignRequestInterceptor</code> 请求拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignRequestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RequestInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(RequestTemplate requestTemplate)</span> &#123;<br>        <span class="hljs-comment">// 获取当前上下文中的用户 ID</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> LoginUserContextHolder.getUserId();<br><br>        <span class="hljs-comment">// 若不为空，则添加到请求头中</span><br>        <span class="hljs-keyword">if</span> (Objects.nonNull(userId)) &#123;<br>            requestTemplate.header(GlobalConstants.USER_ID, String.valueOf(userId));<br>            log.info(<span class="hljs-string">&quot;########## feign 请求设置请求头 userId: &#123;&#125;&quot;</span>, userId);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>自定义 <code>Feign</code> 请求拦截器需继承自 <code>RequestInterceptor</code> 接口；</p></li><li><p>在 <code>apply()</code> 方法中，先通过 <code>LoginUserContextHolder.getUserId()</code>; 拿到当前请求对应的用户 ID;</p></li><li><p>判断若不为空，则将用户 ID 添加到请求头中，以便下游服务再次获取；</p></li></ul><ol start="2"><li>自动化配置</li></ol><p>在 <code>/config</code> 包下，新建一个 <code>FeignContextAutoConfiguration</code> 自动化配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfiguration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignContextAutoConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FeignRequestInterceptor <span class="hljs-title function_">feignRequestInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FeignRequestInterceptor</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将刚刚自定义的 <code>FeignRequestInterceptor</code> 请求拦截器，自动注入到 Spring 容器中。</li></ul><p>同时，别忘了在 <code>org.springframework.autoconfigure.AutoConfiguration.imports</code> 文件中，添加上 <code>FeignContextAutoConfiguration</code> 的完整包路径。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>OpenFeign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云OSS</title>
    <link href="/2025/01/22/%E9%98%BF%E9%87%8C%E4%BA%91OSS/"/>
    <url>/2025/01/22/%E9%98%BF%E9%87%8C%E4%BA%91OSS/</url>
    
    <content type="html"><![CDATA[<ol><li>开通服务<br>需要登录阿里云官网，并访问对象存储 OSS 产品首页：<a href="https://www.aliyun.com/product/oss">https://www.aliyun.com/product/oss</a> ，如下图所示，点击立即开通按钮，开通服务<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122170737048.png" alt="Loading" title="Aliyun OSS"><br>开通成功后，进入到对象存储 OSS 控制台， 点击 Bucket 列表，在 Bucket 列表中，点击上方的创建 Bucket 按钮，准备创建桶，填写 Bucket 相关配置项，如下：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122170900224.png" alt="Loading" title="配置"></li></ol><ul><li>模式选择：勾选自定义创建；</li><li>Bucket 名称： </li><li>地域：推荐选择离你产品使用者较近的地方，有助于提升访问速度。</li><li>阻止公共访问：关闭掉，并将读写权限修改为公共读；</li></ul><ol start="2"><li>获取 AccessKey 接入凭证<br>通过代码上传文件到 Bucket ，阿里云需要校验你的身份，还需要获取一下接入凭证。点击回到阿里云首页，将鼠标移动到登录用户的头像上，即可看到 AccessKey 选项，点击即可查看<br>将你的 AccessKeyID 以及 AccessKey Secret 复制出来</li></ol><p>编辑模块的 application-dev.yml 开发环境配置，修改一下 minio 配置项的结构，统一放置到 storage 节点下，方便统一维护。再额外加一下阿里云 OSS 需要用到的配置项，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#=================================================================</span><br><span class="hljs-comment"># 对象存储配置</span><br><span class="hljs-comment">#=================================================================</span><br><span class="hljs-attr">storage:</span><br>  <span class="hljs-attr">minio:</span><br>    <span class="hljs-attr">endpoint:</span> <span class="hljs-string">http://127.0.0.1:9000</span><br>    <span class="hljs-attr">accessKey:</span> <span class="hljs-string">xxx</span><br>    <span class="hljs-attr">secretKey:</span> <span class="hljs-string">xxx</span><br>  <span class="hljs-attr">aliyun-oss:</span><br>    <span class="hljs-attr">endpoint:</span> <span class="hljs-string">oss-cn-hangzhou.aliyuncs.com</span> <span class="hljs-comment"># 改成你自己的</span><br>    <span class="hljs-attr">accessKey:</span> <span class="hljs-string">xxx</span> <span class="hljs-comment"># 改成你自己的</span><br>    <span class="hljs-attr">secretKey:</span> <span class="hljs-string">xxx</span> <span class="hljs-comment"># 改成你自己的</span><br></code></pre></td></tr></table></figure><ol start="3"><li>添加阿里云OSS配置类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;storage.aliyun-oss&quot;)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunOSSProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> String endpoint;<br>    <span class="hljs-keyword">private</span> String accessKey;<br>    <span class="hljs-keyword">private</span> String secretKey;<br>&#125;```<br><br>添加依赖<br>```java<br> &lt;!-- 阿里云 OSS --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;<br>            &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;<br>            &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;javax.activation&lt;/groupId&gt;<br>            &lt;artifactId&gt;activation&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        &lt;!-- no more than <span class="hljs-number">2.3</span><span class="hljs-number">.3</span>--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;<br>            &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>阿里云配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunOSSConfig</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> AliyunOSSProperties aliyunOSSProperties;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构建 阿里云 OSS 客户端</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> OSS <span class="hljs-title function_">aliyunOSSClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 设置访问凭证</span><br>        <span class="hljs-type">DefaultCredentialProvider</span> <span class="hljs-variable">credentialsProvider</span> <span class="hljs-operator">=</span> CredentialsProviderFactory.newDefaultCredentialProvider(<br>                aliyunOSSProperties.getAccessKey(), aliyunOSSProperties.getSecretKey());<br><br>        <span class="hljs-comment">// 创建 OSSClient 实例</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClientBuilder</span>().build(aliyunOSSProperties.getEndpoint(), credentialsProvider);<br>    &#125;<br>&#125;```<br><br>阿里云策略实现类<br>```java<br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunOSSFileStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FileStrategy</span>  &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> AliyunOSSProperties aliyunOSSProperties;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> OSS ossClient;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">uploadFile</span><span class="hljs-params">(MultipartFile file, String bucketName)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;## 上传文件至阿里云 OSS ...&quot;</span>);<br><br>        <span class="hljs-comment">// 判断文件是否为空</span><br>        <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">null</span> || file.getSize() == <span class="hljs-number">0</span>) &#123;<br>            log.error(<span class="hljs-string">&quot;==&gt; 上传文件异常：文件大小为空 ...&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;文件大小不能为空&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 文件的原始名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFileName</span> <span class="hljs-operator">=</span> file.getOriginalFilename();<br><br>        <span class="hljs-comment">// 生成存储对象的名称（将 UUID 字符串中的 - 替换成空字符串）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString().replace(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// 获取文件的后缀，如 .jpg</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">suffix</span> <span class="hljs-operator">=</span> originalFileName.substring(originalFileName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><br>        <span class="hljs-comment">// 拼接上文件后缀，即为要存储的文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">objectName</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s%s&quot;</span>, key, suffix);<br><br>        log.info(<span class="hljs-string">&quot;==&gt; 开始上传文件至阿里云 OSS, ObjectName: &#123;&#125;&quot;</span>, objectName);<br><br>        <span class="hljs-comment">// 上传文件至阿里云 OSS</span><br>        ossClient.putObject(bucketName, objectName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(file.getInputStream().readAllBytes()));<br><br>        <span class="hljs-comment">// 返回文件的访问链接</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;https://%s.%s/%s&quot;</span>, bucketName, aliyunOSSProperties.getEndpoint(), objectName);<br>        log.info(<span class="hljs-string">&quot;==&gt; 上传文件至阿里云 OSS 成功，访问路径: &#123;&#125;&quot;</span>, url);<br>        <span class="hljs-keyword">return</span> url;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minio对象存储</title>
    <link href="/2025/01/22/Minio%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"/>
    <url>/2025/01/22/Minio%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<ol><li><p>什么是 MinIO？<br>MinIO 是一个开源的对象存储服务器。这意味着它允许你在互联网上存储大量数据，比如文件、图片、视频等，而不需要依赖传统的文件系统。MinIO 的特点在于它非常灵活、易于使用，同时也非常强大，可以在你的应用程序中方便地集成。</p></li><li><p>为什么使用 MinIO？</p></li></ol><ul><li><p>可伸缩性和性能： MinIO 允许你在需要时轻松地扩展存储容量，无需中断服务。它具有出色的性能，可以处理大量的并发读取和写入请求。</p></li><li><p>开源和自由： MinIO 是开源软件，遵循 Apache License 2.0 许可证，这意味着你可以自由地使用、修改和分发它。</p></li><li><p>容器化部署： MinIO 提供了容器化部署的支持，可以在各种平台上快速部署和运行，包括本地开发机、云服务器和容器编排环境（如 Docker）。</p></li><li><p>兼容性： MinIO 提供了 S3 兼容的 API，这意味着它可以与任何兼容 Amazon S3 的应用程序无缝集成，为你的应用程序提供强大的对象存储能力。</p></li><li><p>易用性： MinIO 的配置和管理非常简单，它提供了直观的Web控制台和命令行工具，帮助你方便地管理存储桶和对象。</p></li></ul><p>总的来说，MinIO 是一个灵活、高性能、易用且开源的对象存储解决方案，适用于各种规模的应用程序，特别是那些需要大规模数据存储和访问的项目。</p><ol start="3"><li>Docker搭建Minio服务<br>3.1 选择一个 Minio 镜像<br>然后，我们在浏览器中访问地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a> ， 输入关键词 minio&#x2F;minio, 找到 Minio 镜像：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122164023293.png" alt="Loading" title="Minio"></li></ol><p>点击进去，点击 Tags 标签选项，选择最新的一个发行版本：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122164100224.png" alt="Loading" title="Tags"></p><p>3.2 下载Minio镜像<br>打开命令行，执行该命令拉取镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull minio/minio:RELEASE.2023-09-30T07-02-29Z<br></code></pre></td></tr></table></figure><p>镜像下载成功后，执行 <code>docker images</code> , 如果列表中有 <code>minio/minio</code> 镜像，则表示镜像下载成功了：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122164239816.png" alt="Loading" title="images"></p><p>3.3 新建数据挂载目录<br>下载镜像成功后，我们在某个盘下，新建一个 &#x2F;docker 文件夹，然后在该文件夹中再新建一个 &#x2F;minio 文件夹。<br>新建该文件夹的目的是，后面通过镜像运行 Minio 容器时，可以将容器内的数据目录，挂载到宿主机的 E:\docker\minio 目录下，防止容器重启后，会导致数据丢失的问题。</p><p>3.4 运行 Docker Minio 容器<br>通过该镜像运行 <code>Minio</code> 容器，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d \<br>   -p 9000:9000 \<br>   -p 9090:9090 \<br>   --name minio \<br>   -v E:\docker\minio\data:/data \<br>   -e <span class="hljs-string">&quot;MINIO_ROOT_USER=xxx&quot;</span> \<br>   -e <span class="hljs-string">&quot;MINIO_ROOT_PASSWORD=xxx&quot;</span> \<br>   minio/minio:RELEASE.2023-09-30T07-02-29Z server /data --console-address <span class="hljs-string">&quot;:9090&quot;</span><br></code></pre></td></tr></table></figure><p>命令选型含义：</p><ul><li><code>docker run</code>: 运行 Docker 容器的命令。</li><li><code>-d</code> : 表示后台运行该容器；</li><li><code>-p 9000:9000</code>: 将宿主机的 9000 端口映射到容器的 9000 端口。MinIO 默认的 HTTP API 端口是 9000。</li><li><code>-p 9090:9090</code>: 将宿主机的 9090 端口映射到容器的 9090 端口。这是 MinIO 的 Web 控制台的端口。</li><li><code>--name minio</code>: 给容器取了一个名字，这里是 “minio”。</li><li><code>-v E:\docker\minio\data:/data</code>: 将宿主机上的 <code>E:\docker\minio\data</code> 目录映射到容器内的 <code>/data</code>目录。这是 MinIO 存储数据的地方。如果你希望数据在容器删除后仍然保存，可以将数据目录映射到宿主机。</li><li><code>-e &quot;MINIO_ROOT_USER=xxx&quot;</code>: 设置 MinIO 的管理员用户名为 “xxx”。这是用于 MinIO Web 控制台和 API 的初始管理员用户名。</li><li><code>-e &quot;MINIO_ROOT_PASSWORD=xxx&quot;</code>: 设置 MinIO 的管理员密码为 “xxx”。这是用于 MinIO Web 控制台和 API 的初始管理员密码。</li><li><code>minio/minio:RELEASE.2023-09-30T07-02-29Z</code>: 这是 MinIO 的 Docker 镜像版本。</li><li><code>server /data --console-address &quot;:9090&quot;</code>: 启动 MinIO 服务器，并将数据存储在容器内的<code>/data</code>目录。</li><li><code>--console-address &quot;:9090&quot;</code>表示 MinIO 的Web 控制台将在容器的 9090 端口上运行。</li></ul><p>执行该命令后，再执行 <code>docker ps</code> 命令，可查看正在运行的容器，若如下图所示，容器列表中出现了 <code>minio</code> ，则表示 <code>Minio</code> 后台运行成功了：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122164239344.png" alt="Loading" title="Minio"></p><ol start="4"><li><p>访问Minio控制台<br>浏览器访问地址 <a href="http://localhost:9090/">http://localhost:9090</a> ，可访问 MinIO 的 Web 控制台：<br>输入运行容器时，指定的用户名&#x2F;密码：xxx&#x2F;xxx , 进入到 Minio 的管理后台:<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122165043436.png" alt="Loading" title="后台页面"></p></li><li><p>新建一个Bucket桶<br>进入后台后，点击 Create a Bucket 创建一个 Bucket 桶，用于存储图片。<br>输入 Bucket Name, 我们将其命名为 xxx， 然后点击 Create Bucket 按钮，创建成功后，在 Buckets 列表中就可以看到刚刚新建的桶了：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122165043436.png" alt="Loading" title="创建Bucket"></p></li><li><p>设置 Bucket 为公共读<br>因为我们上传的图片需要被公网访问到，所以，还需要设置 Bucket 为公共读，默认为 Private 私有。点击想要设置的桶，然后编辑 Access Policy,将 Access Policy 选项选择为 Public 公共读，点击 Set 设置按钮,设置成功后，就可以看到 Access Policy 一栏变更为 Public 了，如下图所示:<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122165205868.png" alt="Loading"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Minio</tag>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos使用</title>
    <link href="/2025/01/22/Nacos%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/01/22/Nacos%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Nacos简介"><a href="#Nacos简介" class="headerlink" title="Nacos简介"></a>Nacos简介</h1><p>Nacos &#x2F;nɑ:kəʊs&#x2F; 是 Dynamic Naming and Configuration Service 的首字母简称，它是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p><p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p><p>Nacos主要特性：</p><ul><li><p>服务发现和服务健康检测。</p></li><li><p>动态配置服务。</p></li><li><p>动态DNS服务。</p></li><li><p>服务及其元数据管理。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122151352461.jpg" alt="Loading" title="Nacos地图"></p><h1 id="安装Nacos"><a href="#安装Nacos" class="headerlink" title="安装Nacos"></a>安装Nacos</h1><ol><li>安装包安装</li></ol><ul><li><p>Nacos 依赖 Java 环境来运行，所以，需要确保你的机器上已经安装好了 JDK 1.8+ 版本。</p></li><li><p>浏览器访问地址：<a href="https://nacos.io/download/release-history/">https://nacos.io/download/release-history/</a> ，找到 2.2.3 版本，点击并下载对应版本的安装包：</p></li><li><p>下载完成后，解压到某个文件夹下，然后进入 &#x2F;bin 目录下，打开终端：</p></li><li><p>在终端中，运行如下启动命令 ( standalone 代表着单机模式运行，非集群模式) :</p></li></ul><p><code>./startup.cmd -m standalone</code></p><ul><li>浏览器访问地址：<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> ，即可进入到 Nacos 的控制后台。</li></ul><ol start="2"><li>Docker安装Nacos</li></ol><ul><li><p>在拉取 Nacos 镜像之前，在 E:\docker 文件夹下，创建一个 &#x2F;nacos 文件夹，等会运行容器时，用于将 Nacos 容器中的配置文件、持久化文件挂载出来，防止容器重启时数据丢失的问题。</p></li><li><p>那么，下载 2.2.3 版本的 Nacos 镜像，运行命令如下：</p></li></ul><p><code>docker pull nacos/nacos-server:v2.2.3</code></p><ul><li>执行完成后，执行如下命令，查看本地已下载的镜像列表，确认一下镜像是否下载成功了：</li></ul><p><code>docker images</code></p><ul><li>镜像下载成功后，运行如下命令，运行一个 Nacos 容器：</li></ul><p><code>docker run -d --name nacos --env MODE=standalone -p 8848:8848 -p 9848:9848 nacos/nacos-server:v2.2.3</code></p><ul><li><p>命令执行完毕后，通过 docker ps 命令查看一下正在运行中的 Docker 容器，确认一下容器是否正常跑起来了。</p></li><li><p>浏览器访问地址：<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> ，即可进入到 Nacos 的控制后台。</p></li><li><p>Nacos 容器跑起来后，我们将容器中的配置文件，以及数据文件复制到宿主机中。</p></li></ul><p><code>docker cp nacos:/home/nacos/conf E:\docker\nacos</code></p><p><code>docker cp nacos:/home/nacos/data E:\docker\nacos</code></p><ul><li>最后，执行如下命令，强制删除正在运行中的 Nacos 容器：</li></ul><p><code>docker rm -f nacos</code></p><ul><li>重新跑一个正式的 Nacos 容器，运行命令如下：</li></ul><p><code>docker run -d --name nacos --privileged -e MODE=standalone -e JVM_XMX=300m -e JVM_XMS=300m -p 8848:8848 -p 9848:9848  -v E:\docker\nacos\conf:/home/nacos/conf -v E:\docker\nacos\data:/home/nacos/data -v E:\docker\nacos\logs:/home/nacos/logs nacos/nacos-server:v2.2.3</code></p><h2 id="整合-Nacos-配置中心：实现动态配置刷新"><a href="#整合-Nacos-配置中心：实现动态配置刷新" class="headerlink" title="整合 Nacos 配置中心：实现动态配置刷新"></a>整合 Nacos 配置中心：实现动态配置刷新</h2><p>什么是配置中心？</p><p>在微服务架构下，配置中心是一个专门用来集中管理和分发配置的服务。它通过提供统一的接口，帮助开发人员将所有微服务的配置项集中存储、管理和分发，确保微服务在不同环境下（如开发、测试、生产环境）能够方便地获取到对应的配置。</p><p>为什么需要配置中心？</p><ol><li><p>集中管理，简化运维： 在传统的单体应用中，配置项通常存储在本地文件中，管理和维护相对简单。但在微服务架构下，配置项分散在多个服务中，如果每个服务都单独管理自己的配置项，会导致管理复杂性增加。配置中心通过集中管理配置项，极大简化了运维工作。</p></li><li><p>环境隔离，配置灵活： 不同的环境（开发、测试、生产等）通常需要不同的配置项。配置中心支持按环境隔离配置项，使得相同的微服务在不同环境中可以方便地获取对应的配置，而无需手动修改配置文件。</p></li><li><p>动态更新，实时生效： 在业务需求变化较快的场景中，配置项的频繁修改是常态。配置中心支持配置项的动态更新和实时生效，减少了服务重启的次数，提高了系统的可用性和灵活性。</p></li><li><p>安全管理： 某些敏感配置项（如数据库密码、API 密钥等）不适合写在代码中或本地文件中。配置中心提供了安全的存储和访问机制，确保敏感信息的安全性。</p></li><li><p>统一监控，提升稳定性： 配置中心可以对所有配置项进行统一监控和管理，方便运维人员及时发现和处理配置问题，提升系统的稳定性和可靠性。</p></li></ol><p>使用Nacos配置中心</p><p>进入 Nacos 管理后台，创建配置</p><p>浏览器访问： <a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> ， 进入到 Nacos 控制台，点击创建配置按钮。</p><p>填写相关配置项：</p><p>①：Data Id : 配置的唯一标识，这里我们填写；</p><p>②：Group: 所属组，这里默认组即可；</p><p>③：配置格式：项目中使用的 YAML 格式配置， 这里也选择 YAML;</p><p>④：配置内容，将限流阈值配置复制进去；</p><p>⑤：点击发布按钮；</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122154510679.png" alt="Loading" title="创建配置"></p><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Nacos 配置中心 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>nacos-config-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.3.0-RC<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：版本 0.2.x.RELEASE 对应的是 Spring Boot 2.x 版本，版本 0.1.x.RELEASE 对应的是 Spring Boot 1.x 版本。我们是 Spring Boot 3.x, 故使用最新的 0.3.x 版本。</p><h2 id="项目配置Nacos"><a href="#项目配置Nacos" class="headerlink" title="项目配置Nacos"></a>项目配置Nacos</h2><p>依赖添加完毕后，编辑 applicaiton.yml 文件，准备添加 Nacos 相关配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">nacos:</span> <br>  <span class="hljs-attr">config:</span> <span class="hljs-comment"># Nacos 配置中心</span><br>    <span class="hljs-attr">access-key:</span> <span class="hljs-comment"># 身份验证</span><br>    <span class="hljs-attr">secret-key:</span> <span class="hljs-comment"># 身份验证</span><br>    <span class="hljs-attr">data-id:</span> <span class="hljs-string">xxx</span> <span class="hljs-comment"># 指定要加载的配置数据的 Data Id</span><br>    <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span> <span class="hljs-comment"># 指定配置数据所属的组</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 指定配置数据的格式</span><br>    <span class="hljs-attr">server-addr:</span> <span class="hljs-string">http://127.0.0.1:8848/</span> <span class="hljs-comment"># 指定 Nacos 配置中心的服务器地址</span><br>    <span class="hljs-attr">auto-refresh:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否自动刷新配置</span><br>    <span class="hljs-attr">remote-first:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否优先使用远程配置</span><br>    <span class="hljs-attr">bootstrap:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 启动时，预热配置</span><br></code></pre></td></tr></table></figure><h2 id="Nacos配置中心：动态加载Bean"><a href="#Nacos配置中心：动态加载Bean" class="headerlink" title="Nacos配置中心：动态加载Bean"></a>Nacos配置中心：动态加载Bean</h2><p>当系统发送异常时，需要给开发发送告警信息，提示开发速度修复系统问题。告警的形式可以是发送短信，也可以是发送邮件。至于具体使用哪种方式， 支持通过修改 Nacos 配置中心中的配置项来动态控制。</p><p>自定义配置</p><p>编辑 application.yml 文件，自定义一个告警类型的配置：<br>sms : 表示短信告警；<br>mail : 表示邮件告警；</p><p>添加Nacos配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">xxx</span> <span class="hljs-comment"># 应用名称</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 默认激活 dev 本地开发环境</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">http://127.0.0.1:8848</span> <span class="hljs-comment"># 指定 Nacos 配置中心的服务器地址</span><br>        <span class="hljs-attr">prefix:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span> <span class="hljs-comment"># 配置 Data Id 前缀，这里使用应用名称作为前缀</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span> <span class="hljs-comment"># 所属组</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">public</span> <span class="hljs-comment"># 命名空间</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 配置文件格式</span><br>        <span class="hljs-attr">refresh-enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否开启动态刷新</span><br></code></pre></td></tr></table></figure><p>使用<code>@RefreshScope</code> 注解<br>这个注解是干嘛的？</p><p>@RefreshScope 注解是 Spring Cloud 提供的一个注解，用于实现配置动态刷新功能。当配置中心的配置发生变化时，标注了 @RefreshScope 的 Bean 会重新加载最新的配置，而无需重启应用。</p><p>在 Nacos 配置中心的场景下，@RefreshScope 的主要功能包括：</p><ul><li><p>动态刷新配置：当 Nacos 配置中心的配置发生变化时，应用中的配置会自动更新，避免了手动重启应用的繁琐过程。</p></li><li><p>重新加载 Bean：标注了 @RefreshScope 的 Bean 会在配置变化后重新加载，确保 Bean 使用最新的配置。</p></li><li><p>与 Spring Cloud 集成：@RefreshScope 与 Spring Cloud 的配置管理机制紧密集成，能够无缝地处理配置更新事件。</p></li></ul><h2 id="Nacos命名空间应用：项目隔离"><a href="#Nacos命名空间应用：项目隔离" class="headerlink" title="Nacos命名空间应用：项目隔离"></a>Nacos命名空间应用：项目隔离</h2><p>命名空间（Namespace）是 Nacos 提供的一种逻辑隔离手段，用于对配置和服务进行分组和隔离。在 Nacos 中，命名空间通常被用于做业务隔离。</p><p>什么是业务隔离？<br>不同业务线的配置和服务可以放在不同的命名空间中，方便管理和维护。</p><p>创建命名空间</p><p>进入到 Nacos 管理后台：<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> ：点击命名空间菜单，点击新建命名空间按钮：</p><p>填写命名空间相关配置项，如下图所示：</p><p>①：命名空间 ID： 可不填，不填的话，会自动生成一长串的唯一 ID , 这里为了方便识别，手动填写；</p><p>②：命名空间名称：也可以写中文，这里填项目的拼音；</p><p>③：描述：命名空间描述性文字；</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122154611418.png" alt="Loading" title="创建命名空间"></p><h2 id="克隆配置"><a href="#克隆配置" class="headerlink" title="克隆配置"></a>克隆配置</h2><p>创建完成后，进入到配置管理 | 配置列表，在上方会发现除了 public 外，多出了一个咱们刚刚创建的 xxx 命名空间，选择该命名空间，会发现该命名空间下，还没有任何配置：<br>将 public 命名空间下的所有配置勾选，点击克隆，选择目标空间 | 开始克隆 ， 即可将 public 空间下的配置，一键复制到 xxx 命名空间下：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122154705649.png" alt="Loading" title="克隆配置"></p><h2 id="服务注册：将认证服务注册到-Nacos-上"><a href="#服务注册：将认证服务注册到-Nacos-上" class="headerlink" title="服务注册：将认证服务注册到 Nacos 上"></a>服务注册：将认证服务注册到 Nacos 上</h2><p>在微服务架构中，服务注册是一种机制，用于将服务实例的信息（如地址、端口、健康状态等）注册到服务注册中心。服务实例启动时，会向注册中心登记自己的信息，停止时则注销。</p><p>它的作用如下：</p><ul><li><p>提供服务元数据：注册中心保存了所有服务实例的元数据，供其他服务或负载均衡器查询。</p></li><li><p>健康检查：注册中心通常会定期检查注册的服务实例的健康状况，以确保它们可用并将不可用的实例从注册列表中移除。</p></li></ul><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 服务注册发现 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-string">//</span> <span class="hljs-string">省略</span> <span class="hljs-string">...</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br> <span class="hljs-string">//</span> <span class="hljs-string">省略...</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 启用服务发现</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span> <span class="hljs-comment"># 所属组</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">xxx#</span> <span class="hljs-string">命名空间</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># 指定 Nacos 配置中心的服务器地址</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RBAC权限设计模型</title>
    <link href="/2025/01/22/RBAC%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/01/22/RBAC%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-RBAC-模型？"><a href="#什么是-RBAC-模型？" class="headerlink" title="什么是 RBAC 模型？"></a>什么是 RBAC 模型？</h1><p>RBAC（Role-Based Access Control）是一种基于角色的访问控制。它通过角色来管理用户的权限。RBAC 的核心思想是将用户与角色进行关联，并将权限分配给角色，而不是直接分配给用户。这样，通过改变用户的角色，就可以灵活地控制用户的权限。<br>RBAC 的主要组成部分包括：<br>    - 用户（User）：系统的使用者。</p><pre><code class="hljs">- 角色（Role）：权限的集合，一个角色可以包含多个权限。- 权限（Permission）：对系统资源的访问操作，如读取、写入、删除等。</code></pre><h2 id="模型扩展"><a href="#模型扩展" class="headerlink" title="模型扩展"></a>模型扩展</h2><h3 id="RBAC0"><a href="#RBAC0" class="headerlink" title="RBAC0"></a>RBAC0</h3><p>即上面所讲的 RBAC 模型，基于用户-角色-权限的模型。</p><h3 id="RBAC1：基于角色的层次模型（Role-Hierarchies）"><a href="#RBAC1：基于角色的层次模型（Role-Hierarchies）" class="headerlink" title="RBAC1：基于角色的层次模型（Role Hierarchies）"></a>RBAC1：基于角色的层次模型（Role Hierarchies）</h3><p>RBAC 1 在 RBAC 0 的基础上增加了角色层次结构（Role Hierarchies）。角色层次结构允许角色之间存在继承关系，一个角色可以继承另一个角色的权限。</p><p>主要特点：</p><ul><li><p>角色继承：一个角色可以继承另一个角色的所有权限。比如，角色B继承角色 A 的权限，那么角色 B 不仅拥有自己定义的权限，还拥有角色 A 的所有权限。</p></li><li><p>权限传递：继承关系是传递的，如果角色 C 继承角色 B，而角色 B 继承角色 A，那么角色 C 将拥有角色 A 和角色 B 的所有权限。</p></li></ul><p>优点：</p><ul><li><p>简化权限管理：通过角色继承，可以减少重复定义权限的工作。</p></li><li><p>提高灵活性：可以方便地对角色进行分层管理，满足不同层次用户的权限需求。</p></li></ul><h3 id="RBAC2：基于约束的-RBAC-模型（Constraints）"><a href="#RBAC2：基于约束的-RBAC-模型（Constraints）" class="headerlink" title="RBAC2：基于约束的 RBAC 模型（Constraints）"></a>RBAC2：基于约束的 RBAC 模型（Constraints）</h3><p>RBAC 2 同样建立在 RBAC 0 基础之上，但是增加了约束（Constraints）。约束是用于加强访问控制策略的规则或条件，可以限制用户、角色和权限的关联方式。</p><p>主要特点：</p><ul><li><p>互斥角色：某些角色不能同时赋予同一个用户。例如，审计员和财务员角色不能同时赋予同一个用户，以避免暗黑交易。</p></li><li><p>先决条件：用户要获得某个角色，必须先拥有另一个角色。例如，公司研发人员要成为高级程序员，必须先成为中级程序员。</p></li><li><p>基数约束：限制某个角色可以被赋予的用户数量。例如，某个项目的经理角色只能赋予一个用户，以确保项目的唯一责任人。</p></li></ul><p>优点：</p><ul><li><p>加强安全性：通过约束规则，可以避免权限滥用和利益冲突。</p></li><li><p>精细化管理：可以更精细地控制用户的角色分配和权限管理。</p></li></ul><h3 id="RBAC3-统一模型（Consolidated-Model）"><a href="#RBAC3-统一模型（Consolidated-Model）" class="headerlink" title="RBAC3: 统一模型（Consolidated Model）"></a>RBAC3: 统一模型（Consolidated Model）</h3><p>RBAC 3 是最全面的 RBAC 模型，它结合了 RBAC1 的角色层次结构和 RBAC2 的约束，形成一个统一的模型，提供了最大程度的灵活性和安全性。</p><p>主要特点：</p><ul><li><p>包含RBAC 1的所有功能：角色层次结构，角色继承和权限传递。</p></li><li><p>包含RBAC 2的所有功能：互斥角色、先决条件角色和角色卡数限制等约束规则。</p></li><li><p>综合管理：可以同时利用角色继承和约束规则，提供最全面的权限管理解决方案。</p></li></ul><p>优点：</p><ul><li>高灵活性：可以满足各种复杂的权限管理需求。</li></ul><p>-高安全性：通过约束规则，进一步加强权限管理的安全性。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>设计思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SaToken使用</title>
    <link href="/2025/01/22/SaToken%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/01/22/SaToken%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ol><li>什么是SaToken？</li></ol><p>Sa-Token是一个轻量级Java权限认证框架，官网地址：<a href="https://sa-token.cc/">https://sa-token.cc/</a> ，主要解决：登录认证、权限认证、单点登录、OAuth2.0、分布式Session会话、微服务网关鉴权 等一系列权限相关问题。</p><ol start="2"><li>SaToken功能</li></ol><p>Sa-Token目前主要五大功能模块：登录认证、权限认证、单点登录、OAuth2.0、微服务鉴权。<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122132955471.png" alt="Loading" title="SaToken结构图"></p><ol start="3"><li>使用配置</li></ol><p>在<code>pom.xml</code>文件引入对应依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Sa-Token 权限认证，在线文档：https://sa-token.cc --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.dev33<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sa-token-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.39.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在application.yml中填写相关配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">############## Sa-Token 配置 (文档: https://sa-token.cc) ##############<br>sa-token:<br>  # token 名称（同时也是 cookie 名称）<br>  token-name: satoken<br>  # token 有效期（单位：秒） 默认30天，-1 代表永久有效<br>  timeout: 2592000<br>  # token 最低活跃频率（单位：秒），如果 token 超过此时间没有访问系统就会被冻结，默认-1 代表不限制，永不冻结<br>  active-timeout: -1<br>  # 是否允许同一账号多地同时登录 （为 true 时允许一起登录, 为 false 时新登录挤掉旧登录）<br>  is-concurrent: true<br>  # 在多人登录同一账号时，是否共用一个 token （为 true 时所有登录共用一个 token, 为 false 时每次登录新建一个 token）<br>  is-share: true<br>  # token 风格（默认可取值：uuid、simple-uuid、random-32、random-64、random-128、tik）<br>  token-style: uuid<br>  # 是否输出操作日志<br>  is-log: true<br></code></pre></td></tr></table></figure><ol start="4"><li>自定义 Token 生成风格与请求格式</li></ol><p>在 SaToken 中，Token 风格可以通过<code> sa-token.token-style</code> 配置项来定制，默认的生成策略是 uuid 风格，值类似于 <code>623368f0-ae5e-4475-a53f-93e4225f16ae</code></p><p>SaToken 内置支持的风格有多种，大致如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">/</span> <span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=uuid</span>    <span class="hljs-string">——</span> <span class="hljs-string">uuid风格</span> <span class="hljs-string">(默认风格)</span><br><span class="hljs-string">&quot;623368f0-ae5e-4475-a53f-93e4225f16ae&quot;</span><br><br><span class="hljs-string">//</span> <span class="hljs-number">2</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=simple-uuid</span>    <span class="hljs-string">——</span> <span class="hljs-string">同上，uuid风格,</span> <span class="hljs-string">只不过去掉了中划线</span><br><span class="hljs-string">&quot;6fd4221395024b5f87edd34bc3258ee8&quot;</span><br><br><span class="hljs-string">//</span> <span class="hljs-number">3</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=random-32</span>    <span class="hljs-string">——</span> <span class="hljs-string">随机32位字符串</span><br><span class="hljs-string">&quot;qEjyPsEA1Bkc9dr8YP6okFr5umCZNR6W&quot;</span><br><br><span class="hljs-string">//</span> <span class="hljs-number">4</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=random-64</span>    <span class="hljs-string">——</span> <span class="hljs-string">随机64位字符串</span><br><span class="hljs-string">&quot;v4ueNLEpPwMtmOPMBtOOeIQsvP8z9gkMgIVibTUVjkrNrlfra5CGwQkViDjO8jcc&quot;</span><br><br><span class="hljs-string">//</span> <span class="hljs-number">5</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=random-128</span>    <span class="hljs-string">——</span> <span class="hljs-string">随机128位字符串</span><br><span class="hljs-string">&quot;nojYPmcEtrFEaN0Otpssa8I8jpk8FO53UcMZkCP9qyoHaDbKS6dxoRPky9c6QlftQ0pdzxRGXsKZmUSrPeZBOD6kJFfmfgiRyUmYWcj4WU4SSP2ilakWN1HYnIuX0Olj&quot;</span><br><br><span class="hljs-string">//</span> <span class="hljs-number">6</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=tik</span>    <span class="hljs-string">——</span> <span class="hljs-string">tik风格</span><br><span class="hljs-string">&quot;gr_SwoIN0MC1ewxHX_vfCW3BothWDZMMtx__&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>自定义Token请求风格</li></ol><p>比较通用、规范的 Token 请求格式：<br><code>Authorization = Bearer + 空格 + 令牌值</code></p><p>修改SaToken配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sa-token:</span><br>  <span class="hljs-comment"># token 名称（同时也是 cookie 名称）</span><br>  <span class="hljs-attr">token-name:</span> <span class="hljs-string">Authorization</span><br>  <span class="hljs-comment"># token前缀</span><br>  <span class="hljs-attr">token-prefix:</span> <span class="hljs-string">Bearer</span><br></code></pre></td></tr></table></figure><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>在我们已经将 SaToken 权限认证框架整合进了项目。但是有个问题，当调用 <code>TestController</code> 中的登录接口 <code>/user/doLogin?username=zhang&amp;password=123456</code> ，登录成功后再重启项目，调用 <code>/user/isLogin</code> 接口，验证一下用户是否登录的时候，会发现登录已经失效了。</p><h2 id="登录失效的原因？"><a href="#登录失效的原因？" class="headerlink" title="登录失效的原因？"></a>登录失效的原因？</h2><p>Sa-Token 默认将数据保存在内存中，此模式读写速度最快，且避免了序列化与反序列化带来的性能消耗，但是此模式也有一些缺点，比如：</p><ul><li><p>重启后数据会丢失。</p></li><li><p>无法在分布式环境中共享数据。</p></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为此，Sa-Token 提供了扩展接口，你可以轻松将会话数据存储在一些专业的缓存中间件上（比如 Redis）， 做到重启数据不丢失，而且保证分布式环境下多节点的会话一致性。</p><p>项目<code>pom.xml</code>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-comment">&lt;!-- Sa-Token 整合 Redis （使用 jackson 序列化方式） --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.dev33<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sa-token-redis-jackson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;sa-token.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Sa-Token 整合 Redis （使用 jackson 序列化方式） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.dev33<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sa-token-redis-jackson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Redis 连接池 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github搭建个人图床</title>
    <link href="/2025/01/21/Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/"/>
    <url>/2025/01/21/Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="一、创建新的个人仓库"><a href="#一、创建新的个人仓库" class="headerlink" title="一、创建新的个人仓库"></a>一、创建新的个人仓库</h1><p>在Github中创建新的仓库，确保仓库为public，其他保持默认即可</p><h1 id="二、上传图片"><a href="#二、上传图片" class="headerlink" title="二、上传图片"></a>二、上传图片</h1><p>通过传统方式向Github上传图片比较麻烦，此处使用PicGO来进行图片上传。</p><h2 id="PicGO图片上传配置"><a href="#PicGO图片上传配置" class="headerlink" title="PicGO图片上传配置"></a>PicGO图片上传配置</h2><ol><li><p>在Github创建token，打开Settings -&gt; Developer settings -&gt; Personal access tokens，选择classic方式创建，最后点击 generate new token；<br> 填写相关信息时，勾选repo。<br> 注：token生成只会生成一次，需要自行记录备用。</p></li><li><p>配置PicGO。打开 图床设置 -&gt; Github 图床</p></li></ol><p><img src="https://github.com/Bloomivy/pic/blob/main/image-1.png?raw=true" alt="Loading" title="GitHub设置"></p><p>可能存在的问题：上传图片时报错：You must be logged in to use issue<br>解决方式：注册sm.ms账号，创建token，将token填入PicGO配置即可正常上传。</p><p><img src="https://github.com/Bloomivy/pic/blob/main/image-2.png?raw=true" alt="Loading" title="sm"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>差分数组</title>
    <link href="/2025/01/21/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    <url>/2025/01/21/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。<br>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 差分数组工具类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Difference</span> &#123;<br>    <span class="hljs-comment">// 差分数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] diff;<br>    <br>    <span class="hljs-comment">// 输入一个初始数组，区间操作将在这个数组上进行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Difference</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">assert</span> nums.length &gt; <span class="hljs-number">0</span>;<br>        diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-comment">// 根据初始数组构造差分数组</span><br>        diff[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            diff[i] = nums[i] - nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 给闭区间 [i, j] 增加 val（可以是负数）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> val)</span> &#123;<br>        diff[i] += val;<br>        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; diff.length) &#123;<br>            diff[j + <span class="hljs-number">1</span>] -= val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回结果数组</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] result() &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[diff.length];<br>        <span class="hljs-comment">// 根据差分数组构造结果数组</span><br>        res[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; diff.length; i++) &#123;<br>            res[i] = res[i - <span class="hljs-number">1</span>] + diff[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>差分数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和数组</title>
    <link href="/2025/01/21/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <url>/2025/01/21/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一维数组前缀和"><a href="#一维数组前缀和" class="headerlink" title="一维数组前缀和"></a>一维数组前缀和</h1><p>LeetCode 303.区域和检索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>    <span class="hljs-comment">// 前缀和数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] preSum;<br><br>    <span class="hljs-comment">// 输入一个数组，构造前缀和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// preSum[0] = 0，便于计算累加和</span><br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 计算 nums 的累加和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; preSum.length; i++) &#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 查询闭区间 [left, right] 的累加和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> preSum[right + <span class="hljs-number">1</span>] - preSum[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="矩阵前缀和"><a href="#矩阵前缀和" class="headerlink" title="矩阵前缀和"></a>矩阵前缀和</h1><p>LeetCode 304.二位区域和检索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br>    <span class="hljs-comment">// preSum[i][j] 记录矩阵 [0, 0, i-1, j-1] 的元素和</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] preSum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 构造前缀和矩阵</span><br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-comment">// 计算每个矩阵 [0, 0, i, j] 的元素和</span><br>                preSum[i][j] = preSum[i-<span class="hljs-number">1</span>][j] + preSum[i][j-<span class="hljs-number">1</span>] + matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - preSum[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算子矩阵 [x1, y1, x2, y2] 的元素和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span> &#123;<br>        <span class="hljs-comment">// 目标矩阵之和由四个相邻矩阵运算获得</span><br>        <span class="hljs-keyword">return</span> preSum[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] - preSum[x1][y2+<span class="hljs-number">1</span>] - preSum[x2+<span class="hljs-number">1</span>][y1] + preSum[x1][y1];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结-前缀和核心代码"><a href="#总结-前缀和核心代码" class="headerlink" title="总结 前缀和核心代码"></a>总结 前缀和核心代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrefixSum</span> &#123;<br>    <span class="hljs-comment">// 前缀和数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] preSum;<br><br>    <span class="hljs-comment">// 输入一个数组，构造前缀和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrefixSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// preSum[0] = 0，便于计算累加和</span><br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 计算 nums 的累加和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; preSum.length; i++) &#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 查询闭区间 [left, right] 的累加和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> preSum[right + <span class="hljs-number">1</span>] - preSum[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git相关</title>
    <link href="/2025/01/20/Git%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/01/20/Git%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h1><h1 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h1><h2 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h2><h3 id="本地创建"><a href="#本地创建" class="headerlink" title="本地创建"></a>本地创建</h3><p>在需要创建仓库的地方执行指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> demo<br><span class="hljs-built_in">cd</span> demo<br></code></pre></td></tr></table></figure><p>初始化Git仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><p>执行指令 ls -a，控制台显示.git目录。<br>进入.git目录下，执行ls -altr查看到以下文件。<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122111103994.png" alt="Loading" title="命令回显"></p><h3 id="远程获取"><a href="#远程获取" class="headerlink" title="远程获取"></a>远程获取</h3><p>使用git clone 命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/git/git.git<br></code></pre></td></tr></table></figure><h2 id="Git工作区域和文件状态"><a href="#Git工作区域和文件状态" class="headerlink" title="Git工作区域和文件状态"></a>Git工作区域和文件状态</h2><p>Git主要存在三种区域。<br>在.git目录层即为工作区，通常在这一层编写代码。<br>代码编写完成后使用 git add 命令提交，提交到暂存区。<br>在暂存区的代码使用 git commit 提交到本地仓库。</p><p>Git中文件的几种状态</p><ul><li>untrack </li><li>unmodified</li><li>modified</li><li>committed<br><img src="https://github.com/Bloomivy/pic/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_21-1-2025_9212_www.bilibili.com.jpeg?raw=true" alt="Loading" title="Git文件四种状态"></li></ul><h2 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h2><p> git status 查看当前状态。<br> git add 将文件添加到暂存区，等待后续操作。<br> git commit 提交暂存区中的文件，并不提交工作区中的文件。可以使用 -m 指定提交的信息。如果不使用-m参数，git会自动进入一个交互式界面，默认使用nano编辑。<br> git log 命令查看提交记录。可以使用 – online 查看简洁的提交信息，只显示作者和提交时间。</p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>git reset </p><ul><li>git reset –soft：回退到上一个版本时，工作区和暂存区都不清空。</li><li>git reset –hard：回退到上一个版本时，工作区和暂存区会清空。</li><li>git reset –mixed：回退到上一个版本时，清空暂存区，不清空工作区。</li><li>git reflog：查看所有操作及对应的版本号，便于进行回退。</li></ul><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>git diff，默认比较工作区和暂存区的内容。<br>git diff commit，比较工作区和指定提交版本的区别。<br>git diff cached commit，比较暂存区与指定提交版本区别。<br>git diff commit1 commit2，比较两个提交的版本区别。</p><h2 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h2><p>应该忽略哪些文件：</p><ul><li>系统或软件自动生成的代码。</li><li>编译产生的中间文件和结果文件。</li><li>运行时生成的日志文件、缓存文件和临时文件。</li><li>涉及敏感信息的文件。</li></ul><h2 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h2><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>git branch xx 创建新的分支。<br>git checkout xx 切换到不同分支上。也可以用于恢复文件，存在歧义，默认切换分支。<br>git switch xx 切换不同分支。<br>git merge xx 合并分支到当前位置。</p><p>切换分支时，工作区也会随之变化。</p><h2 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h2><p>两个分支如果存在对同一文件进行不同修改，此时会发生冲突。<br>可以使用 git diff 命令查看冲突的具体内容。<br>手动修改文件再提交即可。</p><h2 id="回退和rebase"><a href="#回退和rebase" class="headerlink" title="回退和rebase"></a>回退和rebase</h2><ul><li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li><li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分搜索</title>
    <link href="/2025/01/20/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    <url>/2025/01/20/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找框架"><a href="#二分查找框架" class="headerlink" title="二分查找框架"></a>二分查找框架</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = ...;<br><br>    <span class="hljs-keyword">while</span>(...) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            ...<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = ...<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = ...<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ...;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。计算 mid 时需要防止溢出，代码中 left + (right - left) &#x2F; 2 就和 (left + right) &#x2F; 2 的结果相同，但是有效防止了 left 和 right 太大，直接相加导致溢出的情况。</p><h1 id="寻找一个数"><a href="#寻找一个数" class="headerlink" title="寻找一个数"></a>寻找一个数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 标准的二分搜索框架，搜索目标元素的索引，若不存在则返回 -1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 注意</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;   <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                <span class="hljs-comment">// 注意</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                <span class="hljs-comment">// 注意</span><br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个算法存在局限性。<br>比如说给你有序数组 nums &#x3D; [1,2,2,2,3]，target 为 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。</p><p>为什么while中left&lt;&#x3D;right，而不是&lt;？<br>因为right初始化为nums.length-1而不是nums.length。</p><h1 id="寻找左侧边界的二分搜索"><a href="#寻找左侧边界的二分搜索" class="headerlink" title="寻找左侧边界的二分搜索"></a>寻找左侧边界的二分搜索</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">left_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 注意</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>    <br>    <span class="hljs-comment">// 注意</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            <span class="hljs-comment">// 注意</span><br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用双闭区间的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">left_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 搜索区间为 [left, right]</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            <span class="hljs-comment">// 搜索区间变为 [mid+1, right]</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            <span class="hljs-comment">// 搜索区间变为 [left, mid-1]</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 收缩右侧边界</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 判断 target 是否存在于 nums 中</span><br>    <span class="hljs-comment">// 如果越界，target 肯定不存在，返回 -1</span><br>    <span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">0</span> || left &gt;= nums.length) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 判断一下 nums[left] 是不是 target</span><br>    <span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="寻找右侧边界的二分查找"><a href="#寻找右侧边界的二分查找" class="headerlink" title="寻找右侧边界的二分查找"></a>寻找右侧边界的二分查找</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">right_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 注意</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 注意</span><br>    <span class="hljs-keyword">return</span> left - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用双闭区间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">right_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 这里改成收缩左侧边界即可</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后改成返回 right</span><br>    <span class="hljs-keyword">if</span> (right &lt; <span class="hljs-number">0</span> || right &gt;= nums.length) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[right] == target ? right : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="逻辑统一"><a href="#逻辑统一" class="headerlink" title="逻辑统一"></a>逻辑统一</h1><ul><li>基本的二分查找</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">因为我们初始化 right = nums.length - 1<br>所以决定了我们的「搜索区间」是 [left, right]<br>所以决定了 <span class="hljs-keyword">while</span> (left &lt;= right)<br>同时也决定了 left = mid+1 和 right = mid-1<br><br>因为我们只需找到一个 target 的索引即可<br>所以当 nums[mid] == target 时可以立即返回<br></code></pre></td></tr></table></figure><ul><li>查找左侧边界的二分查找</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">因为我们初始化 right = nums.length<br>所以决定了我们的「搜索区间」是 [left, right)<br>所以决定了 <span class="hljs-keyword">while</span> (left &lt; right)<br>同时也决定了 left = mid + 1 和 right = mid<br><br>因为我们需找到 target 的最左侧索引<br>所以当 nums[mid] == target 时不要立即返回<br>而要收紧右侧边界以锁定左侧边界<br></code></pre></td></tr></table></figure><ul><li>查找右侧边界的二分查找</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">因为我们初始化 right = nums.length<br>所以决定了我们的「搜索区间」是 [left, right)<br>所以决定了 <span class="hljs-keyword">while</span> (left &lt; right)<br>同时也决定了 left = mid + 1 和 right = mid<br><br>因为我们需找到 target 的最右侧索引<br>所以当 nums[mid] == target 时不要立即返回<br>而要收紧左侧边界以锁定右侧边界<br><br>又因为收紧左侧边界时必须 left = mid + 1<br>所以最后无论返回 left 还是 right，必须减一<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2025/01/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2025/01/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口框架"><a href="#滑动窗口框架" class="headerlink" title="滑动窗口框架"></a>滑动窗口框架</h1><p>滑动窗口就是简单维护一个窗口，不断滑动，然后更新答案，代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (right &lt; nums.size()) &#123;<br>    <span class="hljs-comment">// 增大窗口</span><br>    window.addLast(nums[right]);<br>    right++;<br>    <br>    <span class="hljs-keyword">while</span> (window needs shrink) &#123;<br>        <span class="hljs-comment">// 缩小窗口</span><br>        window.removeFirst(nums[left]);<br>        left++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>滑动窗口的伪框架实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 滑动窗口算法伪码框架</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">slidingWindow</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">// 用合适的数据结构记录窗口中的数据，根据具体场景变通</span><br>    <span class="hljs-comment">// 比如说，我想记录窗口中元素出现的次数，就用 map</span><br>    <span class="hljs-comment">// 如果我想记录窗口中的元素和，就可以只用一个 int</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">window</span> <span class="hljs-operator">=</span> ...<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>        <span class="hljs-comment">// c 是将移入窗口的字符</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s[right];<br>        window.add(c)<br>        <span class="hljs-comment">// 增大窗口</span><br>        right++;<br>        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>        ...<br><br>        <span class="hljs-comment">// *** debug 输出的位置 ***</span><br>        <span class="hljs-comment">// 注意在最终的解法代码中不要 print</span><br>        <span class="hljs-comment">// 因为 IO 操作很耗时，可能导致超时</span><br>        printf(<span class="hljs-string">&quot;window: [%d, %d)\n&quot;</span>, left, right);<br>        <span class="hljs-comment">// ***********************</span><br><br>        <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; window needs shrink) &#123;<br>            <span class="hljs-comment">// d 是将移出窗口的字符</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s[left];<br>            window.remove(d)<br>            <span class="hljs-comment">// 缩小窗口</span><br>            left++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于滑动窗口实现的代码，时间复杂度是O(N)。</p><h2 id="LeetCode76-最小覆盖子串"><a href="#LeetCode76-最小覆盖子串" class="headerlink" title="LeetCode76.最小覆盖子串"></a>LeetCode76.最小覆盖子串</h2><p>滑动窗口实现的简单思路：<br>1.在字符串s中使用双指针中的左右指针技巧，初始化left&#x3D;right&#x3D;0，将索引左闭右开区间[left,right)称为一个窗口。<br>2.不断增大right指针扩大窗口，[left,right)，直至窗口中字符串符合要求。<br>3.此时，停止增加right，转而不断增大left缩小窗口[left,right)，直至窗口中字符串不再符合要求。同时，每次增加left，都更新结果。<br>4.重复第二、三步，直至left到达s末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>            need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 记录最小覆盖子串的起始索引及长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, len = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-comment">// c 是将移入窗口的字符</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            <span class="hljs-comment">// 扩大窗口</span><br>            right++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            <span class="hljs-keyword">if</span> (need.containsKey(c)) &#123;<br>                window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (window.get(c).equals(need.get(c)))<br>                    valid++;<br>            &#125;<br><br>            <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span> (valid == need.size()) &#123;<br>                <span class="hljs-comment">// 在这里更新最小覆盖子串</span><br>                <span class="hljs-keyword">if</span> (right - left &lt; len) &#123;<br>                    start = left;<br>                    len = right - left;<br>                &#125;<br>                <span class="hljs-comment">// d 是将移出窗口的字符</span><br>                <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left);<br>                <span class="hljs-comment">// 缩小窗口</span><br>                left++;<br>                <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>                <span class="hljs-keyword">if</span> (need.containsKey(d)) &#123;<br>                    <span class="hljs-keyword">if</span> (window.get(d).equals(need.get(d)))<br>                        valid--;<br>                    window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>                &#125;                    <br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回最小覆盖子串</span><br>        <span class="hljs-keyword">return</span> len == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(start, start + len);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-567-字符串排列"><a href="#LeetCode-567-字符串排列" class="headerlink" title="LeetCode 567.字符串排列"></a>LeetCode 567.字符串排列</h2><p>滑动窗口典型：给你一个 S 和一个 T，请问你 S 中是否存在一个子串，包含 T 中所有字符且不包含其他字符？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 判断 s 中是否存在 t 的排列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkInclusion</span><span class="hljs-params">(String t, String s)</span> &#123;<br>        Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>            need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            right++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            <span class="hljs-keyword">if</span> (need.containsKey(c)) &#123;<br>                window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (window.get(c).intValue() == need.get(c).intValue())<br>                    valid++;<br>            &#125;<br><br>            <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span> (right - left &gt;= t.length()) &#123;<br>                <span class="hljs-comment">// 在这里判断是否找到了合法的子串</span><br>                <span class="hljs-keyword">if</span> (valid == need.size())<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left);<br>                left++;<br>                <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>                <span class="hljs-keyword">if</span> (need.containsKey(d)) &#123;<br>                    <span class="hljs-keyword">if</span> (window.get(d).intValue() == need.get(d).intValue())<br>                        valid--;<br>                    window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 未找到符合条件的子串</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-438-找到字符串中所有字母异位词"><a href="#LeetCode-438-找到字符串中所有字母异位词" class="headerlink" title="LeetCode 438.找到字符串中所有字母异位词"></a>LeetCode 438.找到字符串中所有字母异位词</h2><p>相当于，输入一个串 S，一个串 T，找到 S 中所有 T 的排列，返回它们的起始索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>            need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 记录结果</span><br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            right++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            <span class="hljs-keyword">if</span> (need.containsKey(c)) &#123;<br>                window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (window.get(c).equals(need.get(c))) &#123;<br>                    valid++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span> (right - left &gt;= t.length()) &#123;<br>                <span class="hljs-comment">// 当窗口符合条件时，把起始索引加入 res</span><br>                <span class="hljs-keyword">if</span> (valid == need.size())<br>                    res.add(left);<br>                <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left);<br>                left++;<br>                <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>                <span class="hljs-keyword">if</span> (need.containsKey(d)) &#123;<br>                    <span class="hljs-keyword">if</span> (window.get(d).equals(need.get(d))) &#123;<br>                        valid--;<br>                    &#125;<br>                    window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-3-最长无重复子串"><a href="#LeetCode-3-最长无重复子串" class="headerlink" title="LeetCode 3.最长无重复子串"></a>LeetCode 3.最长无重复子串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 记录结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            right++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span> (window.get(c) &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left);<br>                left++;<br>                <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>                window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">// 在这里更新答案</span><br>            res = Math.max(res, right - left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ安装配置</title>
    <link href="/2025/01/20/RocketMQ%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/01/20/RocketMQ%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ-基本概念"><a href="#RocketMQ-基本概念" class="headerlink" title="RocketMQ 基本概念"></a>RocketMQ 基本概念</h1><p>关于 RocketMQ 相关的基本概念，可翻阅官网：<a href="https://rocketmq.apache.org/zh/docs/4.x/producer/01concept1%E3%80%82">https://rocketmq.apache.org/zh/docs/4.x/producer/01concept1。</a></p><h1 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h1><ol><li><p>下载 RocketMQ 二进制包<br>浏览器访问地址：<a href="https://archive.apache.org/dist/rocketmq/4.9.4/rocketmq-all-4.9.4-bin-release.zip">https://archive.apache.org/dist/rocketmq/4.9.4/rocketmq-all-4.9.4-bin-release.zip</a> ， 下载 RocketMQ 编译完成后的二进制包：</p></li><li><p>下载完成后，进行解压。</p></li></ol><p>3.设置环境变量<br>解压完成后放着，先把相关环境变量设置一下</p><p>添加一个 ROCKETMQ_HOME 变量，值为刚刚我们二进制包解压的具体路径：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123110105133.png" alt="Loading"></p><p>另外，将 JAVA_HOME 系统变量修改为 jdk1.8</p><ol start="4"><li>设置完成后保存，打开一个新的命令窗口，执行 java -version 命令，确认当前使用的版本是 Java 8</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123110201377.png" alt="Loading"></p><ol start="5"><li><p>启动 RocketMQ<br>接着，准备正式启动 RocketMQ。</p></li><li><p>启动 namesrv<br>打开 cmd 命令行工具，进入到 RocketMQ 安装包的 &#x2F;bin 文件夹下，执行如下命令，先将 namesrv 启动起来:</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">start .\mqnamesrv.cmd<br></code></pre></td></tr></table></figure><p>命令执行完成后，会打开一个新的窗口，若提示 The Name Server boot sucess. , 则表示 namesrv 启动成功了。</p><p>注意：窗口打开后，不要关闭，关闭后 namesrv 也会随之关闭。</p><ol start="7"><li>启动 broker<br>接着，执行如下命令，准备启动 broker :</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">.\mqbroker -n 127.0.0.1:9876 autoCreateTopicEnable=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>解释一下启动参数的含义：</p><ul><li><p><code>-n 127.0.0.1:9876</code>：用来指定网络连接参数的标志，绑定到本地 IP 地址 127.0.0.1 并监听端口 9876。</p></li><li><p><code>autoCreateTopicEnable=true</code>：当发送的消息主题（topic）不存在时，则自动创建。</p></li></ul><p>命令执行完成后，若提示 The broker .. boot success. , 则表示运行成功了。同样的，窗口不要关闭。</p><ol start="8"><li>RocketMQ 控制台<br>为了更方便的管控 RocketMQ, 还需要一个控制台。浏览器访问：<a href="https://github.com/apache/rocketmq-dashboard">https://github.com/apache/rocketmq-dashboard</a> ， 如下图所示，下载 zip 源码：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123105805180.png"></p><p>下载完成后解压，并使用 IDEA 打开项目。</p><p>运行 App 启动类，将项目跑起来。启动成功后，浏览器访问 localhost:8080, 即可打开 RocketMQ 的控制台了</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK安装与配置</title>
    <link href="/2025/01/20/JDK%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/01/20/JDK%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="JDK下载-基于window11系统"><a href="#JDK下载-基于window11系统" class="headerlink" title="JDK下载(基于window11系统)"></a>JDK下载(基于window11系统)</h1><p>打开官网链接，根据自己的系统，按需选择下载JDK。会跳转到Oracle登录页，如果有账号直接登录即可，没账号的话点击创建账户，填写信息（邮箱填写正确，其余随便填均可）后点击创建账户，邮箱验证即可，再次登录，登录成功即开始下载。</p><h2 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h2><p>打开下载的对应文件.exe，单击下一步安装。<br>安装时可自选安装路径<br>JDK安装完成后会弹出JRE安装，同样流程完成。</p><h2 id="JDK环境配置"><a href="#JDK环境配置" class="headerlink" title="JDK环境配置"></a>JDK环境配置</h2><p>安装完JDK之后，需要设置JAVA_HOME的环境变量。其中JAVA_HOME需要指向的是JDK的安装目录。<br>JAVA_HOME设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 变量名：</span><br>JAVA_HOME<br><span class="hljs-comment"># 变量值：例如我设置的是如下，所以指向的是此地址，此处根据你自己设置的来。</span><br>D:\codeConfiguration\JAVA\jdk1.8<br></code></pre></td></tr></table></figure><p>更改path环境变量设置<br>PATH是什么？</p><ul><li>PATH 是操作系统用于查找来自命令行或终端窗口的必需可执行文件的系统变量。</li><li>PATH 系统变量可使用控制面板中的“系统”实用程序设置（在 Windows 上），或在 shell 的启动文件内设置（在 Linux 和 Solaris 上）。<br>Window下环境变量设置：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Windows：%JAVA_HOME%\bin<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker相关</title>
    <link href="/2025/01/19/Docker%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/01/19/Docker%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础常见面试题</title>
    <link href="/2025/01/19/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2025/01/19/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>Java中有8种基本数据类型，分别为：</p><p>6 种数字类型：</p><ul><li>4 种整数型：byte，short，int，long</li><li>2 种浮点型：float，double<br>1 种字符类型：char<br>1 种布尔型：boolean</li></ul><table><thead><tr><th>基本类型</th><th>位数</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>8</td><td>1</td><td>0</td></tr><tr><td>short</td><td>16</td><td>2</td><td>0</td></tr><tr><td>int</td><td>32</td><td>4</td><td>0</td></tr><tr><td>long</td><td>64</td><td>8</td><td>0L</td></tr><tr><td>char</td><td>16</td><td>2</td><td>‘u0000’</td></tr><tr><td>float</td><td>32</td><td>4</td><td>0.0f</td></tr><tr><td>double</td><td>64</td><td>8</td><td>0.0d</td></tr><tr><td>boolean</td><td>1</td><td>1</td><td>false</td></tr></tbody></table><p>这八种类型对应的包装类型分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean。</p><p>基本类型和包装类型的区别？</p><ol><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少使用基本数据类型来定义变量，并且，包装类型可以有多个值，而基本类型不可以。</li><li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机的局部变量表中，基本数据类型的成员变量（未做 static 修饰）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型），基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量是包装类型时默认值是 <code>null</code>，而基本数据类型默认值不是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值， 对于包装类型来说，<code>==</code> 比较的是对象的内存地址。所有包装类对象之间的比较，都应该使用 <code>equals()</code> 方法。</li></ol><p><strong>注</strong>：基本数据类型存储位置取决于其作用域及生命周期。</p><p>包装类的缓存机制？<br>Byte、Short、Integer、Long 这 4 种包装类默认创建数值 [-128，127] 的相应类型的缓存数据，<br>Character 创建了数值在 [0，127] 范围的缓存数据，Boolean 直接返回 True 或 False。<br>如果超出对应范围仍会创建新对象，缓存的范围区间大小只是在性能和资源之间权衡。<br>两种浮点类型的包装类Float、Double并未实现缓存机制。</p><p>Integer缓存源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerCache</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> -<span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> high;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// high value may be configured by property</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自动装箱与拆箱原理？<br>什么是自动拆装箱？</p><ul><li>装箱：将基本类型用对应的有引用类型包装起来。</li><li>拆箱：将包装类型转换为基本数据类型。</li></ul><p>装箱就是调用包装类的valueOf()方法，拆箱就是调用xxxValue()方法。</p><h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><p>面向对象三大特征</p><p>封装<br>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p><p>继承<br>继承是使用已存在的类的定义作为基础建立新类的技术，新类可以增加新的数据和功能，也可以使用父类的功能，但不能选择性继承。继承可以提高代码的复用性，程序的可维护性。<br>继承的三大特点：</p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，只有拥有。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以拥有自己的方法形式定义父类的方法。（以后介绍）</li></ol><p>多态<br>一个对象具有多种状态，具体表现为父类的引用指向子类的实例。<br>多态的特点：</p><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型是从其方法调用的返回值类型来决定哪个方法，必须在程序运行时才能确定；</li><li>多态不能单用，只在子类存在任意父类方法不存在的时候；</li><li>如果子类没有重写父类方法，具体执行的是父类的写的方法，执行的就是父类的。</li></ul><p>接口和抽象类异同？<br>接口和抽象类的共同点</p><p>实例化: 接口和抽象类都不能直接实例化对象，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。<br>抽象方法: 接口和抽象类可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。</p><p>接口和抽象类的区别</p><ul><li>设计目的: 接口主要用于对类的行为进行约束，接口就拥有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>继承规则： 一个类只能继承一个类（包括抽象类），因为 Java 不支持多继承。一个接口可以继承多个其他接口。</li><li>成分限制： 抽象类可以包含实例变量，方法体，public static final 类型的，不能被修改但必须有初始值。接口类的成分要求只能是 public static final，不能包含方法体，也不能有实例变量或被定义为默认值或默认方法。</li><li>方法:<br> 在 Java 8 之前，接口中的方法默认是 public abstract，也就是只有方法声明。自 Java 8 起，可以在接口中定义 default（默认）方法和 static（静态）方法。自 Java 9 起，接口也可以包含 private 方法。<br> 抽象类可以包含抽象方法和具体方法。抽象类方法有具体实现，可以直接在抽象类中使用或在子类中实现。非抽象方法具有具体实现。<br>在 Java 8 以及以后的版本中，接口可以拥有新的方法声明：default 方法、static 方法和 private 方法。这些方法被接口的实现类使用时必须满足一定规则。</li></ul><p>深拷贝和浅拷贝的区别？什么是引用拷贝？</p><ul><li>浅拷贝: 浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的引用类型的变量，浅拷贝会直接复制内部对象的引用地址，也就是说浅拷贝对象和原对象共用一个内部对象。</li><li>深拷贝: 深拷贝会完全复制整个对象，包括这个对象所包含的内内部对象。</li><li>引用拷贝：两个不同的引用指向同一个对象。</li></ul><p>Object类</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组遍历技巧</title>
    <link href="/2025/01/19/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%8A%80%E5%B7%A7/"/>
    <url>/2025/01/19/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="顺-逆时针旋转矩阵"><a href="#顺-逆时针旋转矩阵" class="headerlink" title="顺&#x2F;逆时针旋转矩阵"></a>顺&#x2F;逆时针旋转矩阵</h1><h2 id="LeetCode-48-旋转图像"><a href="#LeetCode-48-旋转图像" class="headerlink" title="LeetCode 48.旋转图像"></a>LeetCode 48.旋转图像</h2><p>常规的思路就是去寻找原始坐标和旋转后坐标的映射规律，但我们是否可以让思维跳跃跳跃，尝试把矩阵进行反转、镜像对称等操作，可能会出现新的突破口。</p><p>我们可以先将 n x n 矩阵 matrix 按照左上到右下的对角线进行镜像对称，然后再对矩阵的每一行进行反转，结果就是 matrix 顺时针旋转 90 度的结果：。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 将二维矩阵原地顺时针旋转 90 度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 先沿对角线镜像对称二维矩阵</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++) &#123;<br>                <span class="hljs-comment">// swap(matrix[i][j], matrix[j][i]);</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 然后反转二维矩阵的每一行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : matrix) &#123;<br>            reverse(row);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 反转一维数组</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = arr.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt; i) &#123;<br>            <span class="hljs-comment">// swap(arr[i], arr[j]);</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>扩展：如何将矩阵逆时针旋转90度<br>思路是类似的，只要通过另一条对角线镜像对称矩阵，然后再反转每一行，就得到了逆时针旋转矩阵的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// 将二维矩阵原地逆时针旋转 90 度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate2</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 沿左下到右上的对角线镜像对称二维矩阵</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n - i; j++) &#123;<br>                <span class="hljs-comment">// swap(matrix[i][j], matrix[n-j-1][n-i-1])</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[n - j - <span class="hljs-number">1</span>][n - i - <span class="hljs-number">1</span>];<br>                matrix[n - j - <span class="hljs-number">1</span>][n - i - <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 然后反转二维矩阵的每一行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : matrix) &#123;<br>            reverse(row);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-comment">// ···</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解法2：先翻转再对称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">//先翻转数组，再对称即可</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : matrix) &#123;<br>            reverse(arr);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[left];<br>            nums[left] = nums[right];<br>            nums[right] = tmp;<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="矩阵的螺旋遍历"><a href="#矩阵的螺旋遍历" class="headerlink" title="矩阵的螺旋遍历"></a>矩阵的螺旋遍历</h1><h2 id="LeetCode-54-螺旋矩阵"><a href="#LeetCode-54-螺旋矩阵" class="headerlink" title="LeetCode 54.螺旋矩阵"></a>LeetCode 54.螺旋矩阵</h2><p>解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界,随着螺旋遍历，相应的边界会收缩，直到螺旋遍历完整个数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">upper_bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lower_bound = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left_bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right_bound = n - <span class="hljs-number">1</span>;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// res.size() == m * n 则遍历完整个数组</span><br>        <span class="hljs-keyword">while</span> (res.size() &lt; m * n) &#123;<br>            <span class="hljs-keyword">if</span> (upper_bound &lt;= lower_bound) &#123;<br>                <span class="hljs-comment">// 在顶部从左向右遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> left_bound; j &lt;= right_bound; j++) &#123;<br>                    res.add(matrix[upper_bound][j]);<br>                &#125;<br>                <span class="hljs-comment">// 上边界下移</span><br>                upper_bound++;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (left_bound &lt;= right_bound) &#123;<br>                <span class="hljs-comment">// 在右侧从上向下遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> upper_bound; i &lt;= lower_bound; i++) &#123;<br>                    res.add(matrix[i][right_bound]);<br>                &#125;<br>                <span class="hljs-comment">// 右边界左移</span><br>                right_bound--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (upper_bound &lt;= lower_bound) &#123;<br>                <span class="hljs-comment">// 在底部从右向左遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> right_bound; j &gt;= left_bound; j--) &#123;<br>                    res.add(matrix[lower_bound][j]);<br>                &#125;<br>                <span class="hljs-comment">// 下边界上移</span><br>                lower_bound--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (left_bound &lt;= right_bound) &#123;<br>                <span class="hljs-comment">// 在左侧从下向上遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lower_bound; i &gt;= upper_bound; i--) &#123;<br>                    res.add(matrix[i][left_bound]);<br>                &#125;<br>                <span class="hljs-comment">// 左边界右移</span><br>                left_bound++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-59-螺旋矩阵Ⅱ"><a href="#LeetCode-59-螺旋矩阵Ⅱ" class="headerlink" title="LeetCode 59.螺旋矩阵Ⅱ"></a>LeetCode 59.螺旋矩阵Ⅱ</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">upper_bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lower_bound = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left_bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right_bound = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 需要填入矩阵的数字</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span> (num &lt;= n * n) &#123;<br>            <span class="hljs-keyword">if</span> (upper_bound &lt;= lower_bound) &#123;<br>                <span class="hljs-comment">// 在顶部从左向右遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> left_bound; j &lt;= right_bound; j++) &#123;<br>                    matrix[upper_bound][j] = num++;<br>                &#125;<br>                <span class="hljs-comment">// 上边界下移</span><br>                upper_bound++;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (left_bound &lt;= right_bound) &#123;<br>                <span class="hljs-comment">// 在右侧从上向下遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> upper_bound; i &lt;= lower_bound; i++) &#123;<br>                    matrix[i][right_bound] = num++;<br>                &#125;<br>                <span class="hljs-comment">// 右边界左移</span><br>                right_bound--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (upper_bound &lt;= lower_bound) &#123;<br>                <span class="hljs-comment">// 在底部从右向左遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> right_bound; j &gt;= left_bound; j--) &#123;<br>                    matrix[lower_bound][j] = num++;<br>                &#125;<br>                <span class="hljs-comment">// 下边界上移</span><br>                lower_bound--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (left_bound &lt;= right_bound) &#123;<br>                <span class="hljs-comment">// 在左侧从下向上遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lower_bound; i &gt;= upper_bound; i--) &#123;<br>                    matrix[i][left_bound] = num++;<br>                &#125;<br>                <span class="hljs-comment">// 左边界右移</span><br>                left_bound++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二维数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针相关算法</title>
    <link href="/2025/01/19/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/19/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、快慢指针"><a href="#一、快慢指针" class="headerlink" title="一、快慢指针"></a>一、快慢指针</h1><h2 id="原地修改"><a href="#原地修改" class="headerlink" title="原地修改"></a>原地修改</h2><h3 id="LeetCode-26-删除有序数组中的重复项"><a href="#LeetCode-26-删除有序数组中的重复项" class="headerlink" title="LeetCode 26. 删除有序数组中的重复项"></a>LeetCode 26. 删除有序数组中的重复项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fast] != nums[slow]) &#123;<br>                slow++;<br>                <span class="hljs-comment">// 维护 nums[0..slow] 无重复</span><br>                nums[slow] = nums[fast];<br>            &#125;<br>            fast++;<br>        &#125;<br>        <span class="hljs-comment">// 数组长度为索引 + 1</span><br>        <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LeetCode-27-移除元素"><a href="#LeetCode-27-移除元素" class="headerlink" title="LeetCode 27.移除元素"></a>LeetCode 27.移除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fast] != val) &#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>            fast++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与26题存在差别：先给 nums[slow] 赋值然后再给 slow++，这样可以保证 nums[0..slow-1] 是不包含值为 val 的元素的，最后的结果数组长度就是 slow。</p><h3 id="LeetCode-283-移动零"><a href="#LeetCode-283-移动零" class="headerlink" title="LeetCode 283.移动零"></a>LeetCode 283.移动零</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 去除 nums 中的所有 0，返回不含 0 的数组长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> removeElement(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 将 nums[p..] 的元素赋值为 0</span><br>        <span class="hljs-keyword">for</span> (; p &lt; nums.length; p++) &#123;<br>            nums[p] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 见27.代码实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口代码框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 滑动窗口算法框架伪码</span><br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (right &lt; nums.size()) &#123;<br>    <span class="hljs-comment">// 增大窗口</span><br>    window.addLast(nums[right]);<br>    right++;<br>    <br>    <span class="hljs-keyword">while</span> (window needs shrink) &#123;<br>        <span class="hljs-comment">// 缩小窗口</span><br>        window.removeFirst(nums[left]);<br>        left++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、左右指针"><a href="#二、左右指针" class="headerlink" title="二、左右指针"></a>二、左右指针</h1><p>二分方法下左右指针：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right + left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-167-两数之和Ⅱ"><a href="#LeetCode-167-两数之和Ⅱ" class="headerlink" title="LeetCode 167.两数之和Ⅱ"></a>LeetCode 167.两数之和Ⅱ</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = numbers.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> numbers[left] + numbers[right];<br>            <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                <span class="hljs-comment">// 题目要求的索引是从 1 开始的</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>                <span class="hljs-comment">// 让 sum 大一点</span><br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>                <span class="hljs-comment">// 让 sum 小一点</span><br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-344-反转字符串"><a href="#Leetcode-344-反转字符串" class="headerlink" title="Leetcode 344.反转字符串"></a>Leetcode 344.反转字符串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>    <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 交换 s[left] 和 s[right]</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s[left];<br>        s[left] = s[right];<br>        s[right] = temp;<br>        left++;<br>        right--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-5-最长回文子串"><a href="#Leetcode-5-最长回文子串" class="headerlink" title="Leetcode 5.最长回文子串"></a>Leetcode 5.最长回文子串</h2><p>判断回文串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        left++;<br>        right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>找回文串关键点在于，回文串长度可能为奇数也可能是偶数，解决问题核心在于从回文串中心向两边扩散的双指针技巧。<br>如果回文串长度为奇数，则它有一个中心字符；如果回文串长度为偶数，则有两个中心字符。<br>函数实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串</span><br>String <span class="hljs-title function_">palindrome</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-comment">// 防止索引越界</span><br>    <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.length()<br>            &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;<br>        <span class="hljs-comment">// 双指针，向两边展开</span><br>        l--; r++;<br>    &#125;<br>    <span class="hljs-comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span><br>    <span class="hljs-keyword">return</span> s.substring(l + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><p>整体解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-comment">// 以 s[i] 为中心的最长回文子串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> palindrome(s, i, i);<br>        <span class="hljs-comment">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> palindrome(s, i, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// res = longest(res, s1, s2)</span><br>        res = res.length() &gt; s1.length() ? res : s1;<br>        res = res.length() &gt; s2.length() ? res : s2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br>String <span class="hljs-title function_">palindrome</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-comment">// 防止索引越界</span><br>    <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.length()<br>            &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;<br>        <span class="hljs-comment">// 双指针，向两边展开</span><br>        l--; r++;<br>    &#125;<br>    <span class="hljs-comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span><br>    <span class="hljs-keyword">return</span> s.substring(l + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOC&amp;AOP</title>
    <link href="/2025/01/19/Spring-IOC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/01/19/Spring-IOC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="什么是IOC？"><a href="#什么是IOC？" class="headerlink" title="什么是IOC？"></a>什么是IOC？</h2><p>IOC即控制反转。是一种思想，将创建对象的权力交给外部容器(IOC容器)</p><h2 id="IOC解决的问题："><a href="#IOC解决的问题：" class="headerlink" title="IOC解决的问题："></a>IOC解决的问题：</h2><p>1.降低对象之间的耦合度；<br>2.使资源管理更简单。</p><h2 id="IOC与DI有什么区别？"><a href="#IOC与DI有什么区别？" class="headerlink" title="IOC与DI有什么区别？"></a>IOC与DI有什么区别？</h2><p>IOC是一种设计思想，即将本来在程序中手动创建对象的控制权交给第三方比如IOC容器。对于Spring框架而言，IOC就是一个Map(key,value)，Mao中存放各种对象。IOC并非Spring独有。<br>IOC最常见、最合理的实现方法即DI(依赖注入)。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h2><p>AOP即面向切面编程，AOP是OOP的一种延伸，二者互相补充。核心思想是将横切关注点从业务逻辑中抽离出来，形成一个个切面。</p><h2 id="AOP关键术语："><a href="#AOP关键术语：" class="headerlink" title="AOP关键术语："></a>AOP关键术语：</h2><ul><li>切点 (PointCut)：一个切点即一个表达式，用来匹配需要增强被切面增强的连接点。</li><li>切面(Aspect)：对横切关注点进行封装的类，一个切面是一个类。一个切面可以定义多个通知，实现具体的功能。</li><li>连接点(JoinPoint)：连接点是方法调用或方法执行的某个特定时刻(方法调用、异常抛出等)。</li><li>通知(Advice)：通知即切面在某个连接点要执行的操作。通知分为五种类型。分别是前置通知(Before)、后置通知(After)、返回通知(AfterReturning)、异常通知(AfterThrowing)和环绕通知(Around)。</li><li>织入(Weaving)：织入是将切面和目标对象连接起来的过程，即将通知应用到切点匹配的连接点上。常见的织入时期：编译器织入和运行期织入。</li></ul><h2 id="AOP常见的通知类型："><a href="#AOP常见的通知类型：" class="headerlink" title="AOP常见的通知类型："></a>AOP常见的通知类型：</h2><ul><li>Before（前置通知）：目标对象的方法调用在前触发。</li><li>After（后置通知）：目标对象的方法调用之后触发。</li><li>AfterReturning（返回通知）：目标对象的方法调用完成后触发，返回结果值之后触发。</li><li>AfterThrowing（异常通知）：目标对象的方法执行中抛出异常时触发。如果方法调用成功且无异常，则返回值不受影响。</li><li>Around（环绕通知）：可以在方法调用的前后执行自定义逻辑，甚至可以控制方法的执行，具有完全的控制权。</li></ul><h2 id="AOP解决了什么问题？"><a href="#AOP解决了什么问题？" class="headerlink" title="AOP解决了什么问题？"></a>AOP解决了什么问题？</h2><p>OOP不能很好的处理分散在多个类或对象中的公共行为，即横切关注点。而AOP可以将横切关注点从核心业务逻辑中分离出来，实现关注点的分离。</p><h2 id="AOP常见应用场景？"><a href="#AOP常见应用场景？" class="headerlink" title="AOP常见应用场景？"></a>AOP常见应用场景？</h2><ul><li>日志记录：自定义日志记录注解，利用 AOP，行代码即可实现日志记录。</li><li>性能统计：利用 AOP 在目标方法的执行前后进行统计，方便优化和分析。</li><li>事务管理：@Transactional 注解可以让 Spring 为我们进行事务管理，避免了重复的事务管理逻辑。@Transactional 注解是基于 AOP 实现的。</li><li>权限控制：利用 AOP 在目标方法执行前判断用户是否具备所需的权限，如果具备，就执行目标方法，否则就不执行。例如，SpringSecurity 利用 @PreAuthorize 注解一行代码即可自定义权限校验。</li><li>接入限制：利用 AOP 在目标方法执行前进行请求参数的校验和实现请求排队限流处理。</li><li>缓存管理：利用 AOP 在目标方法执行后进行缓存的读取和更新。</li></ul><h1 id="AOP实现方式有哪些？"><a href="#AOP实现方式有哪些？" class="headerlink" title="AOP实现方式有哪些？"></a>AOP实现方式有哪些？</h1><p>AOP常见实现方式有动态代理和字节码操作两种方式。</p><h2 id="Spring-AOP与AspectJ-AOP有什么区别？"><a href="#Spring-AOP与AspectJ-AOP有什么区别？" class="headerlink" title="Spring AOP与AspectJ AOP有什么区别？"></a>Spring AOP与AspectJ AOP有什么区别？</h2><p>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。Spring AOP 基于代理 (Proxy)，而 AspectJ 基于字节码操作（Bytecode Manipulation）。<br>Spring AOP 已经集成了 AspectJ，AspectJ 应该算的是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单。<br>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的时候，最好选择 AspectJ，它比 Spring AOP 快很多。</p>]]></content>
    
    
    <categories>
      
      <category>Spring框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo主题搭建</title>
    <link href="/2025/01/18/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
    <url>/2025/01/18/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1. 安装依赖包"></a>1. 安装依赖包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><h1 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br>npm install<br></code></pre></td></tr></table></figure><h1 id="3-关联Github"><a href="#3-关联Github" class="headerlink" title="3. 关联Github"></a>3. 关联Github</h1><h2 id="上传文章封面图不显示"><a href="#上传文章封面图不显示" class="headerlink" title="上传文章封面图不显示"></a>上传文章封面图不显示</h2><p>设置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">tags: [fluid, js, css,Hexo]<br>categories: [Hexo]<br>index_img: /source/img/cover/fluid.png<br></code></pre></td></tr></table></figure><p>问题：<br>设置路径错误，修正如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">categories: [Hexo]<br>index_img: /img/cover/fluid.png<br></code></pre></td></tr></table></figure><p>TODO：文章底部生成链接修正<br>TODO：头像旋转<br>TODO：引入一言<br>TODO：引入PV UV</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fluid</tag>
      
      <tag>js</tag>
      
      <tag>css</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>场景算法</title>
    <link href="/2025/01/18/%E5%9C%BA%E6%99%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/18/%E5%9C%BA%E6%99%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题-16-25-LRU缓存"><a href="#LeetCode-面试题-16-25-LRU缓存" class="headerlink" title="LeetCode 面试题 16.25. LRU缓存"></a>LeetCode 面试题 16.25. LRU缓存</h2><p>设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。<br>它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p>示例：</p><p>LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );</p><p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       &#x2F;&#x2F; 返回  1<br>cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得密钥 2 作废<br>cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)<br>cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得密钥 1 作废<br>cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)<br>cache.get(3);       &#x2F;&#x2F; 返回  3<br>cache.get(4);       &#x2F;&#x2F; 返回  4</p><p>思路：使用双向链表实现，每个节点包括k，v数据以及前驱、后继节点。此外，链表中还有虚拟节点dummy，让每个节点的pre和next均不为空，简化操作。<br>为什么要保存key？<br>在删除链表末尾节点时，需要删除哈希表中的记录，需要查找末尾节点的key。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> key, value;<br>        Node pre, next;<br><br>        Node(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v) &#123;<br>            key = k;<br>            value = v;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer,Node&gt; keyToNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        dummy.pre = dummy;<br>        dummy.next = dummy;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNode(key);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> ? node.value : -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNode(key);<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            node.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value);<br>        keyToNode.put(key,node);<br>        pushFront(node);<br>        <span class="hljs-keyword">if</span> (keyToNode.size() &gt; capacity) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">backNode</span> <span class="hljs-operator">=</span> dummy.pre;<br>            keyToNode.remove(backNode.key);<br>            remove(backNode);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (! keyToNode.containsKey(key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> keyToNode.get(key);<br>        remove(node);<br>        pushFront(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Node x)</span> &#123;<br>        x.pre.next = x.next;<br>        x.next.pre = x.pre;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushFront</span><span class="hljs-params">(Node x)</span> &#123;<br>        x.pre = dummy;<br>        x.next = dummy.next;<br>        x.pre.next = x;<br>        x.next.pre = x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手写单例模式的实现"><a href="#手写单例模式的实现" class="headerlink" title="手写单例模式的实现"></a>手写单例模式的实现</h2><h3 id="1-懒汉式"><a href="#1-懒汉式" class="headerlink" title="1.懒汉式"></a>1.懒汉式</h3><p>懒汉式单例是在第一次使用时创建实例，但这种方式在多线程环境下不安全，可能导致多个实例的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态变量，保存唯一的实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <span class="hljs-comment">// 这里是懒加载</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1懒汉式的线程安全模式"><a href="#1-1懒汉式的线程安全模式" class="headerlink" title="1.1懒汉式的线程安全模式"></a>1.1懒汉式的线程安全模式</h4><p>通过在 getInstance() 方法加锁来实现线程安全，但由于每次都加锁，可能会影响性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态变量，保存唯一的实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2双重检查锁"><a href="#1-2双重检查锁" class="headerlink" title="1.2双重检查锁"></a>1.2双重检查锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 使用 volatile 确保可见性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3静态内部类"><a href="#1-3静态内部类" class="headerlink" title="1.3静态内部类"></a>1.3静态内部类</h4><p>这种方式是线程安全的，并且延迟加载，推荐使用。JVM 确保了静态内部类只会加载一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态内部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHelper</span> &#123;<br>        <span class="hljs-comment">// 静态变量，保存唯一的实例</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHelper.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-饿汉式"><a href="#2-饿汉式" class="headerlink" title="2.饿汉式"></a>2.饿汉式</h3><p>这种方式在类加载时就创建实例，不会等到需要的时候才创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态变量，保存唯一的实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三个线程循环打印斐波那契数列"><a href="#三个线程循环打印斐波那契数列" class="headerlink" title="三个线程循环打印斐波那契数列"></a>三个线程循环打印斐波那契数列</h2><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FibonacciPrinter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <span class="hljs-comment">// 用于线程间同步</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">fib1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 斐波那契数列的第一个数字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">fib2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 斐波那契数列的第二个数字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 控制打印的次数</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建三个线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(<span class="hljs-number">2</span>));<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(<span class="hljs-number">3</span>));<br><br>        <span class="hljs-comment">// 启动线程</span><br>        thread1.start();<br>        thread2.start();<br>        thread3.start();<br>    &#125;<br><br>    <span class="hljs-comment">// 斐波那契数列打印任务</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FibonacciTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threadId;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">FibonacciTask</span><span class="hljs-params">(<span class="hljs-type">int</span> threadId)</span> &#123;<br>            <span class="hljs-built_in">this</span>.threadId = threadId;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">30</span>) &#123;  <span class="hljs-comment">// 打印30个斐波那契数列</span><br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    <span class="hljs-comment">// 判断当前线程是否轮到它打印</span><br>                    <span class="hljs-keyword">if</span> (count % <span class="hljs-number">3</span> == threadId - <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">nextFib</span> <span class="hljs-operator">=</span> fib1 + fib2;<br>                        System.out.println(<span class="hljs-string">&quot;Thread &quot;</span> + threadId + <span class="hljs-string">&quot; prints: &quot;</span> + fib1);<br>                        fib1 = fib2;<br>                        fib2 = nextFib;<br>                        count++;<br>                        lock.notifyAll();  <span class="hljs-comment">// 唤醒其他线程</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            lock.wait();  <span class="hljs-comment">// 当前线程等待</span><br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            Thread.currentThread().interrupt();<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script><div id="posts-chart"style="border-radius: 8px; height: 190px; padding: 10px;"></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>面经</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>lru</tag>
      
      <tag>JUC</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/01/18/hello-world/"/>
    <url>/2025/01/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script><div id="posts-chart"style="border-radius: 8px; height: 190px; padding: 10px;"></div>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
