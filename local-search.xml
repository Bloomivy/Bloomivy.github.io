<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>二维数组遍历技巧</title>
    <link href="/2025/01/19/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%8A%80%E5%B7%A7/"/>
    <url>/2025/01/19/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="顺-逆时针旋转矩阵"><a href="#顺-逆时针旋转矩阵" class="headerlink" title="顺&#x2F;逆时针旋转矩阵"></a>顺&#x2F;逆时针旋转矩阵</h1><h2 id="LeetCode-48-旋转图像"><a href="#LeetCode-48-旋转图像" class="headerlink" title="LeetCode 48.旋转图像"></a>LeetCode 48.旋转图像</h2><p>常规的思路就是去寻找原始坐标和旋转后坐标的映射规律，但我们是否可以让思维跳跃跳跃，尝试把矩阵进行反转、镜像对称等操作，可能会出现新的突破口。</p><p>我们可以先将 n x n 矩阵 matrix 按照左上到右下的对角线进行镜像对称，然后再对矩阵的每一行进行反转，结果就是 matrix 顺时针旋转 90 度的结果：。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 将二维矩阵原地顺时针旋转 90 度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 先沿对角线镜像对称二维矩阵</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++) &#123;<br>                <span class="hljs-comment">// swap(matrix[i][j], matrix[j][i]);</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 然后反转二维矩阵的每一行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : matrix) &#123;<br>            reverse(row);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 反转一维数组</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = arr.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt; i) &#123;<br>            <span class="hljs-comment">// swap(arr[i], arr[j]);</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>扩展：如何将矩阵逆时针旋转90度<br>思路是类似的，只要通过另一条对角线镜像对称矩阵，然后再反转每一行，就得到了逆时针旋转矩阵的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// 将二维矩阵原地逆时针旋转 90 度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate2</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 沿左下到右上的对角线镜像对称二维矩阵</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n - i; j++) &#123;<br>                <span class="hljs-comment">// swap(matrix[i][j], matrix[n-j-1][n-i-1])</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[n - j - <span class="hljs-number">1</span>][n - i - <span class="hljs-number">1</span>];<br>                matrix[n - j - <span class="hljs-number">1</span>][n - i - <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 然后反转二维矩阵的每一行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : matrix) &#123;<br>            reverse(row);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-comment">// ···</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解法2：先翻转再对称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">//先翻转数组，再对称即可</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : matrix) &#123;<br>            reverse(arr);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[left];<br>            nums[left] = nums[right];<br>            nums[right] = tmp;<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="矩阵的螺旋遍历"><a href="#矩阵的螺旋遍历" class="headerlink" title="矩阵的螺旋遍历"></a>矩阵的螺旋遍历</h1><h2 id="LeetCode-54-螺旋矩阵"><a href="#LeetCode-54-螺旋矩阵" class="headerlink" title="LeetCode 54.螺旋矩阵"></a>LeetCode 54.螺旋矩阵</h2><p>解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界,随着螺旋遍历，相应的边界会收缩，直到螺旋遍历完整个数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">upper_bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lower_bound = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left_bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right_bound = n - <span class="hljs-number">1</span>;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// res.size() == m * n 则遍历完整个数组</span><br>        <span class="hljs-keyword">while</span> (res.size() &lt; m * n) &#123;<br>            <span class="hljs-keyword">if</span> (upper_bound &lt;= lower_bound) &#123;<br>                <span class="hljs-comment">// 在顶部从左向右遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> left_bound; j &lt;= right_bound; j++) &#123;<br>                    res.add(matrix[upper_bound][j]);<br>                &#125;<br>                <span class="hljs-comment">// 上边界下移</span><br>                upper_bound++;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (left_bound &lt;= right_bound) &#123;<br>                <span class="hljs-comment">// 在右侧从上向下遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> upper_bound; i &lt;= lower_bound; i++) &#123;<br>                    res.add(matrix[i][right_bound]);<br>                &#125;<br>                <span class="hljs-comment">// 右边界左移</span><br>                right_bound--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (upper_bound &lt;= lower_bound) &#123;<br>                <span class="hljs-comment">// 在底部从右向左遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> right_bound; j &gt;= left_bound; j--) &#123;<br>                    res.add(matrix[lower_bound][j]);<br>                &#125;<br>                <span class="hljs-comment">// 下边界上移</span><br>                lower_bound--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (left_bound &lt;= right_bound) &#123;<br>                <span class="hljs-comment">// 在左侧从下向上遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lower_bound; i &gt;= upper_bound; i--) &#123;<br>                    res.add(matrix[i][left_bound]);<br>                &#125;<br>                <span class="hljs-comment">// 左边界右移</span><br>                left_bound++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-59-螺旋矩阵Ⅱ"><a href="#LeetCode-59-螺旋矩阵Ⅱ" class="headerlink" title="LeetCode 59.螺旋矩阵Ⅱ"></a>LeetCode 59.螺旋矩阵Ⅱ</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">upper_bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lower_bound = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left_bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right_bound = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 需要填入矩阵的数字</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span> (num &lt;= n * n) &#123;<br>            <span class="hljs-keyword">if</span> (upper_bound &lt;= lower_bound) &#123;<br>                <span class="hljs-comment">// 在顶部从左向右遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> left_bound; j &lt;= right_bound; j++) &#123;<br>                    matrix[upper_bound][j] = num++;<br>                &#125;<br>                <span class="hljs-comment">// 上边界下移</span><br>                upper_bound++;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (left_bound &lt;= right_bound) &#123;<br>                <span class="hljs-comment">// 在右侧从上向下遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> upper_bound; i &lt;= lower_bound; i++) &#123;<br>                    matrix[i][right_bound] = num++;<br>                &#125;<br>                <span class="hljs-comment">// 右边界左移</span><br>                right_bound--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (upper_bound &lt;= lower_bound) &#123;<br>                <span class="hljs-comment">// 在底部从右向左遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> right_bound; j &gt;= left_bound; j--) &#123;<br>                    matrix[lower_bound][j] = num++;<br>                &#125;<br>                <span class="hljs-comment">// 下边界上移</span><br>                lower_bound--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (left_bound &lt;= right_bound) &#123;<br>                <span class="hljs-comment">// 在左侧从下向上遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lower_bound; i &gt;= upper_bound; i--) &#123;<br>                    matrix[i][left_bound] = num++;<br>                &#125;<br>                <span class="hljs-comment">// 左边界右移</span><br>                left_bound++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二维数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针相关算法</title>
    <link href="/2025/01/19/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/19/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、快慢指针"><a href="#一、快慢指针" class="headerlink" title="一、快慢指针"></a>一、快慢指针</h1><h2 id="原地修改"><a href="#原地修改" class="headerlink" title="原地修改"></a>原地修改</h2><h3 id="LeetCode-26-删除有序数组中的重复项"><a href="#LeetCode-26-删除有序数组中的重复项" class="headerlink" title="LeetCode 26. 删除有序数组中的重复项"></a>LeetCode 26. 删除有序数组中的重复项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fast] != nums[slow]) &#123;<br>                slow++;<br>                <span class="hljs-comment">// 维护 nums[0..slow] 无重复</span><br>                nums[slow] = nums[fast];<br>            &#125;<br>            fast++;<br>        &#125;<br>        <span class="hljs-comment">// 数组长度为索引 + 1</span><br>        <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LeetCode-27-移除元素"><a href="#LeetCode-27-移除元素" class="headerlink" title="LeetCode 27.移除元素"></a>LeetCode 27.移除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fast] != val) &#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>            fast++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与26题存在差别：先给 nums[slow] 赋值然后再给 slow++，这样可以保证 nums[0..slow-1] 是不包含值为 val 的元素的，最后的结果数组长度就是 slow。</p><h3 id="LeetCode-283-移动零"><a href="#LeetCode-283-移动零" class="headerlink" title="LeetCode 283.移动零"></a>LeetCode 283.移动零</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 去除 nums 中的所有 0，返回不含 0 的数组长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> removeElement(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 将 nums[p..] 的元素赋值为 0</span><br>        <span class="hljs-keyword">for</span> (; p &lt; nums.length; p++) &#123;<br>            nums[p] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 见27.代码实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口代码框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 滑动窗口算法框架伪码</span><br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (right &lt; nums.size()) &#123;<br>    <span class="hljs-comment">// 增大窗口</span><br>    window.addLast(nums[right]);<br>    right++;<br>    <br>    <span class="hljs-keyword">while</span> (window needs shrink) &#123;<br>        <span class="hljs-comment">// 缩小窗口</span><br>        window.removeFirst(nums[left]);<br>        left++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、左右指针"><a href="#二、左右指针" class="headerlink" title="二、左右指针"></a>二、左右指针</h1><p>二分方法下左右指针：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right + left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-167-两数之和Ⅱ"><a href="#LeetCode-167-两数之和Ⅱ" class="headerlink" title="LeetCode 167.两数之和Ⅱ"></a>LeetCode 167.两数之和Ⅱ</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = numbers.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> numbers[left] + numbers[right];<br>            <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                <span class="hljs-comment">// 题目要求的索引是从 1 开始的</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>                <span class="hljs-comment">// 让 sum 大一点</span><br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>                <span class="hljs-comment">// 让 sum 小一点</span><br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-344-反转字符串"><a href="#Leetcode-344-反转字符串" class="headerlink" title="Leetcode 344.反转字符串"></a>Leetcode 344.反转字符串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>    <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 交换 s[left] 和 s[right]</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s[left];<br>        s[left] = s[right];<br>        s[right] = temp;<br>        left++;<br>        right--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-5-最长回文子串"><a href="#Leetcode-5-最长回文子串" class="headerlink" title="Leetcode 5.最长回文子串"></a>Leetcode 5.最长回文子串</h2><p>判断回文串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        left++;<br>        right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>找回文串关键点在于，回文串长度可能为奇数也可能是偶数，解决问题核心在于从回文串中心向两边扩散的双指针技巧。<br>如果回文串长度为奇数，则它有一个中心字符；如果回文串长度为偶数，则有两个中心字符。<br>函数实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串</span><br>String <span class="hljs-title function_">palindrome</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-comment">// 防止索引越界</span><br>    <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.length()<br>            &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;<br>        <span class="hljs-comment">// 双指针，向两边展开</span><br>        l--; r++;<br>    &#125;<br>    <span class="hljs-comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span><br>    <span class="hljs-keyword">return</span> s.substring(l + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><p>整体解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-comment">// 以 s[i] 为中心的最长回文子串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> palindrome(s, i, i);<br>        <span class="hljs-comment">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> palindrome(s, i, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// res = longest(res, s1, s2)</span><br>        res = res.length() &gt; s1.length() ? res : s1;<br>        res = res.length() &gt; s2.length() ? res : s2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br>String <span class="hljs-title function_">palindrome</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-comment">// 防止索引越界</span><br>    <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.length()<br>            &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;<br>        <span class="hljs-comment">// 双指针，向两边展开</span><br>        l--; r++;<br>    &#125;<br>    <span class="hljs-comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span><br>    <span class="hljs-keyword">return</span> s.substring(l + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOC&amp;AOP</title>
    <link href="/2025/01/19/Spring-IOC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/01/19/Spring-IOC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="什么是IOC？"><a href="#什么是IOC？" class="headerlink" title="什么是IOC？"></a>什么是IOC？</h2><p>IOC即控制反转。是一种思想，将创建对象的权力交给外部容器(IOC容器)</p><h2 id="IOC解决的问题："><a href="#IOC解决的问题：" class="headerlink" title="IOC解决的问题："></a>IOC解决的问题：</h2><p>1.降低对象之间的耦合度；<br>2.使资源管理更简单。</p><h2 id="IOC与DI有什么区别？"><a href="#IOC与DI有什么区别？" class="headerlink" title="IOC与DI有什么区别？"></a>IOC与DI有什么区别？</h2><p>IOC是一种设计思想，即将本来在程序中手动创建对象的控制权交给第三方比如IOC容器。对于Spring框架而言，IOC就是一个Map(key,value)，Mao中存放各种对象。IOC并非Spring独有。<br>IOC最常见、最合理的实现方法即DI(依赖注入)。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h2><p>AOP即面向切面编程，AOP是OOP的一种延伸，二者互相补充。核心思想是将横切关注点从业务逻辑中抽离出来，形成一个个切面。</p><h2 id="AOP关键术语："><a href="#AOP关键术语：" class="headerlink" title="AOP关键术语："></a>AOP关键术语：</h2><ul><li>切点 (PointCut)：一个切点即一个表达式，用来匹配需要增强被切面增强的连接点。</li><li>切面(Aspect)：对横切关注点进行封装的类，一个切面是一个类。一个切面可以定义多个通知，实现具体的功能。</li><li>连接点(JoinPoint)：连接点是方法调用或方法执行的某个特定时刻(方法调用、异常抛出等)。</li><li>通知(Advice)：通知即切面在某个连接点要执行的操作。通知分为五种类型。分别是前置通知(Before)、后置通知(After)、返回通知(AfterReturning)、异常通知(AfterThrowing)和环绕通知(Around)。</li><li>织入(Weaving)：织入是将切面和目标对象连接起来的过程，即将通知应用到切点匹配的连接点上。常见的织入时期：编译器织入和运行期织入。</li></ul><h2 id="AOP常见的通知类型："><a href="#AOP常见的通知类型：" class="headerlink" title="AOP常见的通知类型："></a>AOP常见的通知类型：</h2><ul><li>Before（前置通知）：目标对象的方法调用在前触发。</li><li>After（后置通知）：目标对象的方法调用之后触发。</li><li>AfterReturning（返回通知）：目标对象的方法调用完成后触发，返回结果值之后触发。</li><li>AfterThrowing（异常通知）：目标对象的方法执行中抛出异常时触发。如果方法调用成功且无异常，则返回值不受影响。</li><li>Around（环绕通知）：可以在方法调用的前后执行自定义逻辑，甚至可以控制方法的执行，具有完全的控制权。</li></ul><h2 id="AOP解决了什么问题？"><a href="#AOP解决了什么问题？" class="headerlink" title="AOP解决了什么问题？"></a>AOP解决了什么问题？</h2><p>OOP不能很好的处理分散在多个类或对象中的公共行为，即横切关注点。而AOP可以将横切关注点从核心业务逻辑中分离出来，实现关注点的分离。</p><h2 id="AOP常见应用场景？"><a href="#AOP常见应用场景？" class="headerlink" title="AOP常见应用场景？"></a>AOP常见应用场景？</h2><ul><li>日志记录：自定义日志记录注解，利用 AOP，行代码即可实现日志记录。</li><li>性能统计：利用 AOP 在目标方法的执行前后进行统计，方便优化和分析。</li><li>事务管理：@Transactional 注解可以让 Spring 为我们进行事务管理，避免了重复的事务管理逻辑。@Transactional 注解是基于 AOP 实现的。</li><li>权限控制：利用 AOP 在目标方法执行前判断用户是否具备所需的权限，如果具备，就执行目标方法，否则就不执行。例如，SpringSecurity 利用 @PreAuthorize 注解一行代码即可自定义权限校验。</li><li>接入限制：利用 AOP 在目标方法执行前进行请求参数的校验和实现请求排队限流处理。</li><li>缓存管理：利用 AOP 在目标方法执行后进行缓存的读取和更新。</li></ul><h1 id="AOP实现方式有哪些？"><a href="#AOP实现方式有哪些？" class="headerlink" title="AOP实现方式有哪些？"></a>AOP实现方式有哪些？</h1><p>AOP常见实现方式有动态代理和字节码操作两种方式。</p><h2 id="Spring-AOP与AspectJ-AOP有什么区别？"><a href="#Spring-AOP与AspectJ-AOP有什么区别？" class="headerlink" title="Spring AOP与AspectJ AOP有什么区别？"></a>Spring AOP与AspectJ AOP有什么区别？</h2><p>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。Spring AOP 基于代理 (Proxy)，而 AspectJ 基于字节码操作（Bytecode Manipulation）。<br>Spring AOP 已经集成了 AspectJ，AspectJ 应该算的是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单。<br>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的时候，最好选择 AspectJ，它比 Spring AOP 快很多。</p>]]></content>
    
    
    <categories>
      
      <category>Spring框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo主题搭建</title>
    <link href="/2025/01/18/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
    <url>/2025/01/18/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1. 安装依赖包"></a>1. 安装依赖包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><h1 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br>npm install<br></code></pre></td></tr></table></figure><h1 id="3-关联Github"><a href="#3-关联Github" class="headerlink" title="3. 关联Github"></a>3. 关联Github</h1><h2 id="上传文章封面图不显示"><a href="#上传文章封面图不显示" class="headerlink" title="上传文章封面图不显示"></a>上传文章封面图不显示</h2><p>设置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">tags: [fluid, js, css,Hexo]<br>categories: [Hexo]<br>index_img: /source/img/cover/fluid.png<br></code></pre></td></tr></table></figure><p>问题：<br>设置路径错误，修正如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">categories: [Hexo]<br>index_img: /img/cover/fluid.png<br></code></pre></td></tr></table></figure><p>TODO：文章底部生成链接修正<br>TODO：头像旋转<br>TODO：引入一言<br>TODO：引入PV UV</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fluid</tag>
      
      <tag>js</tag>
      
      <tag>css</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>场景算法</title>
    <link href="/2025/01/18/%E5%9C%BA%E6%99%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/18/%E5%9C%BA%E6%99%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题-16-25-LRU缓存"><a href="#LeetCode-面试题-16-25-LRU缓存" class="headerlink" title="LeetCode 面试题 16.25. LRU缓存"></a>LeetCode 面试题 16.25. LRU缓存</h2><p>设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。<br>它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p>示例：</p><p>LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );</p><p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       &#x2F;&#x2F; 返回  1<br>cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得密钥 2 作废<br>cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)<br>cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得密钥 1 作废<br>cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)<br>cache.get(3);       &#x2F;&#x2F; 返回  3<br>cache.get(4);       &#x2F;&#x2F; 返回  4</p><p>思路：使用双向链表实现，每个节点包括k，v数据以及前驱、后继节点。此外，链表中还有虚拟节点dummy，让每个节点的pre和next均不为空，简化操作。<br>为什么要保存key？<br>在删除链表末尾节点时，需要删除哈希表中的记录，需要查找末尾节点的key。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> key, value;<br>        Node pre, next;<br><br>        Node(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v) &#123;<br>            key = k;<br>            value = v;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer,Node&gt; keyToNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        dummy.pre = dummy;<br>        dummy.next = dummy;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNode(key);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> ? node.value : -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNode(key);<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            node.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value);<br>        keyToNode.put(key,node);<br>        pushFront(node);<br>        <span class="hljs-keyword">if</span> (keyToNode.size() &gt; capacity) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">backNode</span> <span class="hljs-operator">=</span> dummy.pre;<br>            keyToNode.remove(backNode.key);<br>            remove(backNode);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (! keyToNode.containsKey(key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> keyToNode.get(key);<br>        remove(node);<br>        pushFront(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Node x)</span> &#123;<br>        x.pre.next = x.next;<br>        x.next.pre = x.pre;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushFront</span><span class="hljs-params">(Node x)</span> &#123;<br>        x.pre = dummy;<br>        x.next = dummy.next;<br>        x.pre.next = x;<br>        x.next.pre = x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手写单例模式的实现"><a href="#手写单例模式的实现" class="headerlink" title="手写单例模式的实现"></a>手写单例模式的实现</h2><h3 id="1-懒汉式"><a href="#1-懒汉式" class="headerlink" title="1.懒汉式"></a>1.懒汉式</h3><p>懒汉式单例是在第一次使用时创建实例，但这种方式在多线程环境下不安全，可能导致多个实例的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态变量，保存唯一的实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <span class="hljs-comment">// 这里是懒加载</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1懒汉式的线程安全模式"><a href="#1-1懒汉式的线程安全模式" class="headerlink" title="1.1懒汉式的线程安全模式"></a>1.1懒汉式的线程安全模式</h4><p>通过在 getInstance() 方法加锁来实现线程安全，但由于每次都加锁，可能会影响性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态变量，保存唯一的实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2双重检查锁"><a href="#1-2双重检查锁" class="headerlink" title="1.2双重检查锁"></a>1.2双重检查锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 使用 volatile 确保可见性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3静态内部类"><a href="#1-3静态内部类" class="headerlink" title="1.3静态内部类"></a>1.3静态内部类</h4><p>这种方式是线程安全的，并且延迟加载，推荐使用。JVM 确保了静态内部类只会加载一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态内部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHelper</span> &#123;<br>        <span class="hljs-comment">// 静态变量，保存唯一的实例</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHelper.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-饿汉式"><a href="#2-饿汉式" class="headerlink" title="2.饿汉式"></a>2.饿汉式</h3><p>这种方式在类加载时就创建实例，不会等到需要的时候才创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态变量，保存唯一的实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三个线程循环打印斐波那契数列"><a href="#三个线程循环打印斐波那契数列" class="headerlink" title="三个线程循环打印斐波那契数列"></a>三个线程循环打印斐波那契数列</h2><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FibonacciPrinter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <span class="hljs-comment">// 用于线程间同步</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">fib1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 斐波那契数列的第一个数字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">fib2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 斐波那契数列的第二个数字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 控制打印的次数</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建三个线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(<span class="hljs-number">2</span>));<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(<span class="hljs-number">3</span>));<br><br>        <span class="hljs-comment">// 启动线程</span><br>        thread1.start();<br>        thread2.start();<br>        thread3.start();<br>    &#125;<br><br>    <span class="hljs-comment">// 斐波那契数列打印任务</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FibonacciTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threadId;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">FibonacciTask</span><span class="hljs-params">(<span class="hljs-type">int</span> threadId)</span> &#123;<br>            <span class="hljs-built_in">this</span>.threadId = threadId;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">30</span>) &#123;  <span class="hljs-comment">// 打印30个斐波那契数列</span><br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    <span class="hljs-comment">// 判断当前线程是否轮到它打印</span><br>                    <span class="hljs-keyword">if</span> (count % <span class="hljs-number">3</span> == threadId - <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">nextFib</span> <span class="hljs-operator">=</span> fib1 + fib2;<br>                        System.out.println(<span class="hljs-string">&quot;Thread &quot;</span> + threadId + <span class="hljs-string">&quot; prints: &quot;</span> + fib1);<br>                        fib1 = fib2;<br>                        fib2 = nextFib;<br>                        count++;<br>                        lock.notifyAll();  <span class="hljs-comment">// 唤醒其他线程</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            lock.wait();  <span class="hljs-comment">// 当前线程等待</span><br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            Thread.currentThread().interrupt();<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script><div id="posts-chart"style="border-radius: 8px; height: 190px; padding: 10px;"></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>面经</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>lru</tag>
      
      <tag>JUC</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/01/18/hello-world/"/>
    <url>/2025/01/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script><div id="posts-chart"style="border-radius: 8px; height: 190px; padding: 10px;"></div>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
