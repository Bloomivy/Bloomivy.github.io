<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ArrayList源码</title>
    <link href="/2025/01/27/ArrayList%E6%BA%90%E7%A0%81/"/>
    <url>/2025/01/27/ArrayList%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="ArrayList核心源码"><a href="#ArrayList核心源码" class="headerlink" title="ArrayList核心源码"></a>ArrayList核心源码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">8683452581122892189L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认初始容量大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 空数组（用于空实例）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><br>    <span class="hljs-comment">//用于默认大小空实例的共享空数组实例。</span><br>    <span class="hljs-comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存ArrayList数据的数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ArrayList 所包含的元素个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span><br>            <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果传入的参数等于0，创建空数组</span><br>            <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//其他情况，抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span> +<br>                    initialCapacity);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认无参构造函数</span><br><span class="hljs-comment">     * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>        <span class="hljs-comment">//将指定集合转换为数组</span><br>        elementData = c.toArray();<br>        <span class="hljs-comment">//如果elementData数组的长度不为0</span><br>        <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span><br>            <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>                <span class="hljs-comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span><br>                elementData = Arrays.copyOf(elementData, size, Object[].class);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 其他情况，用空数组代替</span><br>            <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trimToSize</span><span class="hljs-params">()</span> &#123;<br>        modCount++;<br>        <span class="hljs-keyword">if</span> (size &lt; elementData.length) &#123;<br>            elementData = (size == <span class="hljs-number">0</span>)<br>                    ? EMPTY_ELEMENTDATA<br>                    : Arrays.copyOf(elementData, size);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//下面是ArrayList的扩容机制</span><br><span class="hljs-comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span><br><span class="hljs-comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> minCapacity 所需的最小容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// 如果不是默认空数组，则minExpand的值为0；</span><br>        <span class="hljs-comment">// 如果是默认空数组，则minExpand的值为10</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">minExpand</span> <span class="hljs-operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)<br>                <span class="hljs-comment">// 如果不是默认元素表，则可以使用任意大小</span><br>                ? <span class="hljs-number">0</span><br>                <span class="hljs-comment">// 如果是默认空数组，它应该已经是默认大小</span><br>                : DEFAULT_CAPACITY;<br><br>        <span class="hljs-comment">// 如果最小容量大于已有的最大容量</span><br>        <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;<br>            <span class="hljs-comment">// 根据需要的最小容量，确保容量足够</span><br>            ensureExplicitCapacity(minCapacity);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 根据给定的最小容量和当前数组元素来计算所需容量。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span><br>        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>            <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>        &#125;<br>        <span class="hljs-comment">// 否则直接返回最小容量</span><br>        <span class="hljs-keyword">return</span> minCapacity;<br>    &#125;<br><br>    <span class="hljs-comment">// 确保内部容量达到指定的最小容量。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>    &#125;<br><br>    <span class="hljs-comment">//判断是否需要扩容</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        modCount++;<br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>            grow(minCapacity);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 要分配的最大数组大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ArrayList扩容的核心方法。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>        <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>        <span class="hljs-comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br>        <span class="hljs-comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span><br>        <span class="hljs-comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span><br>        <span class="hljs-comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span><br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = hugeCapacity(minCapacity);<br>        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br><br>    <span class="hljs-comment">//比较minCapacity和 MAX_ARRAY_SIZE</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>                Integer.MAX_VALUE :<br>                MAX_ARRAY_SIZE;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中的元素数。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果此列表不包含元素，则返回 true 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//注意=和==的区别</span><br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果此列表包含指定的元素，则返回true 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span><br>        <span class="hljs-keyword">return</span> indexOf(o) &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>                <span class="hljs-keyword">if</span> (elementData[i] == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>                <span class="hljs-comment">//equals()方法比较</span><br>                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>                <span class="hljs-keyword">if</span> (elementData[i] == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="hljs-built_in">super</span>.clone();<br>            <span class="hljs-comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span><br>            v.elementData = Arrays.copyOf(elementData, size);<br>            v.modCount = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> v;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-comment">// 这不应该发生，因为我们是可以克隆的</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span><br><span class="hljs-comment">     * 返回的数组将是“安全的”，因为该列表不保留对它的引用。</span><br><span class="hljs-comment">     * （换句话说，这个方法必须分配一个新的数组）。</span><br><span class="hljs-comment">     * 因此，调用者可以自由地修改返回的数组结构。</span><br><span class="hljs-comment">     * 注意：如果元素是引用类型，修改元素的内容会影响到原列表中的对象。</span><br><span class="hljs-comment">     * 此方法充当基于数组和基于集合的API之间的桥梁。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object[] toArray() &#123;<br>        <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span><br><span class="hljs-comment">     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span><br><span class="hljs-comment">     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span><br><span class="hljs-comment">     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span><br><span class="hljs-comment">     * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<br>        <span class="hljs-keyword">if</span> (a.length &lt; size)<br>            <span class="hljs-comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span><br>            <span class="hljs-keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());<br>        <span class="hljs-comment">//调用System提供的arraycopy()方法实现数组之间的复制</span><br>        System.arraycopy(elementData, <span class="hljs-number">0</span>, a, <span class="hljs-number">0</span>, size);<br>        <span class="hljs-keyword">if</span> (a.length &gt; size)<br>            a[size] = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-comment">// Positional Access Operations</span><br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    E <span class="hljs-title function_">elementData</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> (E) elementData[index];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定位置的元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        rangeCheck(index);<br><br>        <span class="hljs-keyword">return</span> elementData(index);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用指定的元素替换此列表中指定位置的元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>        <span class="hljs-comment">//对index进行界限检查</span><br>        rangeCheck(index);<br><br>        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>        elementData[index] = element;<br>        <span class="hljs-comment">//返回原来在这个位置的元素</span><br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在此列表中的指定位置插入指定的元素。</span><br><span class="hljs-comment">     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span><br><span class="hljs-comment">     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>        rangeCheckForAdd(index);<br><br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span><br>        System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,<br>                size - index);<br>        elementData[index] = element;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        rangeCheck(index);<br><br>        modCount++;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index + <span class="hljs-number">1</span>, elementData, index,<br>                    numMoved);<br>        elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>        <span class="hljs-comment">//从列表中删除的元素</span><br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span><br><span class="hljs-comment">     * 返回true，如果此列表包含指定的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>                <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>                <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 该方法为私有的移除方法，跳过了边界检查，并且不返回被移除的值。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        modCount++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index + <span class="hljs-number">1</span>, elementData, index,<br>                    numMoved);<br>        elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 在移除元素后，将该位置的元素设为 null，以便垃圾回收器（GC）能够回收该元素。</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中删除所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        modCount++;<br><br>        <span class="hljs-comment">// 把数组中所有的元素的值设为null</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>            elementData[i] = <span class="hljs-literal">null</span>;<br><br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>        Object[] a = c.toArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;<br>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, size, numNew);<br>        size += numNew;<br>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;<br>        rangeCheckForAdd(index);<br><br>        Object[] a = c.toArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;<br>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index, elementData, index + numNew,<br>                    numMoved);<br><br>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, index, numNew);<br>        size += numNew;<br>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span><br><span class="hljs-comment">     * 将任何后续元素移动到左侧（减少其索引）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeRange</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span> &#123;<br>        modCount++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - toIndex;<br>        System.arraycopy(elementData, toIndex, elementData, fromIndex,<br>                numMoved);<br><br>        <span class="hljs-comment">// clear to let GC do its work</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newSize</span> <span class="hljs-operator">=</span> size - (toIndex - fromIndex);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> newSize; i &lt; size; i++) &#123;<br>            elementData[i] = <span class="hljs-literal">null</span>;<br>        &#125;<br>        size = newSize;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查给定的索引是否在范围内。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheck</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * add和addAll使用的rangeCheck的一个版本</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回IndexOutOfBoundsException细节信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">outOfBoundsMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Index: &quot;</span> + index + <span class="hljs-string">&quot;, Size: &quot;</span> + size;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从此列表中删除指定集合中包含的所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        Objects.requireNonNull(c);<br>        <span class="hljs-comment">//如果此列表被修改则返回true</span><br>        <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 仅保留此列表中包含在指定集合中的元素。</span><br><span class="hljs-comment">     * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        Objects.requireNonNull(c);<br>        <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-literal">true</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span><br><span class="hljs-comment">     * 指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span><br><span class="hljs-comment">     * 返回的列表迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;Index: &quot;</span> + index);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListItr</span>(index);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回列表中的列表迭代器（按适当的顺序）。</span><br><span class="hljs-comment">     * 返回的列表迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListItr</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以正确的顺序返回该列表中的元素的迭代器。</span><br><span class="hljs-comment">     * 返回的迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itr</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="ArrayList 扩容机制"></a>ArrayList 扩容机制</h1><h2 id="ArrayList-的构造函数"><a href="#ArrayList-的构造函数" class="headerlink" title="ArrayList 的构造函数"></a>ArrayList 的构造函数</h2><p>ArrayList 有三种方式来初始化，构造方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认初始容量大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 带初始容量参数的构造函数。（用户自己指定容量）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//初始容量大于0</span><br>        <span class="hljs-comment">//创建initialCapacity大小的数组</span><br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//初始容量等于0</span><br>        <span class="hljs-comment">//创建空数组</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//初始容量小于0，抛出异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span> + initialCapacity);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span><br><span class="hljs-comment"> *如果指定的集合为null，throws NullPointerException。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    elementData = c.toArray();<br>    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>            elementData = Arrays.copyOf(elementData, size, Object[].class);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</p><p>以无参构造函数创建的 ArrayList 为例分析。</p><p>add() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 加元素之前，先调用ensureCapacityInternal方法</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">// 这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ensureCapacityInternal</code> 方法的源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据给定的最小容量和当前数组元素来计算所需容量。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span><br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-comment">// 否则直接返回最小容量</span><br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br><br><span class="hljs-comment">// 确保内部容量达到指定的最小容量。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ensureCapacityInternal</code> 方法非常简单，内部直接调用了 <code>ensureExplicitCapacity</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断是否需要扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">//判断当前数组容量是否足以存储minCapacity个元素</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//调用grow方法进行扩容</span><br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>添加第 11 个元素，<code>minCapacity</code>(为 11)比 <code>elementData.length</code>（为 10）要大。进入 <code>grow</code> 方法进行扩容。</p><p>grow 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 要分配的最大数组大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ArrayList扩容的核心方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-comment">// 将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>    <span class="hljs-comment">// 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br><br>    <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span><br>    <span class="hljs-comment">// 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br><br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>,所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右。</p><p>hugeCapacity()方法</p><p>从上面 <code>grow()</code> 方法源码我们知道：如果新容量大于 <code>MAX_ARRAY_SIZE</code>,进入(执行) <code>hugeCapacity()</code> 方法来比较 <code>minCapacity</code> 和 <code>MAX_ARRAY_SIZE</code>，如果 <code>minCapacity</code> 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 <code>MAX_ARRAY_SIZE</code> 即为 <code>Integer.MAX_VALUE - 8</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>    <span class="hljs-comment">// 对minCapacity和MAX_ARRAY_SIZE进行比较</span><br>    <span class="hljs-comment">// 若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span><br>    <span class="hljs-comment">// 若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span><br>    <span class="hljs-comment">// MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>        Integer.MAX_VALUE :<br>        MAX_ARRAY_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>System.arraycopy() 和 Arrays.copyOf()方法</p><p>System.arraycopy() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*   复制数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> src 源数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> srcPos 源数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> dest 目标数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> destPos 目标数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> length 要复制的数组元素的数量</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-type">int</span>  srcPos,</span><br><span class="hljs-params">                                    Object dest, <span class="hljs-type">int</span> destPos,</span><br><span class="hljs-params">                                    <span class="hljs-type">int</span> length)</span>;<br></code></pre></td></tr></table></figure><p>Arrays.copyOf()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] copyOf(<span class="hljs-type">int</span>[] original, <span class="hljs-type">int</span> newLength) &#123;<br>    <span class="hljs-comment">// 申请一个新的数组</span><br>      <span class="hljs-type">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[newLength];<br><span class="hljs-comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span><br>      System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,<br>                       Math.min(original.length, newLength));<br>      <span class="hljs-keyword">return</span> copy;<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的代理模式</title>
    <link href="/2025/01/27/Java%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/01/27/Java%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计网相关</title>
    <link href="/2025/01/27/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/01/27/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法</title>
    <link href="/2025/01/26/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/26/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2025/01/25/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2025/01/25/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>单调队列结构</title>
    <link href="/2025/01/23/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84/"/>
    <url>/2025/01/23/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>为啥要发明「单调队列」这种结构呢，主要是为了解决下面这个场景：</p><p>给你一个数组 window，已知其最值为 A，如果给 window 中添加一个数 B，那么比较一下 A 和 B 就可以立即算出新的最值；但如果要从 window 数组中减少一个数，就不能直接得到最值了，因为如果减少的这个数恰好是 A，就需要遍历 window 中的所有元素重新寻找新的最值。</p><p>LeetCode 139.滑动窗口最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 单调队列的实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MonotonicQueue</span> &#123;<br>    LinkedList&lt;Integer&gt; maxq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 将小于 n 的元素全部删除</span><br>        <span class="hljs-keyword">while</span> (!maxq.isEmpty() &amp;&amp; maxq.getLast() &lt; n) &#123;<br>            maxq.pollLast();<br>        &#125;<br>        <span class="hljs-comment">// 然后将 n 加入尾部</span><br>        maxq.addLast(n);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> maxq.getFirst();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == maxq.getFirst()) &#123;<br>            maxq.pollFirst();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">MonotonicQueue</span> <span class="hljs-variable">window</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MonotonicQueue</span>();<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; k - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 先填满窗口的前 k - 1</span><br>                window.push(nums[i]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 窗口向前滑动，加入新数字</span><br>                window.push(nums[i]);<br>                <span class="hljs-comment">// 记录当前窗口的最大值</span><br>                res.add(window.max());<br>                <span class="hljs-comment">// 移出旧数字</span><br>                window.pop(nums[i - k + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 需要转成 int[] 数组再返回</span><br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; res.size(); i++) &#123;<br>            arr[i] = res.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2025/01/23/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2025/01/23/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a>单调栈模板</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] calculateGreaterElement(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-comment">// 存放答案的数组</span><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <br>    <span class="hljs-comment">// 倒着往栈里放</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 判定个子高矮</span><br>        <span class="hljs-keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &lt;= nums[i]) &#123;<br>            <span class="hljs-comment">// 矮个起开，反正也被挡着了。。。</span><br>            s.pop();<br>        &#125;<br>        <span class="hljs-comment">// nums[i] 身后的更大元素</span><br>        res[i] = s.isEmpty() ? -<span class="hljs-number">1</span> : s.peek();<br>        s.push(nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是单调队列解决问题的模板。for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个「个子高」元素之间的元素排除，因为他们的存在没有意义，前面挡着个「更高」的元素，所以他们不可能被作为后续进来的元素的下一个更大元素了。</p><p>分析它的时间复杂度，要从整体来看：总共有 n 个元素，每个元素都被 push 入栈了一次，而最多会被 pop 一次，没有任何冗余操作。所以总的计算规模是和元素规模 n 成正比的，也就是 O(n) 的复杂度。</p><h2 id="LeetCode-496-下一个更大的元素Ⅰ"><a href="#LeetCode-496-下一个更大的元素Ⅰ" class="headerlink" title="LeetCode 496.下一个更大的元素Ⅰ"></a>LeetCode 496.下一个更大的元素Ⅰ</h2><p>题目说 nums1 是 nums2 的子集，那么我们先把 nums2 中每个元素的下一个更大元素算出来存到一个映射里，然后再让 nums1 中的元素去查表即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] nextGreaterElement(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        <span class="hljs-comment">// 记录 nums2 中每个元素的下一个更大元素</span><br>        <span class="hljs-type">int</span>[] greater = calculateGreaterElement(nums2);<br>        <span class="hljs-comment">// 转化成映射：元素 x -&gt; x 的下一个最大元素</span><br>        HashMap&lt;Integer, Integer&gt; greaterMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums2.length; i++) &#123;<br>            greaterMap.put(nums2[i], greater[i]);<br>        &#125;<br>        <span class="hljs-comment">// nums1 是 nums2 的子集，所以根据 greaterMap 可以得到结果</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums1.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; i++) &#123;<br>            res[i] = greaterMap.get(nums1[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] calculateGreaterElement(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-comment">// 见上文</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-739-每日温度"><a href="#LeetCode-739-每日温度" class="headerlink" title="LeetCode 739.每日温度"></a>LeetCode 739.每日温度</h2><p>这个问题本质上也是找下一个更大元素，只不过现在不是问你下一个更大元素的值是多少，而是问你当前元素距离下一个更大元素的索引距离而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> temperatures.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 这里放元素索引，而不是元素</span><br>        Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <br>        <span class="hljs-comment">// 单调栈模板</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">while</span> (!s.isEmpty() &amp;&amp; temperatures[s.peek()] &lt;= temperatures[i]) &#123;<br>                s.pop();<br>            &#125;<br>            <span class="hljs-comment">// 得到索引间距</span><br>            res[i] = s.isEmpty() ? <span class="hljs-number">0</span> : (s.peek() - i); <br>            <span class="hljs-comment">// 将索引入栈，而不是元素</span><br>            s.push(i); <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-503-下一个更大的元素Ⅱ"><a href="#LeetCode-503-下一个更大的元素Ⅱ" class="headerlink" title="LeetCode 503.下一个更大的元素Ⅱ"></a>LeetCode 503.下一个更大的元素Ⅱ</h2><p>这个问题肯定还是要用单调栈的解题模板，但难点在于，比如输入是 [2,1,2,4,3]，对于最后一个元素 3，如何找到元素 4 作为下一个更大元素。</p><p>对于这种需求，常用套路就是将数组长度翻倍：</p><p>这样，元素 3 就可以找到元素 4 作为下一个更大元素了，而且其他的元素都可以被正确地计算。</p><p>有了思路，最简单的实现方式当然可以把这个双倍长度的数组构造出来，然后套用算法模板。但是，我们可以不用构造新数组，而是利用循环数组的技巧来模拟数组长度翻倍的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] nextGreaterElements(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">// 数组长度加倍模拟环形数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">// 索引 i 要求模，其他的和模板一样</span><br>            <span class="hljs-keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &lt;= nums[i % n]) &#123;<br>                s.pop();<br>            &#125;<br>            res[i % n] = s.isEmpty() ? -<span class="hljs-number">1</span> : s.peek();<br>            s.push(nums[i % n]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-1019-链表中的下一个更大节点"><a href="#LeetCode-1019-链表中的下一个更大节点" class="headerlink" title="LeetCode 1019.链表中的下一个更大节点"></a>LeetCode 1019.链表中的下一个更大节点</h2><p>这道题输入的是一条单链表，我们把它转化成数组，方便用索引访问即可直接套用<br>单调栈模板 中的 nextGreaterElement 函数逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] nextLargerNodes(ListNode head) &#123;<br>        <span class="hljs-comment">// 把单链表转化成数组，方便通过索引访问</span><br>        ArrayList&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>            nums.add(p.val);<br>        &#125;<br>        <span class="hljs-comment">// 存放答案的数组</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.size()];<br>        Stack&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">// 单调栈模板，求下一个更大元素，从后往前遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; stk.peek() &lt;= nums.get(i)) &#123;<br>                stk.pop();<br>            &#125;<br>            <span class="hljs-comment">// 本题要求没有下一个更大元素时返回 0</span><br>            res[i] = stk.isEmpty() ? <span class="hljs-number">0</span> : stk.peek();<br>            stk.push(nums.get(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-1944-队列中可以看到的人数"><a href="#LeetCode-1944-队列中可以看到的人数" class="headerlink" title="LeetCode 1944.队列中可以看到的人数"></a>LeetCode 1944.队列中可以看到的人数</h2><p>这道题显然要用到<br>单调栈技巧：靠左的高个子可以把靠右相邻的矮个子都「挤掉」，相当于计算下一个更大元素，即<br>单调栈的几种模板实现 中的 nextGreaterElement 函数。</p><p>只不过这道题不是问你下一个更大元素是多少，而是问你当前元素和下一个更大元素之间的元素个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] canSeePersonsCount(<span class="hljs-type">int</span>[] heights) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// int[] 记录 &#123;身高，小于等于该身高的人数&#125; 二元组</span><br>        Stack&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">// 记录右侧比自己矮的人</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 单调栈模板，计算下一个更大或相等元素（身高）</span><br>            <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; heights[i] &gt; stk.peek()) &#123;<br>                stk.pop();<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// 不仅可以看到比自己矮的人，如果后面存在更高的的人，也可以看到这个高人</span><br>            res[i] = stk.isEmpty() ? count : count + <span class="hljs-number">1</span>;<br>            stk.push(heights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-1475-商品折扣后的最终价格"><a href="#LeetCode-1475-商品折扣后的最终价格" class="headerlink" title="LeetCode 1475.商品折扣后的最终价格"></a>LeetCode 1475.商品折扣后的最终价格</h2><p>这道题就用到了<br>单调栈的几种模板实现 中讲到的一个单调栈模板：计算下一个更小或相等的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] finalPrices(<span class="hljs-type">int</span>[] prices) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 下一个小于等于 price[i] 的价格就是优惠券折扣</span><br>        <span class="hljs-type">int</span>[] nextElement = nextLessOrEqualElement(prices);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>            <span class="hljs-comment">// 如果存在优惠券，则减少相应的价格</span><br>            <span class="hljs-keyword">if</span> (nextElement[i] != -<span class="hljs-number">1</span>) &#123;<br>                res[i] = prices[i] - nextElement[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res[i] = prices[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 单调栈模板：计算 nums 中每个元素的下一个更小或相等的元素</span><br>    <span class="hljs-type">int</span>[] nextLessOrEqualElement(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 存放答案的数组</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">// 倒着往栈里放</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">// 删掉 nums[i] 后面较大的元素</span><br>            <span class="hljs-keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &gt; nums[i]) &#123;<br>                s.pop();<br>            &#125;<br>            <span class="hljs-comment">// 现在栈顶就是 nums[i] 身后的更小或相等元素</span><br>            res[i] = s.isEmpty() ? -<span class="hljs-number">1</span> : s.peek();<br>            s.push(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown基本语法</title>
    <link href="/2025/01/23/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2025/01/23/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Guava令牌桶</title>
    <link href="/2025/01/23/Guava%E4%BB%A4%E7%89%8C%E6%A1%B6/"/>
    <url>/2025/01/23/Guava%E4%BB%A4%E7%89%8C%E6%A1%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Guava-令牌桶"><a href="#Guava-令牌桶" class="headerlink" title="Guava 令牌桶"></a>Guava 令牌桶</h1><p>Guava 是 Google 提供的一个开源 Java 库，RateLimiter 是 Guava 中实现令牌桶限流机制的核心工具。Guava 的令牌桶实现基于 RateLimiter 类，它通过令牌的生成来控制并限制请求的速率，确保系统在一定时间窗口内不会被过多请求淹没，从而起到保护系统和保证服务质量的作用。</p><h2 id="Guava-令牌桶的特点"><a href="#Guava-令牌桶的特点" class="headerlink" title="Guava 令牌桶的特点"></a>Guava 令牌桶的特点</h2><ul><li><p>平滑限流：Guava 通过令牌的生成速率来确保流量的平滑度。RateLimiter 默认采用的是“平滑突发限流”（Smooth Bursty），它允许一定的流量突发。</p></li><li><p>平滑预热限流：Guava 还提供了一种“平滑预热限流”（Smooth Warming Up），当系统启动时，令牌生成速度逐渐增加，适用于服务在冷启动或需要预热阶段的场景。</p></li><li><p>灵活配置：可以根据实际需求设置令牌的生成速率，并提供灵活的参数配置。</p></li></ul><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="RateLimiter-使用"><a href="#RateLimiter-使用" class="headerlink" title="RateLimiter 使用"></a>RateLimiter 使用</h2><p>在 onMessage() 消息消费方法中，通过 acquire() 方法可获取令牌，若成功获取了令牌，则正常执行后续代码；如果没有令牌可用，将阻塞，直到获得为止。</p><h2 id="搭配-Nacos-动态配置"><a href="#搭配-Nacos-动态配置" class="headerlink" title="搭配 Nacos 动态配置"></a>搭配 Nacos 动态配置</h2><p>在生产环境中，服务往往是以集群的方式部署，假设 3 个服务实例构建成一个最基础的集群，数据库每秒能够承受 5000 的并发访问，则平摊到每个服务实例，应该配置为每秒生成 1666 个令牌：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123141829627.jpg" alt="Loading"></p><p>但是生产环境中，集群的实例数往往随时会发生变动，如果集群压力过大，顶不住目前的流量，运维可能会加机器，比如将 3 实例的集群扩展为 5 实例的集群，那么代码中写死的每秒令牌生成数就不对了，应该变更为 5000 &#x2F; 5 &#x3D; 1000，即每秒生成 1000 个令牌，以维持数据库每秒最大能够承受的访问量。</p><p>关于每秒生成的令牌数，完全可以添加到 Nacos 配置中心中。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Guava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Caffeine</title>
    <link href="/2025/01/23/Caffeine/"/>
    <url>/2025/01/23/Caffeine/</url>
    
    <content type="html"><![CDATA[<h1 id="Caffeine-介绍"><a href="#Caffeine-介绍" class="headerlink" title="Caffeine 介绍"></a>Caffeine 介绍</h1><p>Caffeine 是一个高性能、轻量级的 Java 缓存库，旨在提供简单易用的 API 和强大的功能集合。它由 Google 的工程师 Ben Manes 开发，并在多个 Google 内部项目中广泛使用。Caffeine 作为 Java 应用程序中的缓存解决方案，旨在提高应用程序的性能和响应速度，通过减少对外部系统的依赖来加快数据访问的速度。</p><p>Caffeine 的特性如下：</p><ul><li><p>高性能：Caffeine 优化了内部结构，使得缓存操作非常快速。它使用了高效的数据结构和算法，如哈希表和跳表，以及并发友好的实现策略。</p></li><li><p>内存效率：Caffeine 采用了一种称为 Window TinyLFU (W-TinyLFU) 的淘汰策略，它综合了 LRU 和 LFU 的优点，能够更智能地管理缓存中的条目。这种策略可以有效地利用有限的内存资源，同时保持较高的缓存命中率。</p></li><li><p>易于使用：Caffeine 提供了一个简洁的 API，允许开发者轻松地集成缓存逻辑到现有的应用程序中。它还支持多种配置选项，可以根据具体需求进行定制。</p></li><li><p>丰富的功能：除了基本的缓存功能外，Caffeine 还提供了许多高级特性，如定时清理、异步加载、统计报告等。</p></li><li><p>高度可配置：用户可以通过多种方式来调整缓存的行为，包括设置最大容量、TTL（Time To Live，存活时间）、TID（Time To Idle，空闲时间）等参数。</p></li></ul><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Caffeine 本地缓存 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="初始化缓存"><a href="#初始化缓存" class="headerlink" title="初始化缓存"></a>初始化缓存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用户信息本地缓存</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Cache&lt;Long, FindUserByIdRspDTO&gt; LOCAL_CACHE = Caffeine.newBuilder()<br>           .initialCapacity(<span class="hljs-number">10000</span>) <span class="hljs-comment">// 设置初始容量为 10000 个条目</span><br>           .maximumSize(<span class="hljs-number">10000</span>) <span class="hljs-comment">// 设置缓存的最大容量为 10000 个条目</span><br>           .expireAfterWrite(<span class="hljs-number">1</span>, TimeUnit.HOURS) <span class="hljs-comment">// 设置缓存条目在写入后 1 小时过期</span><br>           .build();<br></code></pre></td></tr></table></figure><p>代码解释：</p><ul><li><p><code>initialCapacity</code>: 指定缓存的初始容量。这里初始容量设置为 10000。这意味着缓存最初会预留足够的空间来容纳大约 10000 个条目。这有助于减少缓存扩容的次数，提高性能。</p></li><li><p><code>maximumSize</code>: 指定缓存的最大容量。这里最大容量同样设置为 10000。当缓存中的条目数量超过这个限制时，缓存将开始根据淘汰策略来移除旧条目。这里使用的是 W-TinyLFU 淘汰策略。</p></li><li><p><code>expireAfterWrite</code>: 这个配置指定了缓存条目写入后多久过期。在上面代码中，设置为 1 小时。这意味着一旦一个条目被写入缓存，它将在 1 小时后自动过期并被清除。这有助于防止缓存中存放过时的数据。</p></li></ul><p>再通过 Jmeter 压测一波，看看对比上小节，引入了二级缓存后，性能提升了多少：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123103536839.jpg" alt="Loading"></p><p>如上图所示，吞吐量提升了 2000&#x2F;s 左右，接口响应耗时平均减少了 1ms。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Caffeine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式ID生成</title>
    <link href="/2025/01/23/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90/"/>
    <url>/2025/01/23/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是分布式ID？"><a href="#什么是分布式ID？" class="headerlink" title="什么是分布式ID？"></a>什么是分布式ID？</h1><p>分布式 ID 是指在一个分布式系统中，为每一个数据项或事件生成一个全局唯一标识符的过程。 这个标识符通常是一个长整型数字或字符串，能够跨多个服务实例和数据库集群唯一识别每一个实体，是实现数据关联和跟踪的基础。</p><p>在传统的单体应用中，ID 生成相对简单，可以通过数据库的自增字段来实现。但在微服务架构下，每个服务可能运行在不同的服务器上，甚至可能有多个实例，这就意味着每个服务都需要独立生成 ID，并且保证全局唯一性。此外，分布式 ID 还需要解决以下几个关键问题：</p><ul><li><p>一致性：所有生成的 ID 必须在分布式环境中保持一致，避免重复和冲突。</p></li><li><p>高性能：在高并发场景下，ID 生成机制不能成为系统的瓶颈。</p></li><li><p>可扩展性：随着业务的增长，ID 生成策略应该易于扩展，适应更大的负载。</p></li><li><p>容错性：即使部分服务出现故障，ID 生成也不能中断。</p></li></ul><h1 id="分布式-ID-生成方案"><a href="#分布式-ID-生成方案" class="headerlink" title="分布式 ID 生成方案"></a>分布式 ID 生成方案</h1><p>目前，业界已经发展出了多种分布式 ID 生成算法和技术，以下是常见的几种方案：</p><ol><li><p>UUID ： UUID (Universally Unique Identifier) 是一种常用的分布式 ID 生成方式, 它的标准型式包含 32 个 16 进制数字，以连字号分为五段，形式为 8-4-4-4-12 的 36 个字符，示例：550e8400-e29b-41d4-a716-446655440000。</p><p> 优点:</p><ul><li>生成性能非常高：直接本地生成，不依赖其他中间件，无网络 &#x2F; 磁盘 IO 消耗；</li></ul><p> 缺点：</p><ul><li><p>不易于存储：UUID 太长，16 字节 128 位，通常以 36 长度的字符串表示。在海量数据场景下，会消耗较大的存储空间。</p></li><li><p>信息不安全：基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</p></li><li><p>充当主键时，在特定场景下，会存在问题。如作为 MySQL 数据库的主键时，UUID 就非常不合适。</p></li><li><p>基于数据库（DB）的自增 ID ：可以单独创建一张共享的 ID 生成表，使用自增字段来生成 ID，再存到业务表主键字段中。</p></li></ul></li><li><p>基于数据库（DB）的自增 ID ：可以单独创建一张共享的 ID 生成表，使用自增字段来生成 ID，再存到业务表主键字段中。<br> 优点：</p><ul><li><p>实现非常简单，利用现有的数据库即可搞定；</p></li><li><p>ID 单调递增；</p></li></ul><p> 缺点：</p><ul><li><p>强依赖 DB，当 DB 异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。</p></li><li><p>ID 发号性能瓶颈限制在单台 MySQL 的读写性能。</p></li></ul></li><li><p>基于分布式协调服务： 利用 Zookeeper、Etcd 等分布式协调服务，可以实现 ID 的有序分配。虽然这种方法可以保证 ID 的顺序性，但引入了外部依赖，增加了系统的复杂度。</p></li><li><p>基于分布式缓存：使用 Redis 的 INCRBY 命令，可以为键 （Key）的数字增加指定增量。如果键不存在，则数值会被初始化为 0，然后再执行增量操作。</p></li><li><p>基于 Snowflake 算法（雪花算法）： Snowflake 算法由 Twitter 开发，它结合了时间戳、机器 ID 和序列号，生成 64 位的 ID，如下图所示：</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123085339179.png" alt="Loading" title="snowflake"></p><ul><li><p>1bit: 符号位（标识正负），不作使用，始终为 0，代表生成的 ID 为正数。</p></li><li><p>41-bit 时间戳: 一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）</p></li><li><p>datacenter id + worker id (10 bits): 一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（项目中可以根据实际需求来调整）。这样就可以区分不同集群&#x2F;机房的节点。</p></li><li><p>12-bit 序列号: 一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 &#x3D; 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。理论上 snowflake 方案的QPS约为 409.6w &#x2F;s，这种分配方式可以保证在任何一个 IDC 的任何一台机器在任意毫秒内生成的 ID 都是不同的。</p></li></ul><p>snowflake 雪花算法优缺点如下：</p><p>优点：</p><ul><li><p>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</p></li><li><p>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</p></li><li><p>可以根据自身业务特性分配bit位，非常灵活。</p></li></ul><p>缺点：</p><ul><li>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</li></ul><h1 id="Leaf-介绍"><a href="#Leaf-介绍" class="headerlink" title="Leaf 介绍"></a>Leaf 介绍</h1><p>Leaf 这个名字是来自德国哲学家、数学家莱布尼茨的一句话： There are no two identical leaves in the world</p><p>—— “世界上没有两片相同的树叶”</p><p>美团 Leaf 基于数据库生成以及 snowflake 雪花算法方案之上，做了进一步的优化，提供了如下两种方案：</p><ol><li>第一种：Leaf-segment 数据库方案:</li></ol><p>在使用数据库的方案上，做了如下改变：</p><p>原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用proxy server批量获取，每次获取一个segment(step决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。<br>各个业务不同的发号需求用biz_tag字段来区分，每个biz-tag的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对biz_tag分库分表就行。</p><ol start="2"><li>第二种：Leaf-snowflake 雪花算法方案:</li></ol><p>Leaf-snowflake方案完全沿用snowflake方案的bit位设计，即是“1+41+10+12”的方式组装ID号。对于workerID的分配，当服务集群数量较小的情况下，完全可以手动配置。Leaf服务规模较大，动手配置成本太高。所以使用Zookeeper持久顺序节点的特性自动对snowflake节点配置wokerID。Leaf-snowflake是按照下面几个步骤启动的：</p><p>启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。<br>如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。<br>如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。</p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>Leaf 的 GitHub 地址是：<a href="https://github.com/Meituan-Dianping/Leaf">https://github.com/Meituan-Dianping/Leaf</a> ，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123085611256.png" alt="Loading"></p><ul><li>①：leaf-core : 核心模块，包括两种方案的核心代码；</li><li>②：leaf-server : 服务端工程，用于对外提供接口获取分布式 ID，以及监控页面;</li><li>③：scripts : 数据库脚本；</li></ul><p>打开命令行工具，进入到想要存放工程的文件夹下，执行如下命令，拉取 Leaf 源码。</p><p><code>git clone https://github.com/Meituan-Dianping/Leaf.git</code></p><h2 id="准备数据库"><a href="#准备数据库" class="headerlink" title="准备数据库"></a>准备数据库</h2><p>源码拉取完毕后，还有一些前置工作。由于 Leaf-segment 方案依赖于数据库，所以还需提前将数据库、表创建好。新建一个名为 leaf 的数据库。库创建完毕后，执行如下 SQL :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE TABLE</span> `leaf_alloc` (<br>  `biz_tag` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>)  <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  `max_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1&#x27;</span>,<br>  `step` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT NULL</span>,<br>  `description` <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>)  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `update_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`biz_tag`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB;<br><br><span class="hljs-keyword">insert into</span> leaf_alloc(biz_tag, max_id, step, description) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;leaf-segment-test&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;Test leaf Segment Mode Get Id&#x27;</span>)<br></code></pre></td></tr></table></figure><p>表设计</p><ul><li><p>biz_tag : 用来区分业务，例如生成用户 ID、生成笔记 ID通过此标识隔离开来;</p></li><li><p>max_id: 表示该 biz_tag 目前所被分配的 ID 号段的最大值;</p></li><li><p>step: 表示每次分配的号段长度。</p></li></ul><p>基于数据库生成 ID, 最原始的方案是，获取 ID 每次都需要写数据库，现在只需要把 step 设置得足够大，比如 1000。那么只有当 1000 个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从1减小到了 1&#x2F;step 。</p><p>表创建完成后，再插入一条业务标识为 leaf-segment-test 的记录，step 为 2000，表示号段长度为 2000， 即每次生成 2000 个 ID 。</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>数据库准备好后，通过 IDE 打开 Leaf 源码工程，并编辑 leaf-server 模块 &#x2F;resources 资源目录中的 leaf.properties 配置文件</p><p>将 leaf.segment.enable 配置为 true , 表示开启号段模式，并配置数据库连接等信息。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">leaf.name</span>=<span class="hljs-string">com.sankuai.leaf.opensource.test</span><br><span class="hljs-attr">leaf.segment.enable</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">leaf.jdbc.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/leaf?useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="hljs-attr">leaf.jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">leaf.jdbc.password</span>=<span class="hljs-string">123456</span><br><br><span class="hljs-attr">leaf.snowflake.enable</span>=<span class="hljs-string">false</span><br><span class="hljs-comment">#leaf.snowflake.zk.address=</span><br><span class="hljs-comment">#leaf.snowflake.port=</span><br></code></pre></td></tr></table></figure><h2 id="启动-Leaf"><a href="#启动-Leaf" class="headerlink" title="启动 Leaf"></a>启动 Leaf</h2><p>数据库连接配置完毕后，运行 leaf-server 模块下的启动类，看看能否启动成功。不出意外，你会发现控制台报错如下</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123085941651.jpg" alt="Loading" title="启动时报错"></p><p>因为我们目前使用的是 8.0 版本的 MySQL, 需要对 leaf-seaver 模块的 pom.xml 添加最新的驱动</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MySQL 驱动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.29<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加完依赖后，刷新一下 Maven。 然后，编辑 &#x2F;service 包下的 SegmentService 类，在初始化数据源的时候，指定一下驱动路径，以及连接池中连接检查 SQL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">         <span class="hljs-comment">// Config dataSource</span><br>         dataSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>         dataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br><span class="hljs-comment">// 省略...</span><br>         dataSource.setValidationQuery(<span class="hljs-string">&quot;select 1&quot;</span>);<br>         dataSource.init();<br></code></pre></td></tr></table></figure><h3 id="号段模式获取分布式-ID-测试"><a href="#号段模式获取分布式-ID-测试" class="headerlink" title="号段模式获取分布式 ID 测试"></a>号段模式获取分布式 ID 测试</h3><p>测试一下号段模式获取分布式 ID。两种方案的接口地址，可在 LeafController 类中找到<br>号段模式的接口地址为<br><code>http://localhost:8080/api/segment/get/&#123;key&#125;</code></p><p>key 表示业务标识，即表中的 biz_tag 字段。比如我们想要获取 biz_tag 为 leaf-segment-test 的下一个分布式 ID, 访问接口如下<br><code>http://localhost:8080/api/segment/get/leaf-segment-test</code></p><p>浏览器访问，如下图所示，成功拿到了 ID 值, 并且每次刷新，都会一直递增下去</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123090306186.jpg" alt="Loading"></p><h3 id="监控页"><a href="#监控页" class="headerlink" title="监控页"></a>监控页</h3><p>如果想获取一些监控数据，LeafMonitorController 类中定义了对应的接口，路径如下<br><code>http://localhost:8080/cache</code></p><p>浏览器访问，效果图如下：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123090419001.jpg" alt="Loading"></p><h2 id="Docker-安装-Zookeeper"><a href="#Docker-安装-Zookeeper" class="headerlink" title="Docker 安装 Zookeeper"></a>Docker 安装 Zookeeper</h2><p>我们已经测试了美团 Leaf-segment 号段模式（依赖数据库）来获取分布式 ID , 除了该模式外，还有 Leaf-snowflake （基于雪花算法）模式，它依赖于 Zookeeper。</p><h3 id="Zookeeper-介绍"><a href="#Zookeeper-介绍" class="headerlink" title="Zookeeper 介绍"></a>Zookeeper 介绍</h3><p>Apache ZooKeeper 是一个开源的分布式协调服务，用于大型分布式系统的开发和管理。它提供了一种简单而统一的方法来解决分布式应用中常见的协调问题，如命名服务、配置管理、集群管理、组服务、分布式锁、队列管理等。ZooKeeper 通过提供一种类似文件系统的结构来存储数据，并允许客户端通过简单的 API 进行读写操作，从而简化了分布式系统的复杂度。</p><p>Zookeeper 的核心特性如下：</p><ul><li><p>一致性：对于任何更新，所有客户端都将看到相同的数据视图。这是通过 ZooKeeper 的原子性保证的，意味着所有更新要么完全成功，要么完全失败。</p></li><li><p>可靠性：一旦数据被提交，它将被持久化存储，即使在某些服务器出现故障的情况下，数据也不会丢失。</p></li><li><p>实时性：ZooKeeper 支持事件通知机制，允许客户端实时接收到数据变化的通知。</p></li><li><p>高可用性：ZooKeeper 通常以集群形式部署，可以容忍部分节点的故障，只要集群中超过半数的节点是可用的，ZooKeeper 就能继续提供服务。</p></li></ul><p>ZooKeeper 的数据模型：</p><p>ZooKeeper 使用一个层次化的命名空间来组织数据，类似于文件系统中的目录树。每个节点（称为 znode）都可以有子节点，形成树状结构。每个 znode 可以存储一定量的数据，并且可以设置访问控制列表（ACL）来控制谁可以读取或修改数据。</p><p>ZooKeeper 的应用场景：</p><ul><li><p>配置管理：ZooKeeper 可以用来集中存储和管理分布式系统中的配置信息，当配置发生变化时，可以实时通知到所有客户端。</p></li><li><p>命名服务：ZooKeeper 可以作为服务发现的注册中心，帮助客户端查找和定位服务。</p></li><li><p>集群管理：ZooKeeper 可以用于选举主节点、检测集群成员的变化、以及监控集群的健康状况。</p></li><li><p>分布式锁：ZooKeeper 提供了一种机制来实现分布式环境下的互斥访问，保证多个进程之间数据操作的正确性。</p></li><li><p>队列管理：ZooKeeper 可以用来实现分布式队列，如任务调度队列或消息队列。</p></li></ul><ol><li>下载镜像</li></ol><p>打开命令行工具，执行如下命令，拉取 Zookeeper 镜像</p><p><code>docker pull zookeeper:3.5.6</code></p><ol start="2"><li>创建挂载文件夹</li></ol><p>镜像下载完成后，在 E:&#x2F;docker&#x2F; 目录下创建 &#x2F;zookeeper 文件夹，用于存放等会启动容器时，挂载出容器内 Zookeeper 的相关配置文件，以及相关持久化数据</p><ol start="3"><li>运行容器</li></ol><p>执行如下命令，运行一个 Zookeeper 容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --name zookeeper -p <span class="hljs-number">2181</span>:<span class="hljs-number">2181</span> -e TZ=<span class="hljs-string">&quot;Asia/Shanghai&quot;</span> -v E:\docker\zookeeper\data:/data -v E:\docker\zookeeper\conf:/conf zookeeper:<span class="hljs-number">3</span>.<span class="hljs-number">5</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>参数解释</p><ul><li><p>docker run: 这是启动一个新的 Docker 容器的命令。</p></li><li><p>-d: 这个选项表示以守护进程模式（即后台）运行容器。</p></li><li><p>–name zookeeper: 给容器指定一个名字叫做 zookeeper。这可以帮助你更容易地识别和管理这个容器。</p></li><li><p>-p 2181:2181: 这是一个端口映射选项，它将宿主机的 2181 端口映射到容器内的 2181 端口。这意味着在宿主机上，你可以通过访问 localhost:2181 来连接到运行在容器内的 ZooKeeper 服务。</p></li><li><p>-e TZ&#x3D;”Asia&#x2F;Shanghai”: 这个环境变量设置将容器内部的时间区域设为上海时区（亚洲&#x2F;上海）。这样可以确保容器内的时间与你的本地时区一致。</p></li><li><p>-v E:\docker\zookeeper\data:&#x2F;data: 这是一个卷挂载选项，将宿主机上的 E:\docker\zookeeper\data 目录挂载到容器内的 &#x2F;data 目录。通常，ZooKeeper 将数据存储在 &#x2F;data 目录下，因此这个挂载点可以让你在宿主机上持久化 ZooKeeper 的数据。</p></li><li><p>-v E:\docker\zookeeper\conf:&#x2F;conf: 类似于上面的挂载，这里将宿主机上的 E:\docker\zookeeper\conf 目录挂载到容器内的 &#x2F;conf 目录。ZooKeeper 的配置文件一般位于 &#x2F;conf 目录下，这样你可以在宿主机上编辑配置文件，而不会影响到容器重启后的配置。</p></li><li><p>zookeeper:3.5.6: 这是指定使用的 Docker 镜像，这里是 ZooKeeper 版本 3.5.6 的镜像。</p></li></ul><ol start="4"><li>容器运行成功后，可通过 docker ps 命令查看正在运行中的容器，确认一下 Zookeeper 是否启动成功了</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123090748174.png" alt="Loading"></p><ol start="5"><li>进入 Zookeeper</li></ol><p>执行如下命令，进入到 Zookeeper 容器中</p><p><code>docker exec -it zookeeper bash</code></p><p>接着，执行如下命令，来启动 ZooKeeper 的命令行界面（CLI），它允许用户直接与 ZooKeeper 服务器进行交互</p><p><code>./bin/zkCli.sh</code></p><p>连接成功后，效果图如下</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123090915828.png" alt="Loading"></p><ol start="6"><li>zk 基本命令</li></ol><p>ZooKeeper CLI (zkCli) 是 ZooKeeper 分布式协调服务附带的一个命令行工具，它提供了与 ZooKeeper 服务器交互的方式。使用 zkCli，你可以执行诸如查看、创建、修改和删除 ZooKeeper 中的数据节点（znodes）的操作。</p><ul><li>ls：列出当前路径下的子节点。如：查看根节点的子节点，命令如下</li></ul><p><code>ls /</code></p><ul><li>create：创建一个新的节点 （znode）</li></ul><p><code>create /myNode &quot;hello&quot;</code></p><p>以上命令，将创建一个名为 &#x2F;myNode 的节点，并初始化其数据为 “hello”。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123091016808.png" alt="Loading"></p><ul><li>get：获取指定节点的数据和状态信息。命令如下</li></ul><p><code>get /myNode</code></p><ul><li>set：设置指定节点的数据。命令如下</li></ul><p><code>set /myNode &quot;fresh&quot;</code></p><ul><li>delete：删除指定的节点（znode） 。命令如下</li></ul><p><code>delete /myNode</code></p><p>以上命令，将删除 &#x2F;myNode 节点，注意，只有当该节点没有子节点时才有效。</p><ul><li>quit：退出 zkCli 命令行工具。效果如下：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123091241534.png" alt="Loading"></p><p>美团 Leaf-snowflake 雪花算法模式测试</p><p>编辑配置<br>首先，编辑 leaf-server 模块中的 leaf.properties 配置文件，将 snowflake 模式开启，并配置好 Zookeeper 连接地址，如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 是否开启 snowflake 模式</span><br><span class="hljs-attr">leaf.snowflake.enable</span>=<span class="hljs-literal">true</span><br><span class="hljs-comment"># snowflake 模式下的 zk 地址</span><br><span class="hljs-attr">leaf.snowflake.zk.address</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2181</span><br><span class="hljs-comment"># snowflake 模式下的服务注册端口</span><br><span class="hljs-attr">leaf.snowflake.port</span>=<span class="hljs-number">2222</span><br></code></pre></td></tr></table></figure><p>运行 Leaf<br>运行 leaf-server 项目，若控制台中提示 Snowflake Service Init Successfully , 则表示 Leaf-snowflake 模式初始化成功了</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123091358519.jpg" alt="Loading"></p><p>接口测试<br>项目启动成功后，访问如下接口，即可获取雪花算法 ID</p><p><code>/api/snowflake/get/&#123;key&#125;</code></p><p>关于参数 key , 随便填一个就行。阅读源码，查看 SnowflakeIDGenImpl 类，即可得知 key 实际并没有使用到</p><p>浏览器访问此接口，即可获取基于雪花算法生成的 ID 了，如下图所示，每次刷新结果都会不同，而且值是趋势递增的</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123091535799.jpg" alt="Loading"></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>ZooKeeper</tag>
      
      <tag>leaf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合类</title>
    <link href="/2025/01/22/Java%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <url>/2025/01/22/Java%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Java集合类框架："><a href="#Java集合类框架：" class="headerlink" title="Java集合类框架："></a>Java集合类框架：</h1><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250127150915661.png" alt="Loading"></p><h2 id="简述-Set、List、Map、Queue-四者的区别？"><a href="#简述-Set、List、Map、Queue-四者的区别？" class="headerlink" title="简述 Set、List、Map、Queue 四者的区别？"></a>简述 Set、List、Map、Queue 四者的区别？</h2><ul><li><p>List存储的元素有序可重复。</p></li><li><p>Set存储的元素不可重复。</p></li><li><p>Queue按排队规则确定先后顺序，存储的元素有序可重复。</p></li><li><p>Map使用键值对存储，key无序不可重复，value无序可重复。</p></li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList-与-Array-的区别？"><a href="#ArrayList-与-Array-的区别？" class="headerlink" title="ArrayList 与 Array 的区别？"></a>ArrayList 与 Array 的区别？</h3><ul><li><p><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</p></li><li><p><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</p></li><li><p><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 <code>Integer</code>、<code>Double</code> 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</p></li><li><p><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</p></li><li><p><code>ArrayList</code> 创建时不需要指定大小，而 <code>Array</code> 创建时必须指定大小。</p></li></ul><h3 id="ArrayList-Vector-Stack-三者的区别？"><a href="#ArrayList-Vector-Stack-三者的区别？" class="headerlink" title="ArrayList Vector Stack 三者的区别？"></a>ArrayList Vector Stack 三者的区别？</h3><ul><li><p><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code> 存储，适用于频繁的查找工作，线程不安全。</p></li><li><p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用 <code>Object[]</code> 存储，线程安全。</p></li><li><p><code>Vector</code> 和 <code>Stack</code> 两者都是线程安全的，都是使用 <code>synchronized</code> 关键字进行同步处理。</p></li><li><p><code>Stack</code> 继承自 <code>Vector</code>，是一个后进先出的栈，而 <code>Vector</code> 是一个列表。</p></li></ul><h3 id="ArrayList-可以添加-null-值吗？"><a href="#ArrayList-可以添加-null-值吗？" class="headerlink" title="ArrayList 可以添加 null 值吗？"></a>ArrayList 可以添加 null 值吗？</h3><p><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。<br>不过，不建议向 <code>ArrayList</code> 中添加 <code>null</code> 值， <code>null</code> 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</p><h3 id="ArrayList-与-LinkedList-插入与删除元素时间复杂度对比"><a href="#ArrayList-与-LinkedList-插入与删除元素时间复杂度对比" class="headerlink" title="ArrayList 与 LinkedList 插入与删除元素时间复杂度对比"></a>ArrayList 与 LinkedList 插入与删除元素时间复杂度对比</h3><ol><li>ArrayList</li></ol><ul><li><p>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</p></li><li><p>尾部插入：当 ArrayList 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</p></li><li><p>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</p></li><li><p>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</p></li><li><p>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</p></li><li><p>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</p></li></ul><ol start="2"><li>LinkedList</li></ol><ul><li><p>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</p></li><li><p>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</p></li><li><p>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，不过由于有头尾指针，可以从较近的指针出发，因此需要遍历平均 n&#x2F;4 个元素，时间复杂度为 O(n)。</p></li></ul><h4 id="LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="LinkedList 为什么不能实现 RandomAccess 接口？"></a>LinkedList 为什么不能实现 RandomAccess 接口？</h4><p><code>RandomAcess</code> 是一个标记接口，表示实现该接口的类支持随机访问。<br>但 <code>LinkedList</code> 底层实现是链表，物理上不相邻，不支持随机访问。</p><h4 id="LinkedList-与-ArrayList-异同？"><a href="#LinkedList-与-ArrayList-异同？" class="headerlink" title="LinkedList 与 ArrayList 异同？"></a>LinkedList 与 ArrayList 异同？</h4><ul><li><p>是否线程安全： <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p></li><li><p>底层数据结构：<code>ArrayList</code> 底层使用的是 <code>Object</code> 数组；<code>LinkedList</code> 底层使用的是 双向链表 数据结构</p></li><li><p>插入和删除是否受元素位置影响：<code>ArrayList</code>采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响；<code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响</p></li><li><p>是否支持快速随机访问： <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。</p></li><li><p>内存空间占用： <code>ArrayList</code> 的空间浪费主要体现在在 <code>list</code> 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p></li></ul><h4 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h4><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h3><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p><ul><li><p><code>Comparable</code> 接口实际上是出自 <code>java.lang</code> 包，它有一个 <code>compareTo(Object obj)</code> 方法用来排序；</p></li><li><p><code>Comparator</code> 接口实际上是出自 <code>java.util</code> 包，它有一个 <code>compare(Object obj1, Object obj2)</code> 方法用来排序。</p></li></ul><h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul><li><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</p></li><li><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p></li><li><p>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 <code>FIFO</code> 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p></li></ul><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。</p><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。Deque 扩展了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法。</p><h3 id="ArrayDeque-与-LinkedList-区别"><a href="#ArrayDeque-与-LinkedList-区别" class="headerlink" title="ArrayDeque 与 LinkedList 区别"></a>ArrayDeque 与 LinkedList 区别</h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能。</p><ul><li><p><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</p></li><li><p><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</p></li><li><p><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p></li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><ul><li><p>线程是否安全： <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过 <code>synchronized</code> 修饰。</p></li><li><p>效率：因为线程安全的问题，<code>HashMap</code> 的效率要比 <code>Hashtable</code> 的效率高一些。</p></li><li><p>对 Null Key 与 Null Value 的支持：<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出<code> NullPointerException</code> 。</p></li><li><p>初始容量大小和每次扩充容量大小的不同：</p><ul><li><p>创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</p></li><li><p>创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的 <code>tableSizeFor()</code> 方法保证）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p></li></ul></li><li><p>底层数据结构： JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间；<code>Hashtable</code> 没有这样的机制。</p></li><li><p>哈希函数的实现：<code>HashMap</code> 对哈希值进行了高位和低位的混合扰动处理以减少冲突，而 <code>Hashtable</code> 直接使用键的 <code>hashCode()</code> 值。</p></li></ul><h3 id="HashMap-与-HashSet-的区别"><a href="#HashMap-与-HashSet-的区别" class="headerlink" title="HashMap 与 HashSet 的区别"></a>HashMap 与 HashSet 的区别</h3><p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。</p><h3 id="HashMap-与-TreeMap-的区别"><a href="#HashMap-与-TreeMap-的区别" class="headerlink" title="HashMap 与 TreeMap 的区别"></a>HashMap 与 TreeMap 的区别</h3><p><code>TreeMap</code> 和 <code>HashMap</code> 都继承自 <code>AbstractMap</code> ，但是需要注意的是 <code>TreeMap</code> 它还实现了 <code>NavigableMap</code> 接口和 <code>SortedMap</code> 接口。</p><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p><p>实现 <code>SortedMap</code> 接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。</p><h3 id="HashSet-如何检查元素重复？"><a href="#HashSet-如何检查元素重复？" class="headerlink" title="HashSet 如何检查元素重复？"></a>HashSet 如何检查元素重复？</h3><p>无论 <code>HashSet</code> 中是否已经存在了某元素，HashSet都会直接插入，只是会在 <code>add()</code> 方法的返回值处告诉我们插入前是否存在相同元素。</p><h3 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h3><h4 id="JDK1-8以前"><a href="#JDK1-8以前" class="headerlink" title="JDK1.8以前"></a>JDK1.8以前</h4><p>JDK1.8 之前 <code>HashMap</code> 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置(n是数组长度)<br>如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p><code>HashMap</code> 中的扰动函数（<code>hash</code> 方法）是用来优化哈希值的分布。通过对原始的 <code>hashCode()</code> 进行额外处理，扰动函数可以减小由于糟糕的 <code>hashCode()</code> 实现导致的碰撞，从而提高数据的分布均匀性。</p><p>JDK1.8的 hash 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><h4 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h4><p>当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><ol><li><code>putVal()</code> 方法中执行链表转红黑树的逻辑。</li></ol><p>链表的长度大于 8 的时候，就执行 <code>treeifyBin</code> （转换红黑树）的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 遍历链表</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>    <span class="hljs-comment">// 遍历到链表最后一个节点</span><br>    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 如果链表元素个数大于TREEIFY_THRESHOLD（8）</span><br>        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>            <span class="hljs-comment">// 红黑树转换（并不会直接转换成红黑树）</span><br>            treeifyBin(tab, hash);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>        <span class="hljs-keyword">break</span>;<br>    p = e;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><code>treeifyBin()</code> 方法中判断是否真的转换为红黑树。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">// 判断当前数组的长度是否小于 64</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        <span class="hljs-comment">// 如果当前数组的长度小于 64，那么会选择先进行数组扩容</span><br>        resize();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 否则才将列表转换为红黑树</span><br><br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)<br>                hd = p;<br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>)<br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树。</p><h3 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h3><ol><li><p>位运算效率更高：位运算(&amp;)比取余运算(%)更高效。当长度为 2 的幂次方时，<code>hash % length</code> 等价于 <code>hash &amp; (length - 1)</code>。</p></li><li><p>长度是 2 的幂次方，可以让 <code>HashMap</code> 在扩容的时候更均匀。<br>举例：</p></li></ol><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dns">假设有一个元素的哈希值为 <span class="hljs-number">10101100</span><br><br>旧数组元素位置计算：<br>hash        = <span class="hljs-number">10101100</span><br>length - <span class="hljs-number">1</span>  = <span class="hljs-number">00000111</span><br>&amp; -----------------<br>index       = <span class="hljs-number">00000100</span>  (<span class="hljs-number">4</span>)<br><br>新数组元素位置计算：<br>hash        = <span class="hljs-number">10101100</span><br>length - <span class="hljs-number">1</span>  = <span class="hljs-number">00001111</span><br>&amp; -----------------<br>index       = <span class="hljs-number">00001100</span>  (<span class="hljs-number">12</span>)<br><br>看第四位（从右数）：<br><span class="hljs-number">1</span>.高位为 <span class="hljs-number">0</span>：位置不变。<br><span class="hljs-number">2</span>.高位为 <span class="hljs-number">1</span>：移动到新位置（原索引位置+原容量）。<br></code></pre></td></tr></table></figure><h3 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h3><p>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。<br>为了解决这个问题，JDK1.8 版本的 <code>HashMap</code> 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。</p><h3 id="HashMap-为什么线程不安全"><a href="#HashMap-为什么线程不安全" class="headerlink" title="HashMap 为什么线程不安全"></a>HashMap 为什么线程不安全</h3><p>JDK 1.8 后，在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。<br>多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 判断是否出现 hash 碰撞</span><br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素（处理hash冲突）</span><br>    <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种情况是这两个线程同时 put 操作导致 size 的值不正确，进而导致数据覆盖的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="HashMap-几种遍历方式"><a href="#HashMap-几种遍历方式" class="headerlink" title="HashMap 几种遍历方式"></a>HashMap 几种遍历方式</h3><h3 id="ConcurrentHashMap-与-HashTable-的区别"><a href="#ConcurrentHashMap-与-HashTable-的区别" class="headerlink" title="ConcurrentHashMap 与 HashTable 的区别"></a>ConcurrentHashMap 与 HashTable 的区别</h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><p>底层数据结构：JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p></li><li><p>实现线程安全的方式</p><ul><li><p>JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p></li><li><p>JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 <code>CAS</code> 来操作。看起来就像是优化过且线程安全的 <code>HashMap</code>。</p></li><li><p>Hashtable(同一把锁) :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p></li></ul></li></ul><h3 id="ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><a href="#ConcurrentHashMap-线程安全的具体实现方式-底层具体实现" class="headerlink" title="ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现"></a>ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</h3><ol><li>JDK1.8以前</li></ol><p>首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。<br><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。<br><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p><p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦初始化就不能改变。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。<br><code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p><ol start="2"><li>JDK1.8之后</li></ol><p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。<br>数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。<br>Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p><h3 id="JDK1-7-和-JDK1-8的ConcurrentHashMap实现有什么不同？"><a href="#JDK1-7-和-JDK1-8的ConcurrentHashMap实现有什么不同？" class="headerlink" title="JDK1.7 和 JDK1.8的ConcurrentHashMap实现有什么不同？"></a>JDK1.7 和 JDK1.8的ConcurrentHashMap实现有什么不同？</h3><ul><li><p>线程安全实现方式：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p></li><li><p>Hash 碰撞解决方法 : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</p></li><li><p>并发度：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p></li></ul><h3 id="ConcurrentHashMap-为什么key和value不能为null"><a href="#ConcurrentHashMap-为什么key和value不能为null" class="headerlink" title="ConcurrentHashMap 为什么key和value不能为null"></a>ConcurrentHashMap 为什么key和value不能为null</h3><p><code>ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是为了避免二义性。</p><p>多线程环境下，存在一个线程操作该 <code>ConcurrentHashMap</code> 时，其他的线程将该 <code>ConcurrentHashMap</code> 修改的情况，所以无法通过 <code>containsKey(key)</code> 来判断否存在这个键值对，也就没办法解决二义性问题了。</p><p>与此形成对比的是，<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。单线程环境下，不存在一个线程操作该 HashMap 时，其他的线程将该 <code>HashMap</code> 修改的情况，所以可以通过 <code>contains(key)</code>来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能测试</title>
    <link href="/2025/01/22/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <url>/2025/01/22/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>性能测试是一种检查软件、应用或系统在特定负载下表现的方法。简单来说，就是看看它们能不能承受一定的工作量，并且还能正常运作。</p><p>相关术语</p><ul><li><p>并发用户：在性能测试工具中，一般称为虚拟用户（Virtual User，简称VU），指的是现实系统中操作业务的用户。</p></li><li><p>TPS：Transaction Per Second，每秒事务数，是衡量系统性能的一个非常重要的指标。</p></li><li><p>RPS：Request Per Second，每秒请求数。RPS模式适合用于容量规划和作为限流管控的参考依据。</p></li><li><p>RT：Response Time，响应时间，指的是业务从客户端发起到客户端接收的时间。</p></li><li><p>QPS (Queries Per Second)：每秒执行的查询次数。例如，如果一个网站的首页每秒可以响应 100 次用户请求，则该页面的 QPS 为 100。</p></li></ul><p>在性能测试中，通常有两种施压模式：并发模式和RPS模式。传统方式是使用并发用户数来衡量系统的性能（站在客户端视角）。此方法一般适用于一些网页站点的压测（例如H5页面）；而RPS（Requests per second）模式主要是为了方便直接衡量系统的吞吐能力TPS（Transaction Per Second，每秒事务数）而设计的（站在服务端视角），按照被压测端需要达到TPS等量设置相应的RPS，应用场景主要是一些动态的接口API，例如登录、提交订单等等。</p><p>易混点</p><ul><li><p>TPS vs. QPS:</p><ul><li><p>TPS 关注的是整个业务流程的完成情况，例如完成一笔订单交易。</p></li><li><p>QPS 更加细化，专注于单个数据库查询或 API 调用的速度。一个TPS可能包含多个QPS。</p></li></ul></li><li><p>QPS vs. RPS:</p><ul><li><p>QPS 通常特指数据库查询的频率，API 接口的调用速率。</p></li><li><p>RPS 是指 HTTP 请求的频率，可以包括GET、POST等不同类型的操作。</p></li></ul></li><li><p>TPS vs. RPS:</p><ul><li><p>TPS 关注的是业务层面的事务处理速度。</p></li><li><p>RPS 则是针对 HTTP 协议的请求处理速度，通常比 TPS 更加频繁。</p></li></ul></li></ul><p>VU和TPS换算<br>公式描述：TPS&#x3D;VU&#x2F;RT，（RT单位：秒）。</p><p>举例说明：假如1个虚拟用户在1秒内完成1笔事务，那么TPS明显就是1。如果某笔业务响应时间是1 ms，那么1个虚拟用户在1s内能完成1000笔事务，TPS就是1000了；如果某笔业务响应时间是1s，那么1个虚拟用户在1s内只能完成1笔事务，要想达到1000 TPS，就需要1000个虚拟用户。因此可以说1个虚拟用户可以产生1000 TPS，1000个虚拟用户也可以产生1000 TPS，无非是看响应时间快慢。</p><p>如何获取VU和TPS</p><ul><li>VU获取方式：</li></ul><p>已有系统：可选取高峰时刻，在一定时间内使用系统的人数，这些人数可认为是在线用户数，并发用户数可以取10%，例如在半个小时内，使用系统的用户数为10万，那么取10%（即1万）作为并发用户数基本就够了。</p><ul><li>TPS获取方式：</li></ul><p>已有系统：可选取高峰时刻，在一定时间内（如3分钟<del>10分钟），获取系统总业务量，计算单位时间（秒）内完成的笔数，乘以2</del>5倍作为峰值的TPS，例如峰值3分钟内处理订单18万笔，平均TPS是1000，峰值TPS可以是2000~5000。</p><p>Apache JMeter是Apache组织开发的基于Java的压力测试工具。Apache JMeter具备如下特性：</p><ul><li><p>支持分布式施压。</p></li><li><p>支持图形化界面，且支持流程编排，同时支持断言、逻辑控制器等高级指令，可满足复杂业务压测需求。</p></li><li><p>扩展性强，开发、测试人员可通过编写自己的插件，满足各种压测需求。</p></li><li><p>技术生态好，有强大的开源社区支持，开发者活跃度高。<br>支持查看资源监控、性能报告，但可查看的监控和报告指标较少。</p></li><li><p>基于并发模型，受限于JVM，单机无法支持超高并发。且只支持并发施压模型，不支持吞吐量施压模型。</p></li><li><p>开源支持的分布式能力无法大规模应用到生产环境，部署成本高。</p></li><li><p>不支持测试用例管理、压测脚本管理等功能。</p></li></ul><p>Jmeter介绍</p><p>JMeter 是 Apache 组织开发的一个开源的性能测试工具，主要用于对Web应用进行功能测试和性能测试。它最初是为了进行软件性能测试而设计的，但随着时间的发展，它的功能已经扩展到可以支持多种协议的测试，包括 HTTP、HTTPS、FTP、JDBC、JMS、SMTP 等。</p><p>主要特性如下：</p><ul><li><p>多协议支持： JMeter 可以用来测试各种协议的应用程序，这使得它成为一个非常灵活的工具，适用于多种场景。</p></li><li><p>负载测试和压力测试： 它能够模拟大量用户并发访问，用于评估系统的性能和稳定性。这对于识别系统瓶颈和优化系统至关重要。</p></li><li><p>可扩展性： 通过插件和脚本，JMeter 可以扩展其功能，以适应更复杂的应用环境和测试需求。</p></li><li><p>结果分析： JMeter 提供了丰富的图表和报告功能，帮助用户直观地理解测试结果，包括响应时间、吞吐量、错误率等关键指标。</p></li><li><p>脚本录制与回放： 使用 JMeter 的代理服务器功能，可以轻松地记录用户的浏览器操作，生成测试脚本，然后进行自动化测试。</p></li><li><p>分布式测试： 支持在多台机器上进行分布式测试，从而模拟更大的负载，测试大规模并发情况下的系统表现。</p></li><li><p>跨平台： JMeter 是基于 Java 编写的，因此可以在任何安装了Java运行环境的平台上运行。</p></li><li><p>免费开源： 作为 Apache 项目的一部分，JMeter 是完全免费且开源的，这意味着用户不仅可以使用它，还可以修改和扩展其功能。</p></li><li><p>社区支持： 拥有活跃的开发者和用户社区，提供持续的支持和更新，以及大量的教程和资源。</p></li><li><p>易于学习和使用： 尽管功能强大，但 JMeter 的界面直观，对于初学者来说相对容易上手。</p></li></ul><p>下载Jmeter</p><p>访问 Jmeter 官网：<a href="https://jmeter.apache.org/download_jmeter.cgi">https://jmeter.apache.org/download_jmeter.cgi</a> ，如下图所示，下载页中提供了各个系统的压缩包，这里是 Windows 系统，点击下载 .zip 后缀的压缩包。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122211442998.png" alt="Loading"></p><p>下载完成后，右键解压，无需安装即可使用。</p><p>启动Jmeter</p><p>进入 &#x2F;bin 文件夹下，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122211702631.png" alt="Loading"></p><ul><li><p>Windows 系统，双击 jmeter.bat 启动 Jmeter;</p></li><li><p>Linux、Mac 系统，进入到 &#x2F;bin 文件夹下，执行如下命令启动：</p></li></ul><p><code>sh jmeter.sh</code></p><p>主题修改</p><p>启动成功后，界面如下图所示，默认是暗黑主题，若想修改主题，点击 Options | Look and Feel, 有多种主题可供选择</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122211934808.png" alt="Loading"></p><p>如果喜欢明亮主题，勾选 Metal 即可，然后重启即可应用最新的设置。</p><p>语言设置<br>Jmeter 默认的语言是英文，如果想修改为中文，有两种方式。</p><p>临时设置<br>一种是临时性的设置，点击菜单 Options | Choose Lanuage | Chinese（Simplified）, 即可设置为简体中文。这种方式有个弊端，当重新打开 Jmeter 后，设置就会失效，必须得重新设置。</p><p>永久设置<br>要想永久设置 Jmeter 的语言为中文，可进入到 &#x2F;bin 目录下，找到 jmeter.properties 配置文件：<br>编辑它，将语言设置项的注释放开，并修改为 zh-CN 。</p><p>Jmeter 压测 K-V 存储服务接口</p><p>在测试计划上 右键 | 添加 | 线程 | 线程组</p><p>解释一下线程组的作用：</p><ul><li><p>模拟用户行为： 线程组用于模拟多个用户同时访问服务器或应用程序。每个线程代表一个虚拟用户。</p></li><li><p>控制并发数： 线程组允许你指定同时运行的线程数量，即虚拟用户的数量。这有助于模拟不同级别的并发负载，从而评估系统的性能和稳定性。</p></li><li><p>设置循环次数： 在线程组中，你可以设置采样器的执行次数。这意味着每个虚拟用户将按照设定的次数重复执行相同的请求序列，这对于长时间的压力测试尤其有用。</p></li></ul><p>线程组添加完成后，为了能够发送 HTTP 请求，还需要在线程组上右键 | 添加 | 取样器 | HTTP 请求</p><p>为了能够查看请求接口响应结果，在 HTTP 请求上 右键 | 添加 | 监听器 | 查看结果树</p><p>以上都配置完成后，一个简单的 GET 请求就配置好了。</p><p>请求结果可以点击 响应数据 | Response Body 来查看</p><p>POST 请求</p><p>为了能够发送 application&#x2F;json 请求，还需要为 HTTP 请求右键 | 添加 | 配置元件 | HTTP 信息头管理器</p><p>添加一个请求头，Key 值为 Content-Type , Value 值为 application&#x2F;json</p><p>点击 HTTP 请求，为其添加请求入参，点击消息体数据，填写接口的 JSON 入参</p><p>运行测试之前，可以对查看结果树 右键 | 清除 ， 把之前跑测试的结果全部删除</p><p>压测接口：笔记内容新增</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122212506419.png" alt="Loading"></p><p>压测接口：笔记内容查询</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122212600873.png" alt="Loading"></p><p>Jmeter 线程组间传递 Token</p><p>通过 Jmeter 测试接口时，有些接口需要先认证，才能够请求成功的，此时就需要在请求头中设置 Token 令牌。虽然测试的时候，如下图所示，可以编辑 HTTP 信息头管理器，来写死一个 Token 令牌来达到目的。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122212719681.jpg" alt="Loading"></p><p>新增线程组：用户登录接口</p><p>在测试计划上右键，新增一个线程组，并创建用户登录接口的 HTTP 请求。</p><p>禁用线程组</p><p>我们可以在不想要运行的线程组上右键 | 禁用，以禁止执行该线程组。</p><p>JSON 提取器</p><p>为了能够提取出返参中的 Token 令牌，需要对 HTTP 请求右键 | 添加 | 后置处理器 | JSON 提取器。</p><p>调试后置处理器</p><p>为了能够调试 Token 令牌是否提取成功了，可以对 HTTP 请求右键 | 添加 | 后置处理器 | Debug PostProcessor 。</p><p>BeanShell 后置处理器</p><p>为了能够实现跨线程组传递 Token 令牌，需要在 HTTP 请求右键 | 添加 | 后置处理器 | BeanShell PostProcessor。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cassandra安装与使用</title>
    <link href="/2025/01/22/Cassandra%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/01/22/Cassandra%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Cassandra"><a href="#什么是-Cassandra" class="headerlink" title="什么是 Cassandra ?"></a>什么是 Cassandra ?</h1><p>Apache Cassandra 是一个开源的分布式 NoSQL（Not Only SQL）数据库管理系统，专为处理大规模数据量和高写入频率的工作负载而设计。它最初由 Facebook 开发，后来贡献给了 Apache 软件基金会，成为了 Apache 的一个顶级项目。</p><p>Cassandra 结合了 Google Bigtable 的数据模型和 Amazon Dynamo 的完全分布式架构，提供了以下关键特性：</p><ul><li><p>高可用性：Cassandra 是一个无单点故障的系统，它通过数据复制和一致性级别选择，确保即使在节点失败的情况下数据仍然可访问。</p></li><li><p>水平可扩展性：Cassandra 能够通过添加更多节点到集群中轻松扩展，无需停机，这使得它能够处理不断增长的数据量和用户负载。</p></li><li><p>分布式数据存储：数据在集群中的多个节点上分布存储，每个节点都是平等的，没有主从之分，这有助于提高性能和可靠性。</p></li><li><p>最终一致性：Cassandra 允许开发者选择数据的一致性和可用性之间的权衡，通过可配置的一致性级别，可以在强一致性和高可用性之间找到合适的平衡点。</p></li><li><p>数据模型：Cassandra 使用列族（column-family）的数据模型，允许以宽列的方式存储数据，非常适合存储半结构化或非结构化数据。</p></li><li><p>数据压缩和索引：Cassandra 支持数据压缩和创建二级索引，以提高存储效率和查询性能。</p></li><li><p>多数据中心复制：Cassandra 支持跨多个地理区域的数据中心复制，以实现数据的地理分布和灾难恢复。</p></li></ul><p>Cassandra 被广泛应用于需要处理大量数据和高写入负载的场景，例如社交网络、物联网（IoT）、实时数据分析和推荐系统等。由于其强大的可扩展性和高可用性，Cassandra 成为了许多大型企业如 Netflix、Digg、Twitter 等的选择。</p><h2 id="Cassandra安装"><a href="#Cassandra安装" class="headerlink" title="Cassandra安装"></a>Cassandra安装</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>执行如下命令，开始拉取 <code>cassandra</code> 最新的镜像。</p><p><code>docker pull cassandra:latest</code></p><p>拉取成功后，可执行 <code>docker images</code> 命令查看本地已下载的镜像，确认一下 <code>cassandra</code> 是否下载成功。</p><h3 id="准备挂载的文件夹"><a href="#准备挂载的文件夹" class="headerlink" title="准备挂载的文件夹"></a>准备挂载的文件夹</h3><p>在 <code>E:/docker</code> 路径下，创建一个 <code>/cassandra</code> 文件夹，用于等会启动容器时，将需要持久化的数据挂载到宿主机中，防止容器重启时数据丢失。</p><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p>前置工作完成后，执行如下命令，运行一个 <code>cassandra</code> 容器：</p><p><code>docker run --name cassandra -d -p 9042:9042 -v E:\docker\cassandra\data:/var/lib/cassandra cassandra:latest</code></p><p>各参数含义：</p><ul><li><p><code>docker run</code>: 这是 Docker 用来启动一个新的容器的命令。</p></li><li><p><code>--name cassandra</code>: 这个选项指定了容器的名称为 “cassandra”。给容器命名可以帮助你在将来更容易地识别和管理它。</p></li><li><p><code>-d</code>: 这个标志表示在后台（守护进程模式）运行容器，不会阻塞你的终端会话。</p></li><li><p><code>-p 9042:9042</code>: 这个选项进行了端口映射，将宿主机的 9042 端口映射到容器内的 9042 端口。这意味着你可以在宿主机上通过 9042 端口访问 Cassandra 容器提供的服务。Cassandra 默认使用 9042 端口作为 CQL shell 的接入点。</p></li><li><p><code>-v E:\docker\cassandra\data:/var/lib/cassandra</code>: 这是一个卷（volume）映射，将宿主机上的目录 <code>E:\docker\cassandra\data</code> 挂载到容器内的 <code>/var/lib/cassandra</code> 目录。这个目录是 Cassandra 用来存储数据和日志的地方。通过这种方式，即使容器被删除，数据也会保留在宿主机上，因为数据存储在持久化的卷中。</p></li><li><p><code>cassandra:latest</code>: 这指定了要使用的 Docker 镜像。在这里，镜像是 Cassandra 的官方镜像，并且使用了 latest 标签，意味着拉取 Cassandra 的最新版本镜像。</p></li></ul><p>执行完毕后，执行 <code>docker ps</code> 命令，可查看本地正在运行中的 <code>Docker</code> 容器，确认一下 <code>cassandra</code> 是否启动成功了。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122202326486.png" alt="Loading"></p><h2 id="Cassandra使用"><a href="#Cassandra使用" class="headerlink" title="Cassandra使用"></a>Cassandra使用</h2><ol><li>打开cqlsh命令行</li></ol><p>cassandra 容器运行成功后，执行如下命令，可进入到容器中：</p><p><code>docker exec -it cassandra /bin/sh</code></p><p>接着，执行如下命令，可打开 cqlsh 命令行工具：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">cqlsh</span><br>或<br>cqlsh <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">9042</span><br></code></pre></td></tr></table></figure><p>什么是 cqlsh ?</p><p>cqlsh 是 Cassandra Query Language Shell 的缩写，它是一个命令行工具，允许你向 Cassandra 数据库发送查询、创建表、插入数据、检索数据等。</p><p>若如下图所示，提示 Connected to Test Cluster at 127.0.0.1:9042 , 则说明已经成功连接上了 cassandra。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122202537481.png" alt="Loading" title="cassandra"></p><h2 id="CQL基本命令"><a href="#CQL基本命令" class="headerlink" title="CQL基本命令"></a>CQL基本命令</h2><p>Cassandra 基本概念<br>在学习 CQL 命令之前，先理解一下 Cassandra 中几个基本概念：</p><ul><li><p>节点（Node）：Cassandra 集群中的每个服务器称为一个节点。每个节点都存储数据，并且相互之间没有主从关系，所有节点都是对等的。</p></li><li><p>集群（Cluster）：由多个节点组成的分布式系统称为集群。集群中的节点共同工作，处理读写请求并存储数据。</p></li><li><p>数据中心（Data Center）：集群中的节点可以分布在多个数据中心，每个数据中心包含若干个节点。数据中心的划分有助于实现跨地域的高可用性。</p></li><li><p>键空间（Keyspace）：键空间是一个逻辑容器，用于管理多个表，可以理解为 MySQL 中的库。另外，键空间定义了数据复制的策略。<br>表（Table）：表是数据存储的基本单位，由行和列组成。每张表都有一个唯一的名称和定义。</p></li><li><p>主键（Primary Key）：每行数据都有一个唯一的主键。主键由分区键和可选的列组成，用于唯一标识数据行。</p></li><li><p>分区键（Partition Key）：Cassandra 使用分区键的哈希值将数据分布到不同的节点上，从而实现负载均衡和数据的水平扩展。分区键可以是单个列或多列的组合（复合分区键）。</p></li></ul><ol><li>键空间（Keyspace）</li></ol><p>打开 cqlsh 命令行，执行下面语句，来创建一个 <code>Keyspace</code>。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">KEYSPACE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> test<br><span class="hljs-keyword">WITH</span> replication = &#123;<span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;SimpleStrategy&#x27;</span>, <span class="hljs-string">&#x27;replication_factor&#x27;</span>: <span class="hljs-number">1</span>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>CREATE KEYSPACE IF NOT EXISTS</code>: 这是创建 keyspace 的命令，<code>IF NOT EXISTS</code> 是一个条件语句，确保只有当 keyspace 还未创建时才执行创建操作。这样可以防止重复创建 keyspace 导致的错误。</p></li><li><p><code>test</code>: 这是即将创建的 keyspace 的名称。keyspace 类似于传统关系型数据库中的“数据库”，是 Cassandra 中数据的最高层级容器。</p></li><li><p><code>WITH replication</code>: 这里指定了 keyspace 的复制策略和配置。复制策略决定了数据如何在集群中复制和分布。</p></li><li><p><code>&#39;class&#39;: &#39;SimpleStrategy&#39;</code>: 这里指定了复制策略的类型为 <code>SimpleStrategy</code>。<code>SimpleStrategy</code> 是一种基本的复制策略，适用于单数据中心的部署。它将数据均匀地分布到集群中的节点上。</p></li><li><p><code>&#39;replication_factor&#39;</code>: 1: 这是复制因子，表示每个数据分区的副本数量。在这个例子中，<code>replication_factor</code> 设置为 1，意味着每个数据分区只有一个副本，这通常用于测试或开发环境，但在生产环境中可能不是最佳实践，因为缺乏冗余会导致数据丢失的风险增加。</p></li></ul><ol start="2"><li>键空间创建完成后，执行如下命令，可查看所有的 <code>Keyspace</code>。</li></ol><p><code>DESCRIBE KEYSPACES;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122203134492.png" alt="Loading"></p><ol start="3"><li>如果想删除某个键空间，以及其中的所有数据，可执行如下语句。</li></ol><p><code>DROP KEYSPACE IF EXISTS test;</code></p><ol start="4"><li>键空间创建完成后，可通过 USE 命令，选择该 Keyspace ，以便后续操作它。</li></ol><p><code> USE test;</code></p><ol start="5"><li>执行如下语句，创建一张 <code>note_content</code> 笔记内容表。这里注意，由于我们是拿 Cassandra 充当 K-V 键值存储数据库，所以表中只包含两个字段（实际可以支持多字段），<code>id</code> 主键充当 <code>Key</code> , 笔记内容 <code>content</code> 充当 <code>Value</code> :</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE TABLE</span> note_content (<br>    id UUID <span class="hljs-keyword">PRIMARY KEY</span>,<br>    content TEXT<br>);<br></code></pre></td></tr></table></figure><ul><li><p><code>CREATE TABLE</code>: 这是 Cassandra 中创建新表的命令。</p></li><li><p><code>note_content</code>: 表的名称。</p></li><li><p><code>(</code> 和 <code>)</code>：这些括号包含了表的列定义和主键定义。</p></li><li><p><code>id UUID PRIMARY KEY</code>: 这里定义了表中的一个列 <code>id</code>，其数据类型是 <code>UUID</code>（通用唯一标识符）。<code>PRIMARY KEY</code> 指示 id 列是表的主键。在 Cassandra 中，主键用于唯一标识表中的每一行，同时也是数据在集群中分区的依据。</p></li><li><p><code>content TEXT</code>: 这里定义了另一个列 content，其数据类型是 TEXT。TEXT 类型用于存储文本字符串。</p></li></ul><p>为什么这里要用 UUID? 而不是笔记本身的 ID?</p><p>UUID 生成的值具有较高的随机性，因此在集群中可以提供良好的数据分布，避免热点问题。</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122203548357.png" alt="Loading"></p><ol start="6"><li>执行如下语句，查询 <code>note_content</code> 表中所有数据。</li></ol><p><code>SELECT * FROM note_content;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122203650219.png" alt="Loading"></p><ol start="7"><li>笔记内容表创建完成后，执行如下语句，插入一条数据。</li></ol><p><code>INSERT INTO note_content (id, content) VALUES (uuid(), &#39;这是一条测试笔记&#39;);</code></p><ol start="8"><li>执行如下语句，以 id 为条件来更新对应笔记内容。</li></ol><p><code>UPDATE note_content SET content = &#39;更新后的评论内容&#39; WHERE id = 7e1c4af6-9b12-4f89-a5d1-0e05f8a627c7;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122203905346.png" alt="Loading"></p><ol start="9"><li>执行如下语句，将 id 为 7e1c4af6-9b12-4f89-a5d1-0e05f8a627c7 的记录删除掉。</li></ol><p><code>DELETE FROM note_content WHERE id = 7e1c4af6-9b12-4f89-a5d1-0e05f8a627c7;</code></p><p>![Loading](<a href="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122204050982.png">https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122204050982.png</a> “)</p>]]></content>
    
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Cassandra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenFeign组件</title>
    <link href="/2025/01/22/OpenFeign%E7%BB%84%E4%BB%B6/"/>
    <url>/2025/01/22/OpenFeign%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-OpenFeign"><a href="#什么是-OpenFeign" class="headerlink" title="什么是 OpenFeign ?"></a>什么是 OpenFeign ?</h1><p>OpenFeign 是一个声明式的 HTTP 客户端，它使得我们可以非常方便地调用 HTTP 接口。OpenFeign 是 Netflix 开源的 Feign 项目的扩展，旨在与 Spring Cloud 紧密集成。它通过注解来定义接口，类似于 Spring MVC 的控制器，使得开发者可以专注于业务逻辑，而不需要关注 HTTP 请求的具体实现。</p><h2 id="OpenFeign-使用"><a href="#OpenFeign-使用" class="headerlink" title="OpenFeign 使用"></a>OpenFeign 使用</h2><ol><li>添加OpenFeign依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- OpenFeign --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 负载均衡 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>TIP : <code>OpenFeign</code> 通常和 <code>loadbalancer</code> 接口负载均衡组件搭配使用。</p><ol start="2"><li>声明 FeignClient 客户端接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = ApiConstants.SERVICE_NAME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FileFeignApi</span> &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/file&quot;</span>;<br><br>    <span class="hljs-meta">@PostMapping(value = PREFIX + &quot;/test&quot;)</span><br>    Response&lt;?&gt; test();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注：</p><ul><li><code>@FeignClient</code> 是用来标记这个接口是一个 Feign 客户端的注解。<ul><li><code>name = ApiConstants.SERVICE_NAME</code> 指定了这个 Feign 客户端所调用的服务名称。这个名称通常是在注册中心（如 Eureka 或 Nacos）中注册的服务名称。</li></ul></li><li><code>String PREFIX = &quot;/file&quot;</code> : 定义了一个前缀常量，用于接口中 URI 的路径前缀。</li><li><code>@PostMapping</code> 注解标记这个方法将执行一个 HTTP POST 请求。<ul><li><code>value = PREFIX + &quot;/test&quot;</code> 指定了这个 POST 请求的路径，这里是 <code>&quot;/file/test&quot;</code>。</li></ul></li></ul><p>2.1 创建 <code>ApiConstants</code> 常量类，定义一个服务名称常量，即本身注册到 Nacos 中的服务名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiConstants</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">SERVICE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xiaohashu-oss&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，对象存储服务就将 <code>/file/test</code> 接口的 <code>Feign</code> 客户端，封装到 <code>api</code> 模块中了，有其他服务想要调用对象存储服务的 <code>/file/test</code> 接口，只需引入 <code>xiaohashu-oss-api</code> 模块即可。</p><ol start="3"><li>启用Feign客户端<br>编辑 <code>XiaohashuUserBizApplication</code> 启动类，添加 <code>@EnableFeignClients</code> 注解，以启用引入的 <code>xiaohashu-oss-api</code> 模块中定义好的 <code>Feign</code> 客户端。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;com.quanxiaoha.xiaohashu&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaohashuUserBizApplication</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>服务间调用<br>以上工作完成后，就可以在用户服务中，注入 <code>FileFeignApi</code> 客户端，来调用对象存储服务的 <code>/file/test</code> 接口了。</li></ol><h2 id="OpenFeign-支持表单请求"><a href="#OpenFeign-支持表单请求" class="headerlink" title="OpenFeign 支持表单请求"></a>OpenFeign 支持表单请求</h2><p>针对于图片上传，普通的调用方式还不行，需要额外配置表单提交。</p><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Feign 表单提交 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign.form<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-form<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="feign-form-依赖是干嘛的？"><a href="#feign-form-依赖是干嘛的？" class="headerlink" title="feign-form 依赖是干嘛的？"></a>feign-form 依赖是干嘛的？</h3><p><code>feign-form</code> 是一个 Feign 扩展库，专门用于处理表单数据的编码。它提供了一些增强功能，使 Feign 客户端能够更方便地处理表单提交和文件上传等操作。</p><p>表单配置类<br>新建一个 <code>FeignFormConfig</code>表单配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignFormConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Encoder <span class="hljs-title function_">feignFormEncoder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringFormEncoder</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>SpringFormEncoder</code> 是 Feign 提供的一个编码器，用于处理表单提交。它将对象编码为表单数据格式（如 <code>application/x-www-form-urlencoded</code> 或 <code>multipart/form-data</code>），以便在 HTTP 请求中使用。</li></ul><h2 id="封装-Feign-调用"><a href="#封装-Feign-调用" class="headerlink" title="封装 Feign 调用"></a>封装 Feign 调用</h2><p>创建一个 <code>/rpc</code> 包，统一放置服务间调用代码，并新建 <code>OssRpcService</code> 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OssRpcService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> FileFeignApi fileFeignApi;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">uploadFile</span><span class="hljs-params">(MultipartFile file)</span> &#123;<br>        <span class="hljs-comment">// 调用对象存储服务上传文件</span><br>        Response&lt;?&gt; response = fileFeignApi.uploadFile(file);<br><br>        <span class="hljs-keyword">if</span> (!response.isSuccess()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回图片访问链接</span><br>        <span class="hljs-keyword">return</span> (String) response.getData();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将调用对象存储服务上传文件的逻辑，单独封装一层 <code>service</code>，并声明一个 <code>uploadFile()</code> 方法。方法中，若调用对象存储服务成功，则返回图片链接；否则，返回 <code>null</code> 。</p><h2 id="Feign-请求拦截器：实现-userId-服务间透传"><a href="#Feign-请求拦截器：实现-userId-服务间透传" class="headerlink" title="Feign 请求拦截器：实现 userId 服务间透传"></a>Feign 请求拦截器：实现 userId 服务间透传</h2><p>如果说，我们想在下游服务中获取当前请求对应的用户 ID , 比如，修改用户信息接口，会调用对象存储微服务，在对象存储微服务中，通过前面封装的上下文组件获取当前用户 ID，能拿的到吗？</p><p>为什么获取不到？</p><p>原因是网关路由转发到服务时，网关层会设置用户 ID 到请求头中，但是，服务之间调用是通过 <code>Feign</code> 来完成的，是没有经过网关的，下游服务再去从请求头中获取用户 ID，自然是拿不到。</p><p>如何解决上面这个问题呢？</p><p>可以为 <code>Feign</code> 单独配置一个请求拦截器，在调用其他服务时，将当前用户 ID 添加到请求头中，保证下游服务也能够通过上下文组件拿到用户 ID。</p><ol><li>配置 Feign 请求拦截器<br>将这个功能，一并放到上下文组件中。首先，编辑 <code>xiaoha-spring-boot-starter-biz-context</code> 上下文组件的 <code>pom.xml</code>, 添加 <code>feign</code> 核心依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上下文组件中，创建一个 <code>/interceptor</code> 包，用于放置拦截器，并新建 <code>FeignRequestInterceptor</code> 请求拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignRequestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RequestInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(RequestTemplate requestTemplate)</span> &#123;<br>        <span class="hljs-comment">// 获取当前上下文中的用户 ID</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> LoginUserContextHolder.getUserId();<br><br>        <span class="hljs-comment">// 若不为空，则添加到请求头中</span><br>        <span class="hljs-keyword">if</span> (Objects.nonNull(userId)) &#123;<br>            requestTemplate.header(GlobalConstants.USER_ID, String.valueOf(userId));<br>            log.info(<span class="hljs-string">&quot;########## feign 请求设置请求头 userId: &#123;&#125;&quot;</span>, userId);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>自定义 <code>Feign</code> 请求拦截器需继承自 <code>RequestInterceptor</code> 接口；</p></li><li><p>在 <code>apply()</code> 方法中，先通过 <code>LoginUserContextHolder.getUserId()</code>; 拿到当前请求对应的用户 ID;</p></li><li><p>判断若不为空，则将用户 ID 添加到请求头中，以便下游服务再次获取；</p></li></ul><ol start="2"><li>自动化配置</li></ol><p>在 <code>/config</code> 包下，新建一个 <code>FeignContextAutoConfiguration</code> 自动化配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfiguration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignContextAutoConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FeignRequestInterceptor <span class="hljs-title function_">feignRequestInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FeignRequestInterceptor</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将刚刚自定义的 <code>FeignRequestInterceptor</code> 请求拦截器，自动注入到 Spring 容器中。</li></ul><p>同时，别忘了在 <code>org.springframework.autoconfigure.AutoConfiguration.imports</code> 文件中，添加上 <code>FeignContextAutoConfiguration</code> 的完整包路径。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>OpenFeign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云OSS</title>
    <link href="/2025/01/22/%E9%98%BF%E9%87%8C%E4%BA%91OSS/"/>
    <url>/2025/01/22/%E9%98%BF%E9%87%8C%E4%BA%91OSS/</url>
    
    <content type="html"><![CDATA[<ol><li>开通服务<br>需要登录阿里云官网，并访问对象存储 OSS 产品首页：<a href="https://www.aliyun.com/product/oss">https://www.aliyun.com/product/oss</a> ，如下图所示，点击立即开通按钮，开通服务<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122170737048.png" alt="Loading" title="Aliyun OSS"><br>开通成功后，进入到对象存储 OSS 控制台， 点击 Bucket 列表，在 Bucket 列表中，点击上方的创建 Bucket 按钮，准备创建桶，填写 Bucket 相关配置项，如下：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122170900224.png" alt="Loading" title="配置"></li></ol><ul><li>模式选择：勾选自定义创建；</li><li>Bucket 名称： </li><li>地域：推荐选择离你产品使用者较近的地方，有助于提升访问速度。</li><li>阻止公共访问：关闭掉，并将读写权限修改为公共读；</li></ul><ol start="2"><li>获取 AccessKey 接入凭证<br>通过代码上传文件到 Bucket ，阿里云需要校验你的身份，还需要获取一下接入凭证。点击回到阿里云首页，将鼠标移动到登录用户的头像上，即可看到 AccessKey 选项，点击即可查看<br>将你的 AccessKeyID 以及 AccessKey Secret 复制出来</li></ol><p>编辑模块的 application-dev.yml 开发环境配置，修改一下 minio 配置项的结构，统一放置到 storage 节点下，方便统一维护。再额外加一下阿里云 OSS 需要用到的配置项，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#=================================================================</span><br><span class="hljs-comment"># 对象存储配置</span><br><span class="hljs-comment">#=================================================================</span><br><span class="hljs-attr">storage:</span><br>  <span class="hljs-attr">minio:</span><br>    <span class="hljs-attr">endpoint:</span> <span class="hljs-string">http://127.0.0.1:9000</span><br>    <span class="hljs-attr">accessKey:</span> <span class="hljs-string">xxx</span><br>    <span class="hljs-attr">secretKey:</span> <span class="hljs-string">xxx</span><br>  <span class="hljs-attr">aliyun-oss:</span><br>    <span class="hljs-attr">endpoint:</span> <span class="hljs-string">oss-cn-hangzhou.aliyuncs.com</span> <span class="hljs-comment"># 改成你自己的</span><br>    <span class="hljs-attr">accessKey:</span> <span class="hljs-string">xxx</span> <span class="hljs-comment"># 改成你自己的</span><br>    <span class="hljs-attr">secretKey:</span> <span class="hljs-string">xxx</span> <span class="hljs-comment"># 改成你自己的</span><br></code></pre></td></tr></table></figure><ol start="3"><li>添加阿里云OSS配置类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;storage.aliyun-oss&quot;)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunOSSProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> String endpoint;<br>    <span class="hljs-keyword">private</span> String accessKey;<br>    <span class="hljs-keyword">private</span> String secretKey;<br>&#125;```<br><br>添加依赖<br>```java<br> &lt;!-- 阿里云 OSS --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;<br>            &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;<br>            &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;javax.activation&lt;/groupId&gt;<br>            &lt;artifactId&gt;activation&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        &lt;!-- no more than <span class="hljs-number">2.3</span><span class="hljs-number">.3</span>--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;<br>            &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>阿里云配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunOSSConfig</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> AliyunOSSProperties aliyunOSSProperties;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构建 阿里云 OSS 客户端</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> OSS <span class="hljs-title function_">aliyunOSSClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 设置访问凭证</span><br>        <span class="hljs-type">DefaultCredentialProvider</span> <span class="hljs-variable">credentialsProvider</span> <span class="hljs-operator">=</span> CredentialsProviderFactory.newDefaultCredentialProvider(<br>                aliyunOSSProperties.getAccessKey(), aliyunOSSProperties.getSecretKey());<br><br>        <span class="hljs-comment">// 创建 OSSClient 实例</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClientBuilder</span>().build(aliyunOSSProperties.getEndpoint(), credentialsProvider);<br>    &#125;<br>&#125;```<br><br>阿里云策略实现类<br>```java<br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunOSSFileStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FileStrategy</span>  &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> AliyunOSSProperties aliyunOSSProperties;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> OSS ossClient;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">uploadFile</span><span class="hljs-params">(MultipartFile file, String bucketName)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;## 上传文件至阿里云 OSS ...&quot;</span>);<br><br>        <span class="hljs-comment">// 判断文件是否为空</span><br>        <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">null</span> || file.getSize() == <span class="hljs-number">0</span>) &#123;<br>            log.error(<span class="hljs-string">&quot;==&gt; 上传文件异常：文件大小为空 ...&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;文件大小不能为空&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 文件的原始名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFileName</span> <span class="hljs-operator">=</span> file.getOriginalFilename();<br><br>        <span class="hljs-comment">// 生成存储对象的名称（将 UUID 字符串中的 - 替换成空字符串）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString().replace(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// 获取文件的后缀，如 .jpg</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">suffix</span> <span class="hljs-operator">=</span> originalFileName.substring(originalFileName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><br>        <span class="hljs-comment">// 拼接上文件后缀，即为要存储的文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">objectName</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s%s&quot;</span>, key, suffix);<br><br>        log.info(<span class="hljs-string">&quot;==&gt; 开始上传文件至阿里云 OSS, ObjectName: &#123;&#125;&quot;</span>, objectName);<br><br>        <span class="hljs-comment">// 上传文件至阿里云 OSS</span><br>        ossClient.putObject(bucketName, objectName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(file.getInputStream().readAllBytes()));<br><br>        <span class="hljs-comment">// 返回文件的访问链接</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;https://%s.%s/%s&quot;</span>, bucketName, aliyunOSSProperties.getEndpoint(), objectName);<br>        log.info(<span class="hljs-string">&quot;==&gt; 上传文件至阿里云 OSS 成功，访问路径: &#123;&#125;&quot;</span>, url);<br>        <span class="hljs-keyword">return</span> url;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minio对象存储</title>
    <link href="/2025/01/22/Minio%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"/>
    <url>/2025/01/22/Minio%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<ol><li><p>什么是 MinIO？<br>MinIO 是一个开源的对象存储服务器。这意味着它允许你在互联网上存储大量数据，比如文件、图片、视频等，而不需要依赖传统的文件系统。MinIO 的特点在于它非常灵活、易于使用，同时也非常强大，可以在你的应用程序中方便地集成。</p></li><li><p>为什么使用 MinIO？</p></li></ol><ul><li><p>可伸缩性和性能： MinIO 允许你在需要时轻松地扩展存储容量，无需中断服务。它具有出色的性能，可以处理大量的并发读取和写入请求。</p></li><li><p>开源和自由： MinIO 是开源软件，遵循 Apache License 2.0 许可证，这意味着你可以自由地使用、修改和分发它。</p></li><li><p>容器化部署： MinIO 提供了容器化部署的支持，可以在各种平台上快速部署和运行，包括本地开发机、云服务器和容器编排环境（如 Docker）。</p></li><li><p>兼容性： MinIO 提供了 S3 兼容的 API，这意味着它可以与任何兼容 Amazon S3 的应用程序无缝集成，为你的应用程序提供强大的对象存储能力。</p></li><li><p>易用性： MinIO 的配置和管理非常简单，它提供了直观的Web控制台和命令行工具，帮助你方便地管理存储桶和对象。</p></li></ul><p>总的来说，MinIO 是一个灵活、高性能、易用且开源的对象存储解决方案，适用于各种规模的应用程序，特别是那些需要大规模数据存储和访问的项目。</p><ol start="3"><li>Docker搭建Minio服务<br>3.1 选择一个 Minio 镜像<br>然后，我们在浏览器中访问地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a> ， 输入关键词 minio&#x2F;minio, 找到 Minio 镜像：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122164023293.png" alt="Loading" title="Minio"></li></ol><p>点击进去，点击 Tags 标签选项，选择最新的一个发行版本：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122164100224.png" alt="Loading" title="Tags"></p><p>3.2 下载Minio镜像<br>打开命令行，执行该命令拉取镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull minio/minio:RELEASE.2023-09-30T07-02-29Z<br></code></pre></td></tr></table></figure><p>镜像下载成功后，执行 <code>docker images</code> , 如果列表中有 <code>minio/minio</code> 镜像，则表示镜像下载成功了：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122164239816.png" alt="Loading" title="images"></p><p>3.3 新建数据挂载目录<br>下载镜像成功后，我们在某个盘下，新建一个 &#x2F;docker 文件夹，然后在该文件夹中再新建一个 &#x2F;minio 文件夹。<br>新建该文件夹的目的是，后面通过镜像运行 Minio 容器时，可以将容器内的数据目录，挂载到宿主机的 E:\docker\minio 目录下，防止容器重启后，会导致数据丢失的问题。</p><p>3.4 运行 Docker Minio 容器<br>通过该镜像运行 <code>Minio</code> 容器，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d \<br>   -p 9000:9000 \<br>   -p 9090:9090 \<br>   --name minio \<br>   -v E:\docker\minio\data:/data \<br>   -e <span class="hljs-string">&quot;MINIO_ROOT_USER=xxx&quot;</span> \<br>   -e <span class="hljs-string">&quot;MINIO_ROOT_PASSWORD=xxx&quot;</span> \<br>   minio/minio:RELEASE.2023-09-30T07-02-29Z server /data --console-address <span class="hljs-string">&quot;:9090&quot;</span><br></code></pre></td></tr></table></figure><p>命令选型含义：</p><ul><li><code>docker run</code>: 运行 Docker 容器的命令。</li><li><code>-d</code> : 表示后台运行该容器；</li><li><code>-p 9000:9000</code>: 将宿主机的 9000 端口映射到容器的 9000 端口。MinIO 默认的 HTTP API 端口是 9000。</li><li><code>-p 9090:9090</code>: 将宿主机的 9090 端口映射到容器的 9090 端口。这是 MinIO 的 Web 控制台的端口。</li><li><code>--name minio</code>: 给容器取了一个名字，这里是 “minio”。</li><li><code>-v E:\docker\minio\data:/data</code>: 将宿主机上的 <code>E:\docker\minio\data</code> 目录映射到容器内的 <code>/data</code>目录。这是 MinIO 存储数据的地方。如果你希望数据在容器删除后仍然保存，可以将数据目录映射到宿主机。</li><li><code>-e &quot;MINIO_ROOT_USER=xxx&quot;</code>: 设置 MinIO 的管理员用户名为 “xxx”。这是用于 MinIO Web 控制台和 API 的初始管理员用户名。</li><li><code>-e &quot;MINIO_ROOT_PASSWORD=xxx&quot;</code>: 设置 MinIO 的管理员密码为 “xxx”。这是用于 MinIO Web 控制台和 API 的初始管理员密码。</li><li><code>minio/minio:RELEASE.2023-09-30T07-02-29Z</code>: 这是 MinIO 的 Docker 镜像版本。</li><li><code>server /data --console-address &quot;:9090&quot;</code>: 启动 MinIO 服务器，并将数据存储在容器内的<code>/data</code>目录。</li><li><code>--console-address &quot;:9090&quot;</code>表示 MinIO 的Web 控制台将在容器的 9090 端口上运行。</li></ul><p>执行该命令后，再执行 <code>docker ps</code> 命令，可查看正在运行的容器，若如下图所示，容器列表中出现了 <code>minio</code> ，则表示 <code>Minio</code> 后台运行成功了：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122164239344.png" alt="Loading" title="Minio"></p><ol start="4"><li><p>访问Minio控制台<br>浏览器访问地址 <a href="http://localhost:9090/">http://localhost:9090</a> ，可访问 MinIO 的 Web 控制台：<br>输入运行容器时，指定的用户名&#x2F;密码：xxx&#x2F;xxx , 进入到 Minio 的管理后台:<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122165043436.png" alt="Loading" title="后台页面"></p></li><li><p>新建一个Bucket桶<br>进入后台后，点击 Create a Bucket 创建一个 Bucket 桶，用于存储图片。<br>输入 Bucket Name, 我们将其命名为 xxx， 然后点击 Create Bucket 按钮，创建成功后，在 Buckets 列表中就可以看到刚刚新建的桶了：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122165043436.png" alt="Loading" title="创建Bucket"></p></li><li><p>设置 Bucket 为公共读<br>因为我们上传的图片需要被公网访问到，所以，还需要设置 Bucket 为公共读，默认为 Private 私有。点击想要设置的桶，然后编辑 Access Policy,将 Access Policy 选项选择为 Public 公共读，点击 Set 设置按钮,设置成功后，就可以看到 Access Policy 一栏变更为 Public 了，如下图所示:<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122165205868.png" alt="Loading"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Minio</tag>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos使用</title>
    <link href="/2025/01/22/Nacos%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/01/22/Nacos%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Nacos简介"><a href="#Nacos简介" class="headerlink" title="Nacos简介"></a>Nacos简介</h1><p>Nacos &#x2F;nɑ:kəʊs&#x2F; 是 Dynamic Naming and Configuration Service 的首字母简称，它是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p><p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p><p>Nacos主要特性：</p><ul><li><p>服务发现和服务健康检测。</p></li><li><p>动态配置服务。</p></li><li><p>动态DNS服务。</p></li><li><p>服务及其元数据管理。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122151352461.jpg" alt="Loading" title="Nacos地图"></p><h1 id="安装Nacos"><a href="#安装Nacos" class="headerlink" title="安装Nacos"></a>安装Nacos</h1><ol><li>安装包安装</li></ol><ul><li><p>Nacos 依赖 Java 环境来运行，所以，需要确保你的机器上已经安装好了 JDK 1.8+ 版本。</p></li><li><p>浏览器访问地址：<a href="https://nacos.io/download/release-history/">https://nacos.io/download/release-history/</a> ，找到 2.2.3 版本，点击并下载对应版本的安装包：</p></li><li><p>下载完成后，解压到某个文件夹下，然后进入 &#x2F;bin 目录下，打开终端：</p></li><li><p>在终端中，运行如下启动命令 ( standalone 代表着单机模式运行，非集群模式) :</p></li></ul><p><code>./startup.cmd -m standalone</code></p><ul><li>浏览器访问地址：<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> ，即可进入到 Nacos 的控制后台。</li></ul><ol start="2"><li>Docker安装Nacos</li></ol><ul><li><p>在拉取 Nacos 镜像之前，在 E:\docker 文件夹下，创建一个 &#x2F;nacos 文件夹，等会运行容器时，用于将 Nacos 容器中的配置文件、持久化文件挂载出来，防止容器重启时数据丢失的问题。</p></li><li><p>那么，下载 2.2.3 版本的 Nacos 镜像，运行命令如下：</p></li></ul><p><code>docker pull nacos/nacos-server:v2.2.3</code></p><ul><li>执行完成后，执行如下命令，查看本地已下载的镜像列表，确认一下镜像是否下载成功了：</li></ul><p><code>docker images</code></p><ul><li>镜像下载成功后，运行如下命令，运行一个 Nacos 容器：</li></ul><p><code>docker run -d --name nacos --env MODE=standalone -p 8848:8848 -p 9848:9848 nacos/nacos-server:v2.2.3</code></p><ul><li><p>命令执行完毕后，通过 docker ps 命令查看一下正在运行中的 Docker 容器，确认一下容器是否正常跑起来了。</p></li><li><p>浏览器访问地址：<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> ，即可进入到 Nacos 的控制后台。</p></li><li><p>Nacos 容器跑起来后，我们将容器中的配置文件，以及数据文件复制到宿主机中。</p></li></ul><p><code>docker cp nacos:/home/nacos/conf E:\docker\nacos</code></p><p><code>docker cp nacos:/home/nacos/data E:\docker\nacos</code></p><ul><li>最后，执行如下命令，强制删除正在运行中的 Nacos 容器：</li></ul><p><code>docker rm -f nacos</code></p><ul><li>重新跑一个正式的 Nacos 容器，运行命令如下：</li></ul><p><code>docker run -d --name nacos --privileged -e MODE=standalone -e JVM_XMX=300m -e JVM_XMS=300m -p 8848:8848 -p 9848:9848  -v E:\docker\nacos\conf:/home/nacos/conf -v E:\docker\nacos\data:/home/nacos/data -v E:\docker\nacos\logs:/home/nacos/logs nacos/nacos-server:v2.2.3</code></p><h2 id="整合-Nacos-配置中心：实现动态配置刷新"><a href="#整合-Nacos-配置中心：实现动态配置刷新" class="headerlink" title="整合 Nacos 配置中心：实现动态配置刷新"></a>整合 Nacos 配置中心：实现动态配置刷新</h2><p>什么是配置中心？</p><p>在微服务架构下，配置中心是一个专门用来集中管理和分发配置的服务。它通过提供统一的接口，帮助开发人员将所有微服务的配置项集中存储、管理和分发，确保微服务在不同环境下（如开发、测试、生产环境）能够方便地获取到对应的配置。</p><p>为什么需要配置中心？</p><ol><li><p>集中管理，简化运维： 在传统的单体应用中，配置项通常存储在本地文件中，管理和维护相对简单。但在微服务架构下，配置项分散在多个服务中，如果每个服务都单独管理自己的配置项，会导致管理复杂性增加。配置中心通过集中管理配置项，极大简化了运维工作。</p></li><li><p>环境隔离，配置灵活： 不同的环境（开发、测试、生产等）通常需要不同的配置项。配置中心支持按环境隔离配置项，使得相同的微服务在不同环境中可以方便地获取对应的配置，而无需手动修改配置文件。</p></li><li><p>动态更新，实时生效： 在业务需求变化较快的场景中，配置项的频繁修改是常态。配置中心支持配置项的动态更新和实时生效，减少了服务重启的次数，提高了系统的可用性和灵活性。</p></li><li><p>安全管理： 某些敏感配置项（如数据库密码、API 密钥等）不适合写在代码中或本地文件中。配置中心提供了安全的存储和访问机制，确保敏感信息的安全性。</p></li><li><p>统一监控，提升稳定性： 配置中心可以对所有配置项进行统一监控和管理，方便运维人员及时发现和处理配置问题，提升系统的稳定性和可靠性。</p></li></ol><p>使用Nacos配置中心</p><p>进入 Nacos 管理后台，创建配置</p><p>浏览器访问： <a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> ， 进入到 Nacos 控制台，点击创建配置按钮。</p><p>填写相关配置项：</p><p>①：Data Id : 配置的唯一标识，这里我们填写；</p><p>②：Group: 所属组，这里默认组即可；</p><p>③：配置格式：项目中使用的 YAML 格式配置， 这里也选择 YAML;</p><p>④：配置内容，将限流阈值配置复制进去；</p><p>⑤：点击发布按钮；</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122154510679.png" alt="Loading" title="创建配置"></p><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Nacos 配置中心 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>nacos-config-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.3.0-RC<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：版本 0.2.x.RELEASE 对应的是 Spring Boot 2.x 版本，版本 0.1.x.RELEASE 对应的是 Spring Boot 1.x 版本。我们是 Spring Boot 3.x, 故使用最新的 0.3.x 版本。</p><h2 id="项目配置Nacos"><a href="#项目配置Nacos" class="headerlink" title="项目配置Nacos"></a>项目配置Nacos</h2><p>依赖添加完毕后，编辑 applicaiton.yml 文件，准备添加 Nacos 相关配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">nacos:</span> <br>  <span class="hljs-attr">config:</span> <span class="hljs-comment"># Nacos 配置中心</span><br>    <span class="hljs-attr">access-key:</span> <span class="hljs-comment"># 身份验证</span><br>    <span class="hljs-attr">secret-key:</span> <span class="hljs-comment"># 身份验证</span><br>    <span class="hljs-attr">data-id:</span> <span class="hljs-string">xxx</span> <span class="hljs-comment"># 指定要加载的配置数据的 Data Id</span><br>    <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span> <span class="hljs-comment"># 指定配置数据所属的组</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 指定配置数据的格式</span><br>    <span class="hljs-attr">server-addr:</span> <span class="hljs-string">http://127.0.0.1:8848/</span> <span class="hljs-comment"># 指定 Nacos 配置中心的服务器地址</span><br>    <span class="hljs-attr">auto-refresh:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否自动刷新配置</span><br>    <span class="hljs-attr">remote-first:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否优先使用远程配置</span><br>    <span class="hljs-attr">bootstrap:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 启动时，预热配置</span><br></code></pre></td></tr></table></figure><h2 id="Nacos配置中心：动态加载Bean"><a href="#Nacos配置中心：动态加载Bean" class="headerlink" title="Nacos配置中心：动态加载Bean"></a>Nacos配置中心：动态加载Bean</h2><p>当系统发送异常时，需要给开发发送告警信息，提示开发速度修复系统问题。告警的形式可以是发送短信，也可以是发送邮件。至于具体使用哪种方式， 支持通过修改 Nacos 配置中心中的配置项来动态控制。</p><p>自定义配置</p><p>编辑 application.yml 文件，自定义一个告警类型的配置：<br>sms : 表示短信告警；<br>mail : 表示邮件告警；</p><p>添加Nacos配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">xxx</span> <span class="hljs-comment"># 应用名称</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 默认激活 dev 本地开发环境</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">http://127.0.0.1:8848</span> <span class="hljs-comment"># 指定 Nacos 配置中心的服务器地址</span><br>        <span class="hljs-attr">prefix:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span> <span class="hljs-comment"># 配置 Data Id 前缀，这里使用应用名称作为前缀</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span> <span class="hljs-comment"># 所属组</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">public</span> <span class="hljs-comment"># 命名空间</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 配置文件格式</span><br>        <span class="hljs-attr">refresh-enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否开启动态刷新</span><br></code></pre></td></tr></table></figure><p>使用<code>@RefreshScope</code> 注解<br>这个注解是干嘛的？</p><p>@RefreshScope 注解是 Spring Cloud 提供的一个注解，用于实现配置动态刷新功能。当配置中心的配置发生变化时，标注了 @RefreshScope 的 Bean 会重新加载最新的配置，而无需重启应用。</p><p>在 Nacos 配置中心的场景下，@RefreshScope 的主要功能包括：</p><ul><li><p>动态刷新配置：当 Nacos 配置中心的配置发生变化时，应用中的配置会自动更新，避免了手动重启应用的繁琐过程。</p></li><li><p>重新加载 Bean：标注了 @RefreshScope 的 Bean 会在配置变化后重新加载，确保 Bean 使用最新的配置。</p></li><li><p>与 Spring Cloud 集成：@RefreshScope 与 Spring Cloud 的配置管理机制紧密集成，能够无缝地处理配置更新事件。</p></li></ul><h2 id="Nacos命名空间应用：项目隔离"><a href="#Nacos命名空间应用：项目隔离" class="headerlink" title="Nacos命名空间应用：项目隔离"></a>Nacos命名空间应用：项目隔离</h2><p>命名空间（Namespace）是 Nacos 提供的一种逻辑隔离手段，用于对配置和服务进行分组和隔离。在 Nacos 中，命名空间通常被用于做业务隔离。</p><p>什么是业务隔离？<br>不同业务线的配置和服务可以放在不同的命名空间中，方便管理和维护。</p><p>创建命名空间</p><p>进入到 Nacos 管理后台：<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> ：点击命名空间菜单，点击新建命名空间按钮：</p><p>填写命名空间相关配置项，如下图所示：</p><p>①：命名空间 ID： 可不填，不填的话，会自动生成一长串的唯一 ID , 这里为了方便识别，手动填写；</p><p>②：命名空间名称：也可以写中文，这里填项目的拼音；</p><p>③：描述：命名空间描述性文字；</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122154611418.png" alt="Loading" title="创建命名空间"></p><h2 id="克隆配置"><a href="#克隆配置" class="headerlink" title="克隆配置"></a>克隆配置</h2><p>创建完成后，进入到配置管理 | 配置列表，在上方会发现除了 public 外，多出了一个咱们刚刚创建的 xxx 命名空间，选择该命名空间，会发现该命名空间下，还没有任何配置：<br>将 public 命名空间下的所有配置勾选，点击克隆，选择目标空间 | 开始克隆 ， 即可将 public 空间下的配置，一键复制到 xxx 命名空间下：<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122154705649.png" alt="Loading" title="克隆配置"></p><h2 id="服务注册：将认证服务注册到-Nacos-上"><a href="#服务注册：将认证服务注册到-Nacos-上" class="headerlink" title="服务注册：将认证服务注册到 Nacos 上"></a>服务注册：将认证服务注册到 Nacos 上</h2><p>在微服务架构中，服务注册是一种机制，用于将服务实例的信息（如地址、端口、健康状态等）注册到服务注册中心。服务实例启动时，会向注册中心登记自己的信息，停止时则注销。</p><p>它的作用如下：</p><ul><li><p>提供服务元数据：注册中心保存了所有服务实例的元数据，供其他服务或负载均衡器查询。</p></li><li><p>健康检查：注册中心通常会定期检查注册的服务实例的健康状况，以确保它们可用并将不可用的实例从注册列表中移除。</p></li></ul><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 服务注册发现 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-string">//</span> <span class="hljs-string">省略</span> <span class="hljs-string">...</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br> <span class="hljs-string">//</span> <span class="hljs-string">省略...</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 启用服务发现</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span> <span class="hljs-comment"># 所属组</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">xxx#</span> <span class="hljs-string">命名空间</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># 指定 Nacos 配置中心的服务器地址</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RBAC权限设计模型</title>
    <link href="/2025/01/22/RBAC%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/01/22/RBAC%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-RBAC-模型？"><a href="#什么是-RBAC-模型？" class="headerlink" title="什么是 RBAC 模型？"></a>什么是 RBAC 模型？</h1><p>RBAC（Role-Based Access Control）是一种基于角色的访问控制。它通过角色来管理用户的权限。RBAC 的核心思想是将用户与角色进行关联，并将权限分配给角色，而不是直接分配给用户。这样，通过改变用户的角色，就可以灵活地控制用户的权限。<br>RBAC 的主要组成部分包括：<br>    - 用户（User）：系统的使用者。</p><pre><code class="hljs">- 角色（Role）：权限的集合，一个角色可以包含多个权限。- 权限（Permission）：对系统资源的访问操作，如读取、写入、删除等。</code></pre><h2 id="模型扩展"><a href="#模型扩展" class="headerlink" title="模型扩展"></a>模型扩展</h2><h3 id="RBAC0"><a href="#RBAC0" class="headerlink" title="RBAC0"></a>RBAC0</h3><p>即上面所讲的 RBAC 模型，基于用户-角色-权限的模型。</p><h3 id="RBAC1：基于角色的层次模型（Role-Hierarchies）"><a href="#RBAC1：基于角色的层次模型（Role-Hierarchies）" class="headerlink" title="RBAC1：基于角色的层次模型（Role Hierarchies）"></a>RBAC1：基于角色的层次模型（Role Hierarchies）</h3><p>RBAC 1 在 RBAC 0 的基础上增加了角色层次结构（Role Hierarchies）。角色层次结构允许角色之间存在继承关系，一个角色可以继承另一个角色的权限。</p><p>主要特点：</p><ul><li><p>角色继承：一个角色可以继承另一个角色的所有权限。比如，角色B继承角色 A 的权限，那么角色 B 不仅拥有自己定义的权限，还拥有角色 A 的所有权限。</p></li><li><p>权限传递：继承关系是传递的，如果角色 C 继承角色 B，而角色 B 继承角色 A，那么角色 C 将拥有角色 A 和角色 B 的所有权限。</p></li></ul><p>优点：</p><ul><li><p>简化权限管理：通过角色继承，可以减少重复定义权限的工作。</p></li><li><p>提高灵活性：可以方便地对角色进行分层管理，满足不同层次用户的权限需求。</p></li></ul><h3 id="RBAC2：基于约束的-RBAC-模型（Constraints）"><a href="#RBAC2：基于约束的-RBAC-模型（Constraints）" class="headerlink" title="RBAC2：基于约束的 RBAC 模型（Constraints）"></a>RBAC2：基于约束的 RBAC 模型（Constraints）</h3><p>RBAC 2 同样建立在 RBAC 0 基础之上，但是增加了约束（Constraints）。约束是用于加强访问控制策略的规则或条件，可以限制用户、角色和权限的关联方式。</p><p>主要特点：</p><ul><li><p>互斥角色：某些角色不能同时赋予同一个用户。例如，审计员和财务员角色不能同时赋予同一个用户，以避免暗黑交易。</p></li><li><p>先决条件：用户要获得某个角色，必须先拥有另一个角色。例如，公司研发人员要成为高级程序员，必须先成为中级程序员。</p></li><li><p>基数约束：限制某个角色可以被赋予的用户数量。例如，某个项目的经理角色只能赋予一个用户，以确保项目的唯一责任人。</p></li></ul><p>优点：</p><ul><li><p>加强安全性：通过约束规则，可以避免权限滥用和利益冲突。</p></li><li><p>精细化管理：可以更精细地控制用户的角色分配和权限管理。</p></li></ul><h3 id="RBAC3-统一模型（Consolidated-Model）"><a href="#RBAC3-统一模型（Consolidated-Model）" class="headerlink" title="RBAC3: 统一模型（Consolidated Model）"></a>RBAC3: 统一模型（Consolidated Model）</h3><p>RBAC 3 是最全面的 RBAC 模型，它结合了 RBAC1 的角色层次结构和 RBAC2 的约束，形成一个统一的模型，提供了最大程度的灵活性和安全性。</p><p>主要特点：</p><ul><li><p>包含RBAC 1的所有功能：角色层次结构，角色继承和权限传递。</p></li><li><p>包含RBAC 2的所有功能：互斥角色、先决条件角色和角色卡数限制等约束规则。</p></li><li><p>综合管理：可以同时利用角色继承和约束规则，提供最全面的权限管理解决方案。</p></li></ul><p>优点：</p><ul><li>高灵活性：可以满足各种复杂的权限管理需求。</li></ul><p>-高安全性：通过约束规则，进一步加强权限管理的安全性。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>设计思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SaToken使用</title>
    <link href="/2025/01/22/SaToken%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/01/22/SaToken%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ol><li>什么是SaToken？</li></ol><p>Sa-Token是一个轻量级Java权限认证框架，官网地址：<a href="https://sa-token.cc/">https://sa-token.cc/</a> ，主要解决：登录认证、权限认证、单点登录、OAuth2.0、分布式Session会话、微服务网关鉴权 等一系列权限相关问题。</p><ol start="2"><li>SaToken功能</li></ol><p>Sa-Token目前主要五大功能模块：登录认证、权限认证、单点登录、OAuth2.0、微服务鉴权。<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122132955471.png" alt="Loading" title="SaToken结构图"></p><ol start="3"><li>使用配置</li></ol><p>在<code>pom.xml</code>文件引入对应依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Sa-Token 权限认证，在线文档：https://sa-token.cc --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.dev33<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sa-token-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.39.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在application.yml中填写相关配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">############## Sa-Token 配置 (文档: https://sa-token.cc) ##############<br>sa-token:<br>  # token 名称（同时也是 cookie 名称）<br>  token-name: satoken<br>  # token 有效期（单位：秒） 默认30天，-1 代表永久有效<br>  timeout: 2592000<br>  # token 最低活跃频率（单位：秒），如果 token 超过此时间没有访问系统就会被冻结，默认-1 代表不限制，永不冻结<br>  active-timeout: -1<br>  # 是否允许同一账号多地同时登录 （为 true 时允许一起登录, 为 false 时新登录挤掉旧登录）<br>  is-concurrent: true<br>  # 在多人登录同一账号时，是否共用一个 token （为 true 时所有登录共用一个 token, 为 false 时每次登录新建一个 token）<br>  is-share: true<br>  # token 风格（默认可取值：uuid、simple-uuid、random-32、random-64、random-128、tik）<br>  token-style: uuid<br>  # 是否输出操作日志<br>  is-log: true<br></code></pre></td></tr></table></figure><ol start="4"><li>自定义 Token 生成风格与请求格式</li></ol><p>在 SaToken 中，Token 风格可以通过<code> sa-token.token-style</code> 配置项来定制，默认的生成策略是 uuid 风格，值类似于 <code>623368f0-ae5e-4475-a53f-93e4225f16ae</code></p><p>SaToken 内置支持的风格有多种，大致如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">/</span> <span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=uuid</span>    <span class="hljs-string">——</span> <span class="hljs-string">uuid风格</span> <span class="hljs-string">(默认风格)</span><br><span class="hljs-string">&quot;623368f0-ae5e-4475-a53f-93e4225f16ae&quot;</span><br><br><span class="hljs-string">//</span> <span class="hljs-number">2</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=simple-uuid</span>    <span class="hljs-string">——</span> <span class="hljs-string">同上，uuid风格,</span> <span class="hljs-string">只不过去掉了中划线</span><br><span class="hljs-string">&quot;6fd4221395024b5f87edd34bc3258ee8&quot;</span><br><br><span class="hljs-string">//</span> <span class="hljs-number">3</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=random-32</span>    <span class="hljs-string">——</span> <span class="hljs-string">随机32位字符串</span><br><span class="hljs-string">&quot;qEjyPsEA1Bkc9dr8YP6okFr5umCZNR6W&quot;</span><br><br><span class="hljs-string">//</span> <span class="hljs-number">4</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=random-64</span>    <span class="hljs-string">——</span> <span class="hljs-string">随机64位字符串</span><br><span class="hljs-string">&quot;v4ueNLEpPwMtmOPMBtOOeIQsvP8z9gkMgIVibTUVjkrNrlfra5CGwQkViDjO8jcc&quot;</span><br><br><span class="hljs-string">//</span> <span class="hljs-number">5</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=random-128</span>    <span class="hljs-string">——</span> <span class="hljs-string">随机128位字符串</span><br><span class="hljs-string">&quot;nojYPmcEtrFEaN0Otpssa8I8jpk8FO53UcMZkCP9qyoHaDbKS6dxoRPky9c6QlftQ0pdzxRGXsKZmUSrPeZBOD6kJFfmfgiRyUmYWcj4WU4SSP2ilakWN1HYnIuX0Olj&quot;</span><br><br><span class="hljs-string">//</span> <span class="hljs-number">6</span><span class="hljs-string">.</span> <span class="hljs-string">token-style=tik</span>    <span class="hljs-string">——</span> <span class="hljs-string">tik风格</span><br><span class="hljs-string">&quot;gr_SwoIN0MC1ewxHX_vfCW3BothWDZMMtx__&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>自定义Token请求风格</li></ol><p>比较通用、规范的 Token 请求格式：<br><code>Authorization = Bearer + 空格 + 令牌值</code></p><p>修改SaToken配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sa-token:</span><br>  <span class="hljs-comment"># token 名称（同时也是 cookie 名称）</span><br>  <span class="hljs-attr">token-name:</span> <span class="hljs-string">Authorization</span><br>  <span class="hljs-comment"># token前缀</span><br>  <span class="hljs-attr">token-prefix:</span> <span class="hljs-string">Bearer</span><br></code></pre></td></tr></table></figure><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>在我们已经将 SaToken 权限认证框架整合进了项目。但是有个问题，当调用 <code>TestController</code> 中的登录接口 <code>/user/doLogin?username=zhang&amp;password=123456</code> ，登录成功后再重启项目，调用 <code>/user/isLogin</code> 接口，验证一下用户是否登录的时候，会发现登录已经失效了。</p><h2 id="登录失效的原因？"><a href="#登录失效的原因？" class="headerlink" title="登录失效的原因？"></a>登录失效的原因？</h2><p>Sa-Token 默认将数据保存在内存中，此模式读写速度最快，且避免了序列化与反序列化带来的性能消耗，但是此模式也有一些缺点，比如：</p><ul><li><p>重启后数据会丢失。</p></li><li><p>无法在分布式环境中共享数据。</p></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为此，Sa-Token 提供了扩展接口，你可以轻松将会话数据存储在一些专业的缓存中间件上（比如 Redis）， 做到重启数据不丢失，而且保证分布式环境下多节点的会话一致性。</p><p>项目<code>pom.xml</code>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-comment">&lt;!-- Sa-Token 整合 Redis （使用 jackson 序列化方式） --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.dev33<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sa-token-redis-jackson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;sa-token.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Sa-Token 整合 Redis （使用 jackson 序列化方式） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.dev33<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sa-token-redis-jackson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Redis 连接池 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github搭建个人图床</title>
    <link href="/2025/01/21/Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/"/>
    <url>/2025/01/21/Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="一、创建新的个人仓库"><a href="#一、创建新的个人仓库" class="headerlink" title="一、创建新的个人仓库"></a>一、创建新的个人仓库</h1><p>在Github中创建新的仓库，确保仓库为public，其他保持默认即可</p><h1 id="二、上传图片"><a href="#二、上传图片" class="headerlink" title="二、上传图片"></a>二、上传图片</h1><p>通过传统方式向Github上传图片比较麻烦，此处使用PicGO来进行图片上传。</p><h2 id="PicGO图片上传配置"><a href="#PicGO图片上传配置" class="headerlink" title="PicGO图片上传配置"></a>PicGO图片上传配置</h2><ol><li><p>在Github创建token，打开Settings -&gt; Developer settings -&gt; Personal access tokens，选择classic方式创建，最后点击 generate new token；<br> 填写相关信息时，勾选repo。<br> 注：token生成只会生成一次，需要自行记录备用。</p></li><li><p>配置PicGO。打开 图床设置 -&gt; Github 图床</p></li></ol><p><img src="https://github.com/Bloomivy/pic/blob/main/image-1.png?raw=true" alt="Loading" title="GitHub设置"></p><p>可能存在的问题：上传图片时报错：You must be logged in to use issue<br>解决方式：注册sm.ms账号，创建token，将token填入PicGO配置即可正常上传。</p><p><img src="https://github.com/Bloomivy/pic/blob/main/image-2.png?raw=true" alt="Loading" title="sm"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>差分数组</title>
    <link href="/2025/01/21/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    <url>/2025/01/21/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。<br>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 差分数组工具类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Difference</span> &#123;<br>    <span class="hljs-comment">// 差分数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] diff;<br>    <br>    <span class="hljs-comment">// 输入一个初始数组，区间操作将在这个数组上进行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Difference</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">assert</span> nums.length &gt; <span class="hljs-number">0</span>;<br>        diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-comment">// 根据初始数组构造差分数组</span><br>        diff[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            diff[i] = nums[i] - nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 给闭区间 [i, j] 增加 val（可以是负数）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> val)</span> &#123;<br>        diff[i] += val;<br>        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; diff.length) &#123;<br>            diff[j + <span class="hljs-number">1</span>] -= val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回结果数组</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] result() &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[diff.length];<br>        <span class="hljs-comment">// 根据差分数组构造结果数组</span><br>        res[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; diff.length; i++) &#123;<br>            res[i] = res[i - <span class="hljs-number">1</span>] + diff[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>差分数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和数组</title>
    <link href="/2025/01/21/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <url>/2025/01/21/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一维数组前缀和"><a href="#一维数组前缀和" class="headerlink" title="一维数组前缀和"></a>一维数组前缀和</h1><p>LeetCode 303.区域和检索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>    <span class="hljs-comment">// 前缀和数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] preSum;<br><br>    <span class="hljs-comment">// 输入一个数组，构造前缀和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// preSum[0] = 0，便于计算累加和</span><br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 计算 nums 的累加和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; preSum.length; i++) &#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 查询闭区间 [left, right] 的累加和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> preSum[right + <span class="hljs-number">1</span>] - preSum[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="矩阵前缀和"><a href="#矩阵前缀和" class="headerlink" title="矩阵前缀和"></a>矩阵前缀和</h1><p>LeetCode 304.二位区域和检索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br>    <span class="hljs-comment">// preSum[i][j] 记录矩阵 [0, 0, i-1, j-1] 的元素和</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] preSum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 构造前缀和矩阵</span><br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-comment">// 计算每个矩阵 [0, 0, i, j] 的元素和</span><br>                preSum[i][j] = preSum[i-<span class="hljs-number">1</span>][j] + preSum[i][j-<span class="hljs-number">1</span>] + matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - preSum[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算子矩阵 [x1, y1, x2, y2] 的元素和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span> &#123;<br>        <span class="hljs-comment">// 目标矩阵之和由四个相邻矩阵运算获得</span><br>        <span class="hljs-keyword">return</span> preSum[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] - preSum[x1][y2+<span class="hljs-number">1</span>] - preSum[x2+<span class="hljs-number">1</span>][y1] + preSum[x1][y1];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结-前缀和核心代码"><a href="#总结-前缀和核心代码" class="headerlink" title="总结 前缀和核心代码"></a>总结 前缀和核心代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrefixSum</span> &#123;<br>    <span class="hljs-comment">// 前缀和数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] preSum;<br><br>    <span class="hljs-comment">// 输入一个数组，构造前缀和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrefixSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// preSum[0] = 0，便于计算累加和</span><br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 计算 nums 的累加和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; preSum.length; i++) &#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 查询闭区间 [left, right] 的累加和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> preSum[right + <span class="hljs-number">1</span>] - preSum[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git相关</title>
    <link href="/2025/01/20/Git%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/01/20/Git%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h1><h1 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h1><h2 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h2><h3 id="本地创建"><a href="#本地创建" class="headerlink" title="本地创建"></a>本地创建</h3><p>在需要创建仓库的地方执行指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> demo<br><span class="hljs-built_in">cd</span> demo<br></code></pre></td></tr></table></figure><p>初始化Git仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><p>执行指令 ls -a，控制台显示.git目录。<br>进入.git目录下，执行ls -altr查看到以下文件。<br><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250122111103994.png" alt="Loading" title="命令回显"></p><h3 id="远程获取"><a href="#远程获取" class="headerlink" title="远程获取"></a>远程获取</h3><p>使用git clone 命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/git/git.git<br></code></pre></td></tr></table></figure><h2 id="Git工作区域和文件状态"><a href="#Git工作区域和文件状态" class="headerlink" title="Git工作区域和文件状态"></a>Git工作区域和文件状态</h2><p>Git主要存在三种区域。<br>在.git目录层即为工作区，通常在这一层编写代码。<br>代码编写完成后使用 git add 命令提交，提交到暂存区。<br>在暂存区的代码使用 git commit 提交到本地仓库。</p><p>Git中文件的几种状态</p><ul><li>untrack </li><li>unmodified</li><li>modified</li><li>committed<br><img src="https://github.com/Bloomivy/pic/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_21-1-2025_9212_www.bilibili.com.jpeg?raw=true" alt="Loading" title="Git文件四种状态"></li></ul><h2 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h2><p> git status 查看当前状态。<br> git add 将文件添加到暂存区，等待后续操作。<br> git commit 提交暂存区中的文件，并不提交工作区中的文件。可以使用 -m 指定提交的信息。如果不使用-m参数，git会自动进入一个交互式界面，默认使用nano编辑。<br> git log 命令查看提交记录。可以使用 – online 查看简洁的提交信息，只显示作者和提交时间。</p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>git reset </p><ul><li>git reset –soft：回退到上一个版本时，工作区和暂存区都不清空。</li><li>git reset –hard：回退到上一个版本时，工作区和暂存区会清空。</li><li>git reset –mixed：回退到上一个版本时，清空暂存区，不清空工作区。</li><li>git reflog：查看所有操作及对应的版本号，便于进行回退。</li></ul><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>git diff，默认比较工作区和暂存区的内容。<br>git diff commit，比较工作区和指定提交版本的区别。<br>git diff cached commit，比较暂存区与指定提交版本区别。<br>git diff commit1 commit2，比较两个提交的版本区别。</p><h2 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h2><p>应该忽略哪些文件：</p><ul><li>系统或软件自动生成的代码。</li><li>编译产生的中间文件和结果文件。</li><li>运行时生成的日志文件、缓存文件和临时文件。</li><li>涉及敏感信息的文件。</li></ul><h2 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h2><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>git branch xx 创建新的分支。<br>git checkout xx 切换到不同分支上。也可以用于恢复文件，存在歧义，默认切换分支。<br>git switch xx 切换不同分支。<br>git merge xx 合并分支到当前位置。</p><p>切换分支时，工作区也会随之变化。</p><h2 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h2><p>两个分支如果存在对同一文件进行不同修改，此时会发生冲突。<br>可以使用 git diff 命令查看冲突的具体内容。<br>手动修改文件再提交即可。</p><h2 id="回退和rebase"><a href="#回退和rebase" class="headerlink" title="回退和rebase"></a>回退和rebase</h2><ul><li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li><li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分搜索</title>
    <link href="/2025/01/20/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    <url>/2025/01/20/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找框架"><a href="#二分查找框架" class="headerlink" title="二分查找框架"></a>二分查找框架</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = ...;<br><br>    <span class="hljs-keyword">while</span>(...) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            ...<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = ...<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = ...<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ...;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。计算 mid 时需要防止溢出，代码中 left + (right - left) &#x2F; 2 就和 (left + right) &#x2F; 2 的结果相同，但是有效防止了 left 和 right 太大，直接相加导致溢出的情况。</p><h1 id="寻找一个数"><a href="#寻找一个数" class="headerlink" title="寻找一个数"></a>寻找一个数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 标准的二分搜索框架，搜索目标元素的索引，若不存在则返回 -1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 注意</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;   <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                <span class="hljs-comment">// 注意</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                <span class="hljs-comment">// 注意</span><br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个算法存在局限性。<br>比如说给你有序数组 nums &#x3D; [1,2,2,2,3]，target 为 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。</p><p>为什么while中left&lt;&#x3D;right，而不是&lt;？<br>因为right初始化为nums.length-1而不是nums.length。</p><h1 id="寻找左侧边界的二分搜索"><a href="#寻找左侧边界的二分搜索" class="headerlink" title="寻找左侧边界的二分搜索"></a>寻找左侧边界的二分搜索</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">left_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 注意</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>    <br>    <span class="hljs-comment">// 注意</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            <span class="hljs-comment">// 注意</span><br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用双闭区间的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">left_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 搜索区间为 [left, right]</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            <span class="hljs-comment">// 搜索区间变为 [mid+1, right]</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            <span class="hljs-comment">// 搜索区间变为 [left, mid-1]</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 收缩右侧边界</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 判断 target 是否存在于 nums 中</span><br>    <span class="hljs-comment">// 如果越界，target 肯定不存在，返回 -1</span><br>    <span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">0</span> || left &gt;= nums.length) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 判断一下 nums[left] 是不是 target</span><br>    <span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="寻找右侧边界的二分查找"><a href="#寻找右侧边界的二分查找" class="headerlink" title="寻找右侧边界的二分查找"></a>寻找右侧边界的二分查找</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">right_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 注意</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 注意</span><br>    <span class="hljs-keyword">return</span> left - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用双闭区间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">right_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 这里改成收缩左侧边界即可</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后改成返回 right</span><br>    <span class="hljs-keyword">if</span> (right &lt; <span class="hljs-number">0</span> || right &gt;= nums.length) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[right] == target ? right : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="逻辑统一"><a href="#逻辑统一" class="headerlink" title="逻辑统一"></a>逻辑统一</h1><ul><li>基本的二分查找</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">因为我们初始化 right = nums.length - 1<br>所以决定了我们的「搜索区间」是 [left, right]<br>所以决定了 <span class="hljs-keyword">while</span> (left &lt;= right)<br>同时也决定了 left = mid+1 和 right = mid-1<br><br>因为我们只需找到一个 target 的索引即可<br>所以当 nums[mid] == target 时可以立即返回<br></code></pre></td></tr></table></figure><ul><li>查找左侧边界的二分查找</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">因为我们初始化 right = nums.length<br>所以决定了我们的「搜索区间」是 [left, right)<br>所以决定了 <span class="hljs-keyword">while</span> (left &lt; right)<br>同时也决定了 left = mid + 1 和 right = mid<br><br>因为我们需找到 target 的最左侧索引<br>所以当 nums[mid] == target 时不要立即返回<br>而要收紧右侧边界以锁定左侧边界<br></code></pre></td></tr></table></figure><ul><li>查找右侧边界的二分查找</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">因为我们初始化 right = nums.length<br>所以决定了我们的「搜索区间」是 [left, right)<br>所以决定了 <span class="hljs-keyword">while</span> (left &lt; right)<br>同时也决定了 left = mid + 1 和 right = mid<br><br>因为我们需找到 target 的最右侧索引<br>所以当 nums[mid] == target 时不要立即返回<br>而要收紧左侧边界以锁定右侧边界<br><br>又因为收紧左侧边界时必须 left = mid + 1<br>所以最后无论返回 left 还是 right，必须减一<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2025/01/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2025/01/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口框架"><a href="#滑动窗口框架" class="headerlink" title="滑动窗口框架"></a>滑动窗口框架</h1><p>滑动窗口就是简单维护一个窗口，不断滑动，然后更新答案，代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (right &lt; nums.size()) &#123;<br>    <span class="hljs-comment">// 增大窗口</span><br>    window.addLast(nums[right]);<br>    right++;<br>    <br>    <span class="hljs-keyword">while</span> (window needs shrink) &#123;<br>        <span class="hljs-comment">// 缩小窗口</span><br>        window.removeFirst(nums[left]);<br>        left++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>滑动窗口的伪框架实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 滑动窗口算法伪码框架</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">slidingWindow</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">// 用合适的数据结构记录窗口中的数据，根据具体场景变通</span><br>    <span class="hljs-comment">// 比如说，我想记录窗口中元素出现的次数，就用 map</span><br>    <span class="hljs-comment">// 如果我想记录窗口中的元素和，就可以只用一个 int</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">window</span> <span class="hljs-operator">=</span> ...<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>        <span class="hljs-comment">// c 是将移入窗口的字符</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s[right];<br>        window.add(c)<br>        <span class="hljs-comment">// 增大窗口</span><br>        right++;<br>        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>        ...<br><br>        <span class="hljs-comment">// *** debug 输出的位置 ***</span><br>        <span class="hljs-comment">// 注意在最终的解法代码中不要 print</span><br>        <span class="hljs-comment">// 因为 IO 操作很耗时，可能导致超时</span><br>        printf(<span class="hljs-string">&quot;window: [%d, %d)\n&quot;</span>, left, right);<br>        <span class="hljs-comment">// ***********************</span><br><br>        <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; window needs shrink) &#123;<br>            <span class="hljs-comment">// d 是将移出窗口的字符</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s[left];<br>            window.remove(d)<br>            <span class="hljs-comment">// 缩小窗口</span><br>            left++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于滑动窗口实现的代码，时间复杂度是O(N)。</p><h2 id="LeetCode76-最小覆盖子串"><a href="#LeetCode76-最小覆盖子串" class="headerlink" title="LeetCode76.最小覆盖子串"></a>LeetCode76.最小覆盖子串</h2><p>滑动窗口实现的简单思路：<br>1.在字符串s中使用双指针中的左右指针技巧，初始化left&#x3D;right&#x3D;0，将索引左闭右开区间[left,right)称为一个窗口。<br>2.不断增大right指针扩大窗口，[left,right)，直至窗口中字符串符合要求。<br>3.此时，停止增加right，转而不断增大left缩小窗口[left,right)，直至窗口中字符串不再符合要求。同时，每次增加left，都更新结果。<br>4.重复第二、三步，直至left到达s末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>            need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 记录最小覆盖子串的起始索引及长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, len = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-comment">// c 是将移入窗口的字符</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            <span class="hljs-comment">// 扩大窗口</span><br>            right++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            <span class="hljs-keyword">if</span> (need.containsKey(c)) &#123;<br>                window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (window.get(c).equals(need.get(c)))<br>                    valid++;<br>            &#125;<br><br>            <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span> (valid == need.size()) &#123;<br>                <span class="hljs-comment">// 在这里更新最小覆盖子串</span><br>                <span class="hljs-keyword">if</span> (right - left &lt; len) &#123;<br>                    start = left;<br>                    len = right - left;<br>                &#125;<br>                <span class="hljs-comment">// d 是将移出窗口的字符</span><br>                <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left);<br>                <span class="hljs-comment">// 缩小窗口</span><br>                left++;<br>                <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>                <span class="hljs-keyword">if</span> (need.containsKey(d)) &#123;<br>                    <span class="hljs-keyword">if</span> (window.get(d).equals(need.get(d)))<br>                        valid--;<br>                    window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>                &#125;                    <br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回最小覆盖子串</span><br>        <span class="hljs-keyword">return</span> len == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(start, start + len);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-567-字符串排列"><a href="#LeetCode-567-字符串排列" class="headerlink" title="LeetCode 567.字符串排列"></a>LeetCode 567.字符串排列</h2><p>滑动窗口典型：给你一个 S 和一个 T，请问你 S 中是否存在一个子串，包含 T 中所有字符且不包含其他字符？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 判断 s 中是否存在 t 的排列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkInclusion</span><span class="hljs-params">(String t, String s)</span> &#123;<br>        Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>            need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            right++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            <span class="hljs-keyword">if</span> (need.containsKey(c)) &#123;<br>                window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (window.get(c).intValue() == need.get(c).intValue())<br>                    valid++;<br>            &#125;<br><br>            <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span> (right - left &gt;= t.length()) &#123;<br>                <span class="hljs-comment">// 在这里判断是否找到了合法的子串</span><br>                <span class="hljs-keyword">if</span> (valid == need.size())<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left);<br>                left++;<br>                <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>                <span class="hljs-keyword">if</span> (need.containsKey(d)) &#123;<br>                    <span class="hljs-keyword">if</span> (window.get(d).intValue() == need.get(d).intValue())<br>                        valid--;<br>                    window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 未找到符合条件的子串</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-438-找到字符串中所有字母异位词"><a href="#LeetCode-438-找到字符串中所有字母异位词" class="headerlink" title="LeetCode 438.找到字符串中所有字母异位词"></a>LeetCode 438.找到字符串中所有字母异位词</h2><p>相当于，输入一个串 S，一个串 T，找到 S 中所有 T 的排列，返回它们的起始索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>            need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 记录结果</span><br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            right++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            <span class="hljs-keyword">if</span> (need.containsKey(c)) &#123;<br>                window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (window.get(c).equals(need.get(c))) &#123;<br>                    valid++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span> (right - left &gt;= t.length()) &#123;<br>                <span class="hljs-comment">// 当窗口符合条件时，把起始索引加入 res</span><br>                <span class="hljs-keyword">if</span> (valid == need.size())<br>                    res.add(left);<br>                <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left);<br>                left++;<br>                <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>                <span class="hljs-keyword">if</span> (need.containsKey(d)) &#123;<br>                    <span class="hljs-keyword">if</span> (window.get(d).equals(need.get(d))) &#123;<br>                        valid--;<br>                    &#125;<br>                    window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-3-最长无重复子串"><a href="#LeetCode-3-最长无重复子串" class="headerlink" title="LeetCode 3.最长无重复子串"></a>LeetCode 3.最长无重复子串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 记录结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            right++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span> (window.get(c) &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left);<br>                left++;<br>                <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>                window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">// 在这里更新答案</span><br>            res = Math.max(res, right - left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ安装配置</title>
    <link href="/2025/01/20/RocketMQ%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/01/20/RocketMQ%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ-基本概念"><a href="#RocketMQ-基本概念" class="headerlink" title="RocketMQ 基本概念"></a>RocketMQ 基本概念</h1><p>关于 RocketMQ 相关的基本概念，可翻阅官网：<a href="https://rocketmq.apache.org/zh/docs/4.x/producer/01concept1%E3%80%82">https://rocketmq.apache.org/zh/docs/4.x/producer/01concept1。</a></p><h1 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h1><ol><li><p>下载 RocketMQ 二进制包<br>浏览器访问地址：<a href="https://archive.apache.org/dist/rocketmq/4.9.4/rocketmq-all-4.9.4-bin-release.zip">https://archive.apache.org/dist/rocketmq/4.9.4/rocketmq-all-4.9.4-bin-release.zip</a> ， 下载 RocketMQ 编译完成后的二进制包：</p></li><li><p>下载完成后，进行解压。</p></li></ol><p>3.设置环境变量<br>解压完成后放着，先把相关环境变量设置一下</p><p>添加一个 ROCKETMQ_HOME 变量，值为刚刚我们二进制包解压的具体路径：</p><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123110105133.png" alt="Loading"></p><p>另外，将 JAVA_HOME 系统变量修改为 jdk1.8</p><ol start="4"><li>设置完成后保存，打开一个新的命令窗口，执行 java -version 命令，确认当前使用的版本是 Java 8</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123110201377.png" alt="Loading"></p><ol start="5"><li><p>启动 RocketMQ<br>接着，准备正式启动 RocketMQ。</p></li><li><p>启动 namesrv<br>打开 cmd 命令行工具，进入到 RocketMQ 安装包的 &#x2F;bin 文件夹下，执行如下命令，先将 namesrv 启动起来:</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">start .\mqnamesrv.cmd<br></code></pre></td></tr></table></figure><p>命令执行完成后，会打开一个新的窗口，若提示 The Name Server boot sucess. , 则表示 namesrv 启动成功了。</p><p>注意：窗口打开后，不要关闭，关闭后 namesrv 也会随之关闭。</p><ol start="7"><li>启动 broker<br>接着，执行如下命令，准备启动 broker :</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">.\mqbroker -n 127.0.0.1:9876 autoCreateTopicEnable=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>解释一下启动参数的含义：</p><ul><li><p><code>-n 127.0.0.1:9876</code>：用来指定网络连接参数的标志，绑定到本地 IP 地址 127.0.0.1 并监听端口 9876。</p></li><li><p><code>autoCreateTopicEnable=true</code>：当发送的消息主题（topic）不存在时，则自动创建。</p></li></ul><p>命令执行完成后，若提示 The broker .. boot success. , 则表示运行成功了。同样的，窗口不要关闭。</p><ol start="8"><li>RocketMQ 控制台<br>为了更方便的管控 RocketMQ, 还需要一个控制台。浏览器访问：<a href="https://github.com/apache/rocketmq-dashboard">https://github.com/apache/rocketmq-dashboard</a> ， 如下图所示，下载 zip 源码：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250123105805180.png"></p><p>下载完成后解压，并使用 IDEA 打开项目。</p><p>运行 App 启动类，将项目跑起来。启动成功后，浏览器访问 localhost:8080, 即可打开 RocketMQ 的控制台了</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK安装与配置</title>
    <link href="/2025/01/20/JDK%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/01/20/JDK%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="JDK下载-基于window11系统"><a href="#JDK下载-基于window11系统" class="headerlink" title="JDK下载(基于window11系统)"></a>JDK下载(基于window11系统)</h1><p>打开官网链接，根据自己的系统，按需选择下载JDK。会跳转到Oracle登录页，如果有账号直接登录即可，没账号的话点击创建账户，填写信息（邮箱填写正确，其余随便填均可）后点击创建账户，邮箱验证即可，再次登录，登录成功即开始下载。</p><h2 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h2><p>打开下载的对应文件.exe，单击下一步安装。<br>安装时可自选安装路径<br>JDK安装完成后会弹出JRE安装，同样流程完成。</p><h2 id="JDK环境配置"><a href="#JDK环境配置" class="headerlink" title="JDK环境配置"></a>JDK环境配置</h2><p>安装完JDK之后，需要设置JAVA_HOME的环境变量。其中JAVA_HOME需要指向的是JDK的安装目录。<br>JAVA_HOME设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 变量名：</span><br>JAVA_HOME<br><span class="hljs-comment"># 变量值：例如我设置的是如下，所以指向的是此地址，此处根据你自己设置的来。</span><br>D:\codeConfiguration\JAVA\jdk1.8<br></code></pre></td></tr></table></figure><p>更改path环境变量设置<br>PATH是什么？</p><ul><li>PATH 是操作系统用于查找来自命令行或终端窗口的必需可执行文件的系统变量。</li><li>PATH 系统变量可使用控制面板中的“系统”实用程序设置（在 Windows 上），或在 shell 的启动文件内设置（在 Linux 和 Solaris 上）。<br>Window下环境变量设置：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Windows：%JAVA_HOME%\bin<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker相关</title>
    <link href="/2025/01/19/Docker%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/01/19/Docker%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础常见面试题</title>
    <link href="/2025/01/19/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2025/01/19/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>Java中有8种基本数据类型，分别为：</p><p>6 种数字类型：</p><ul><li>4 种整数型：byte，short，int，long</li><li>2 种浮点型：float，double<br>1 种字符类型：char<br>1 种布尔型：boolean</li></ul><table><thead><tr><th>基本类型</th><th>位数</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>8</td><td>1</td><td>0</td></tr><tr><td>short</td><td>16</td><td>2</td><td>0</td></tr><tr><td>int</td><td>32</td><td>4</td><td>0</td></tr><tr><td>long</td><td>64</td><td>8</td><td>0L</td></tr><tr><td>char</td><td>16</td><td>2</td><td>‘u0000’</td></tr><tr><td>float</td><td>32</td><td>4</td><td>0.0f</td></tr><tr><td>double</td><td>64</td><td>8</td><td>0.0d</td></tr><tr><td>boolean</td><td>1</td><td>1</td><td>false</td></tr></tbody></table><p>这八种类型对应的包装类型分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean。</p><p>基本类型和包装类型的区别？</p><ol><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少使用基本数据类型来定义变量，并且，包装类型可以有多个值，而基本类型不可以。</li><li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机的局部变量表中，基本数据类型的成员变量（未做 static 修饰）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型），基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量是包装类型时默认值是 <code>null</code>，而基本数据类型默认值不是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值， 对于包装类型来说，<code>==</code> 比较的是对象的内存地址。所有包装类对象之间的比较，都应该使用 <code>equals()</code> 方法。</li></ol><p><strong>注</strong>：基本数据类型存储位置取决于其作用域及生命周期。</p><p>包装类的缓存机制？<br>Byte、Short、Integer、Long 这 4 种包装类默认创建数值 [-128，127] 的相应类型的缓存数据，<br>Character 创建了数值在 [0，127] 范围的缓存数据，Boolean 直接返回 True 或 False。<br>如果超出对应范围仍会创建新对象，缓存的范围区间大小只是在性能和资源之间权衡。<br>两种浮点类型的包装类Float、Double并未实现缓存机制。</p><p>Integer缓存源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerCache</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> -<span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> high;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// high value may be configured by property</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自动装箱与拆箱原理？<br>什么是自动拆装箱？</p><ul><li>装箱：将基本类型用对应的有引用类型包装起来。</li><li>拆箱：将包装类型转换为基本数据类型。</li></ul><p>装箱就是调用包装类的valueOf()方法，拆箱就是调用xxxValue()方法。</p><p>为什么浮点数运算会有精度丢失的风险？<br>计算机是二进制的，计算机在表示一个数字时，宽度是有限的，无限循环小数存储在计算机中会被截断导致小数精度丢失问题。</p><p>如何解决浮点数精度丢失问题？</p><p><code>BigDecimal</code>可以实现对浮点数的运算，不会导致精度丢失。</p><p>超过long整型的数字如何表示？</p><p><code>BigInteger</code>内部使用<code>int[]</code>数组来储存，运算效率较低。在使用 <code>BigDecimal</code> 时，为了防止精度丢失，推荐使用它的<code>BigDecimal(String val)</code>构造方法或者 <code>BigDecimal.valueOf(double val)</code> 静态方法来创建对象。</p><h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类可以增加新的数据和功能，也可以使用父类的功能，但不能选择性继承。继承可以提高代码的复用性，程序的可维护性。</p><p>继承的三大特点：</p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，只有拥有。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以拥有自己的方法形式定义父类的方法。（以后介绍）</li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>一个对象具有多种状态，具体表现为父类的引用指向子类的实例。<br>多态的特点：</p><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型是从其方法调用的返回值类型来决定哪个方法，必须在程序运行时才能确定；</li><li>多态不能单用，只在子类存在任意父类方法不存在的时候；</li><li>如果子类没有重写父类方法，具体执行的是父类的写的方法，执行的就是父类的。</li></ul><h2 id="接口和抽象类异同？"><a href="#接口和抽象类异同？" class="headerlink" title="接口和抽象类异同？"></a>接口和抽象类异同？</h2><p>接口和抽象类的共同点</p><p>实例化: 接口和抽象类都不能直接实例化对象，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。<br>抽象方法: 接口和抽象类可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。</p><p>接口和抽象类的区别</p><ul><li><p>设计目的: 接口主要用于对类的行为进行约束，接口就拥有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</p></li><li><p>继承和实现： 一个类只能继承一个类（包括抽象类），因为 Java 不支持多继承。一个接口可以继承多个其他接口。</p></li><li><p>成员变量： 接口中的成员变量只能是 <code>public static final</code>，不能被修改且必须有初始值。抽象类的成员变量可以有任意修饰符，可以在子类被重新定义或赋值。</p></li><li><p>方法: </p><ul><li><p>在 Java 8 之前，接口中的方法默认是 <code>public abstract</code>，也就是只有方法声明。自 Java 8 起，可以在接口中定义 <code>default</code>（默认）方法和 <code>static</code>（静态）方法。自 Java 9 起，接口也可以包含 <code>private</code> 方法。</p></li><li><p>抽象类可以包含抽象方法和具体方法。抽象类方法有具体实现，可以直接在抽象类中使用或在子类中实现。非抽象方法具有具体实现。</p></li></ul></li></ul><p>在 Java 8 以及以后的版本中，接口可以拥有新的方法声明：default 方法、static 方法和 private 方法。这些方法被接口的实现类使用时必须满足一定规则。</p><h2 id="深拷贝和浅拷贝的区别？什么是引用拷贝？"><a href="#深拷贝和浅拷贝的区别？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝的区别？什么是引用拷贝？"></a>深拷贝和浅拷贝的区别？什么是引用拷贝？</h2><ul><li><p>浅拷贝: 浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的引用类型的变量，浅拷贝会直接复制内部对象的引用地址，也就是说浅拷贝对象和原对象共用一个内部对象。</p></li><li><p>深拷贝: 深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p></li><li><p>引用拷贝：两个不同的引用指向同一个对象。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bloomivy/pic/20250127142153772.png" alt="Loading"></p><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p><code>Object</code>类是一个特殊的类，是所有java类的父类，主要提供以下11种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实例被垃圾回收器回收的时候触发的操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="与-equals-的区别？"><a href="#与-equals-的区别？" class="headerlink" title="&#x3D;&#x3D; 与 equals() 的区别？"></a>&#x3D;&#x3D; 与 equals() 的区别？</h3><p>&#x3D;&#x3D; 对基本类型与引用类型是不同的：</p><ul><li><p>对基本类型是比较值。</p></li><li><p>对引用类型是比较对象的地址。</p></li></ul><p>注：java只有值传递，对于 &#x3D;&#x3D; 而言，不论是对于基本数据类型还是引用类型都是比较值。</p><p><code>equals()</code>不能用于判断基本类型，只能用于判断对象是否相对。</p><p><code>equals()</code>方法存在两种使用方法：</p><ul><li><p>类没有重写<code>equals()</code>：等价于 &#x3D;&#x3D; 。</p></li><li><p>类重写<code>equals()</code>：比较两个对象中属性是否相等。</p></li></ul><h3 id="hashcode-有什么用？"><a href="#hashcode-有什么用？" class="headerlink" title="hashcode() 有什么用？"></a>hashcode() 有什么用？</h3><p><code>hashcode</code>的作用是获取对象的hash码。有了 hashCode() 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进HashSet的过程）。</p><h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h4><ul><li><p>可变性： <code>String</code> 是不可变的。<code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p></li><li><p>线程安全：<code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 S<code>tringBuffer</code> 的公共父类。<code>StringBuffe</code>r 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p></li><li><p>性能：每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p></li></ul><h4 id="string-类为什么是不可变的？"><a href="#string-类为什么是不可变的？" class="headerlink" title="string 类为什么是不可变的？"></a>string 类为什么是不可变的？</h4><ul><li><p>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</p></li><li><p><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</p></li></ul><h4 id="字符串拼接使用-还是-StringBuilder？"><a href="#字符串拼接使用-还是-StringBuilder？" class="headerlink" title="字符串拼接使用 + 还是 StringBuilder？"></a>字符串拼接使用 + 还是 StringBuilder？</h4><p>Java自身并不支持运算符重载， + 与 +&#x3D; 是专门为 <code>String</code>类重载的，也是Java仅有的重载运算符。</p><p>字符串对象通过调用 + 拼接字符串的方式，本质上是通过<code>StringBuilder</code>调用<code>append()</code>方法，拼接完成后调用<code>toString()</code>得到<code>String</code>对象。</p><h4 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h4><p>会创建 1 或 2 个字符串对象。</p><ul><li><p>字符串常量池中不存在 “abc”：会创建 2 个 字符串对象。一个在字符串常量池中，由 <code>ldc</code> 指令触发创建。一个在堆中，由 <code>new String()</code> 创建，并使用常量池中的 “abc” 进行初始化。</p></li><li><p>字符串常量池中已存在 “abc”：会创建 1 个 字符串对象。该对象在堆中，由 <code>new String()</code> 创建，并使用常量池中的 “abc” 进行初始化。</p></li></ul><h4 id="String-intern-方法有什么作用"><a href="#String-intern-方法有什么作用" class="headerlink" title="String#intern 方法有什么作用?"></a>String#intern 方法有什么作用?</h4><p><code>String.intern()</code> 是一个 <code>native</code> (本地) 方法，用来处理字符串常量池中的字符串对象引用。</p><ul><li><p><code>intern()</code> 方法的主要作用是确保字符串引用在常量池中的唯一性。</p></li><li><p>当调用 <code>intern()</code> 时，如果常量池中已经存在相同内容的字符串，则返回常量池中已有对象的引用；否则，将该字符串添加到常量池并返回其引用。</p></li></ul><h1 id="Java的反射机制"><a href="#Java的反射机制" class="headerlink" title="Java的反射机制"></a>Java的反射机制</h1><h2 id="何为反射？"><a href="#何为反射？" class="headerlink" title="何为反射？"></a>何为反射？</h2><p>通过反射可以获取任意一个类的所有属性和方法，还可以调用。</p><h2 id="反射的运用场景"><a href="#反射的运用场景" class="headerlink" title="反射的运用场景"></a>反射的运用场景</h2><p>Spring&#x2F;Spring Boot、Mybatis框架都使用到了反射。</p><p>JDK动态代理的实现也依赖于反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代理类中的真实对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DebugInvocationHandler</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;<br>        System.out.println(<span class="hljs-string">&quot;before method &quot;</span> + method.getName());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        System.out.println(<span class="hljs-string">&quot;after method &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java中的注解也运用到了反射。</p><h2 id="反射机制的优缺点"><a href="#反射机制的优缺点" class="headerlink" title="反射机制的优缺点"></a>反射机制的优缺点</h2><p>优点：使代码更加灵活，为各种框架提供便利。</p><p>缺点：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点。</p><h2 id="获取Java对象的方式"><a href="#获取Java对象的方式" class="headerlink" title="获取Java对象的方式"></a>获取Java对象的方式</h2><ol><li>知道具体类的情况：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass</span> <span class="hljs-operator">=</span> TargetObject.class;<br></code></pre></td></tr></table></figure><ol start="2"><li>通过 <code>Class.forName()</code> 方法传入类的全路径获取</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;cn.test.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="3"><li>通过对象实例 <code>Instance.getClass()</code> 获取</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TargetObject</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TargetObject</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass2</span> <span class="hljs-operator">=</span> o.getClass();<br></code></pre></td></tr></table></figure><ol start="4"><li>通过类加载器 <code>xxxClassLoader.loadClass()</code> 传入类路径获取:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure><p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组遍历技巧</title>
    <link href="/2025/01/19/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%8A%80%E5%B7%A7/"/>
    <url>/2025/01/19/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="顺-逆时针旋转矩阵"><a href="#顺-逆时针旋转矩阵" class="headerlink" title="顺&#x2F;逆时针旋转矩阵"></a>顺&#x2F;逆时针旋转矩阵</h1><h2 id="LeetCode-48-旋转图像"><a href="#LeetCode-48-旋转图像" class="headerlink" title="LeetCode 48.旋转图像"></a>LeetCode 48.旋转图像</h2><p>常规的思路就是去寻找原始坐标和旋转后坐标的映射规律，但我们是否可以让思维跳跃跳跃，尝试把矩阵进行反转、镜像对称等操作，可能会出现新的突破口。</p><p>我们可以先将 n x n 矩阵 matrix 按照左上到右下的对角线进行镜像对称，然后再对矩阵的每一行进行反转，结果就是 matrix 顺时针旋转 90 度的结果：。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 将二维矩阵原地顺时针旋转 90 度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 先沿对角线镜像对称二维矩阵</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++) &#123;<br>                <span class="hljs-comment">// swap(matrix[i][j], matrix[j][i]);</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 然后反转二维矩阵的每一行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : matrix) &#123;<br>            reverse(row);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 反转一维数组</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = arr.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt; i) &#123;<br>            <span class="hljs-comment">// swap(arr[i], arr[j]);</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>扩展：如何将矩阵逆时针旋转90度<br>思路是类似的，只要通过另一条对角线镜像对称矩阵，然后再反转每一行，就得到了逆时针旋转矩阵的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// 将二维矩阵原地逆时针旋转 90 度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate2</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 沿左下到右上的对角线镜像对称二维矩阵</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n - i; j++) &#123;<br>                <span class="hljs-comment">// swap(matrix[i][j], matrix[n-j-1][n-i-1])</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[n - j - <span class="hljs-number">1</span>][n - i - <span class="hljs-number">1</span>];<br>                matrix[n - j - <span class="hljs-number">1</span>][n - i - <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 然后反转二维矩阵的每一行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : matrix) &#123;<br>            reverse(row);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-comment">// ···</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解法2：先翻转再对称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">//先翻转数组，再对称即可</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : matrix) &#123;<br>            reverse(arr);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[left];<br>            nums[left] = nums[right];<br>            nums[right] = tmp;<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="矩阵的螺旋遍历"><a href="#矩阵的螺旋遍历" class="headerlink" title="矩阵的螺旋遍历"></a>矩阵的螺旋遍历</h1><h2 id="LeetCode-54-螺旋矩阵"><a href="#LeetCode-54-螺旋矩阵" class="headerlink" title="LeetCode 54.螺旋矩阵"></a>LeetCode 54.螺旋矩阵</h2><p>解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界,随着螺旋遍历，相应的边界会收缩，直到螺旋遍历完整个数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">upper_bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lower_bound = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left_bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right_bound = n - <span class="hljs-number">1</span>;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// res.size() == m * n 则遍历完整个数组</span><br>        <span class="hljs-keyword">while</span> (res.size() &lt; m * n) &#123;<br>            <span class="hljs-keyword">if</span> (upper_bound &lt;= lower_bound) &#123;<br>                <span class="hljs-comment">// 在顶部从左向右遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> left_bound; j &lt;= right_bound; j++) &#123;<br>                    res.add(matrix[upper_bound][j]);<br>                &#125;<br>                <span class="hljs-comment">// 上边界下移</span><br>                upper_bound++;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (left_bound &lt;= right_bound) &#123;<br>                <span class="hljs-comment">// 在右侧从上向下遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> upper_bound; i &lt;= lower_bound; i++) &#123;<br>                    res.add(matrix[i][right_bound]);<br>                &#125;<br>                <span class="hljs-comment">// 右边界左移</span><br>                right_bound--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (upper_bound &lt;= lower_bound) &#123;<br>                <span class="hljs-comment">// 在底部从右向左遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> right_bound; j &gt;= left_bound; j--) &#123;<br>                    res.add(matrix[lower_bound][j]);<br>                &#125;<br>                <span class="hljs-comment">// 下边界上移</span><br>                lower_bound--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (left_bound &lt;= right_bound) &#123;<br>                <span class="hljs-comment">// 在左侧从下向上遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lower_bound; i &gt;= upper_bound; i--) &#123;<br>                    res.add(matrix[i][left_bound]);<br>                &#125;<br>                <span class="hljs-comment">// 左边界右移</span><br>                left_bound++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-59-螺旋矩阵Ⅱ"><a href="#LeetCode-59-螺旋矩阵Ⅱ" class="headerlink" title="LeetCode 59.螺旋矩阵Ⅱ"></a>LeetCode 59.螺旋矩阵Ⅱ</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">upper_bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lower_bound = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left_bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right_bound = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 需要填入矩阵的数字</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span> (num &lt;= n * n) &#123;<br>            <span class="hljs-keyword">if</span> (upper_bound &lt;= lower_bound) &#123;<br>                <span class="hljs-comment">// 在顶部从左向右遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> left_bound; j &lt;= right_bound; j++) &#123;<br>                    matrix[upper_bound][j] = num++;<br>                &#125;<br>                <span class="hljs-comment">// 上边界下移</span><br>                upper_bound++;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (left_bound &lt;= right_bound) &#123;<br>                <span class="hljs-comment">// 在右侧从上向下遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> upper_bound; i &lt;= lower_bound; i++) &#123;<br>                    matrix[i][right_bound] = num++;<br>                &#125;<br>                <span class="hljs-comment">// 右边界左移</span><br>                right_bound--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (upper_bound &lt;= lower_bound) &#123;<br>                <span class="hljs-comment">// 在底部从右向左遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> right_bound; j &gt;= left_bound; j--) &#123;<br>                    matrix[lower_bound][j] = num++;<br>                &#125;<br>                <span class="hljs-comment">// 下边界上移</span><br>                lower_bound--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (left_bound &lt;= right_bound) &#123;<br>                <span class="hljs-comment">// 在左侧从下向上遍历</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lower_bound; i &gt;= upper_bound; i--) &#123;<br>                    matrix[i][left_bound] = num++;<br>                &#125;<br>                <span class="hljs-comment">// 左边界右移</span><br>                left_bound++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二维数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针相关算法</title>
    <link href="/2025/01/19/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/19/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、快慢指针"><a href="#一、快慢指针" class="headerlink" title="一、快慢指针"></a>一、快慢指针</h1><h2 id="原地修改"><a href="#原地修改" class="headerlink" title="原地修改"></a>原地修改</h2><h3 id="LeetCode-26-删除有序数组中的重复项"><a href="#LeetCode-26-删除有序数组中的重复项" class="headerlink" title="LeetCode 26. 删除有序数组中的重复项"></a>LeetCode 26. 删除有序数组中的重复项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fast] != nums[slow]) &#123;<br>                slow++;<br>                <span class="hljs-comment">// 维护 nums[0..slow] 无重复</span><br>                nums[slow] = nums[fast];<br>            &#125;<br>            fast++;<br>        &#125;<br>        <span class="hljs-comment">// 数组长度为索引 + 1</span><br>        <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LeetCode-27-移除元素"><a href="#LeetCode-27-移除元素" class="headerlink" title="LeetCode 27.移除元素"></a>LeetCode 27.移除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fast] != val) &#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>            fast++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与26题存在差别：先给 nums[slow] 赋值然后再给 slow++，这样可以保证 nums[0..slow-1] 是不包含值为 val 的元素的，最后的结果数组长度就是 slow。</p><h3 id="LeetCode-283-移动零"><a href="#LeetCode-283-移动零" class="headerlink" title="LeetCode 283.移动零"></a>LeetCode 283.移动零</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 去除 nums 中的所有 0，返回不含 0 的数组长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> removeElement(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 将 nums[p..] 的元素赋值为 0</span><br>        <span class="hljs-keyword">for</span> (; p &lt; nums.length; p++) &#123;<br>            nums[p] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 见27.代码实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口代码框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 滑动窗口算法框架伪码</span><br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (right &lt; nums.size()) &#123;<br>    <span class="hljs-comment">// 增大窗口</span><br>    window.addLast(nums[right]);<br>    right++;<br>    <br>    <span class="hljs-keyword">while</span> (window needs shrink) &#123;<br>        <span class="hljs-comment">// 缩小窗口</span><br>        window.removeFirst(nums[left]);<br>        left++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、左右指针"><a href="#二、左右指针" class="headerlink" title="二、左右指针"></a>二、左右指针</h1><p>二分方法下左右指针：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right + left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-167-两数之和Ⅱ"><a href="#LeetCode-167-两数之和Ⅱ" class="headerlink" title="LeetCode 167.两数之和Ⅱ"></a>LeetCode 167.两数之和Ⅱ</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = numbers.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> numbers[left] + numbers[right];<br>            <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                <span class="hljs-comment">// 题目要求的索引是从 1 开始的</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>                <span class="hljs-comment">// 让 sum 大一点</span><br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>                <span class="hljs-comment">// 让 sum 小一点</span><br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-344-反转字符串"><a href="#Leetcode-344-反转字符串" class="headerlink" title="Leetcode 344.反转字符串"></a>Leetcode 344.反转字符串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>    <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 交换 s[left] 和 s[right]</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s[left];<br>        s[left] = s[right];<br>        s[right] = temp;<br>        left++;<br>        right--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-5-最长回文子串"><a href="#Leetcode-5-最长回文子串" class="headerlink" title="Leetcode 5.最长回文子串"></a>Leetcode 5.最长回文子串</h2><p>判断回文串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">// 一左一右两个指针相向而行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        left++;<br>        right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>找回文串关键点在于，回文串长度可能为奇数也可能是偶数，解决问题核心在于从回文串中心向两边扩散的双指针技巧。<br>如果回文串长度为奇数，则它有一个中心字符；如果回文串长度为偶数，则有两个中心字符。<br>函数实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串</span><br>String <span class="hljs-title function_">palindrome</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-comment">// 防止索引越界</span><br>    <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.length()<br>            &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;<br>        <span class="hljs-comment">// 双指针，向两边展开</span><br>        l--; r++;<br>    &#125;<br>    <span class="hljs-comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span><br>    <span class="hljs-keyword">return</span> s.substring(l + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><p>整体解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-comment">// 以 s[i] 为中心的最长回文子串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> palindrome(s, i, i);<br>        <span class="hljs-comment">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> palindrome(s, i, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// res = longest(res, s1, s2)</span><br>        res = res.length() &gt; s1.length() ? res : s1;<br>        res = res.length() &gt; s2.length() ? res : s2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br>String <span class="hljs-title function_">palindrome</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-comment">// 防止索引越界</span><br>    <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.length()<br>            &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;<br>        <span class="hljs-comment">// 双指针，向两边展开</span><br>        l--; r++;<br>    &#125;<br>    <span class="hljs-comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span><br>    <span class="hljs-keyword">return</span> s.substring(l + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOC&amp;AOP</title>
    <link href="/2025/01/19/Spring-IOC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/01/19/Spring-IOC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="什么是IOC？"><a href="#什么是IOC？" class="headerlink" title="什么是IOC？"></a>什么是IOC？</h2><p>IOC即控制反转。是一种思想，将创建对象的权力交给外部容器(IOC容器)</p><h2 id="IOC解决的问题："><a href="#IOC解决的问题：" class="headerlink" title="IOC解决的问题："></a>IOC解决的问题：</h2><p>1.降低对象之间的耦合度；<br>2.使资源管理更简单。</p><h2 id="IOC与DI有什么区别？"><a href="#IOC与DI有什么区别？" class="headerlink" title="IOC与DI有什么区别？"></a>IOC与DI有什么区别？</h2><p>IOC是一种设计思想，即将本来在程序中手动创建对象的控制权交给第三方比如IOC容器。对于Spring框架而言，IOC就是一个Map(key,value)，Mao中存放各种对象。IOC并非Spring独有。<br>IOC最常见、最合理的实现方法即DI(依赖注入)。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h2><p>AOP即面向切面编程，AOP是OOP的一种延伸，二者互相补充。核心思想是将横切关注点从业务逻辑中抽离出来，形成一个个切面。</p><h2 id="AOP关键术语："><a href="#AOP关键术语：" class="headerlink" title="AOP关键术语："></a>AOP关键术语：</h2><ul><li>切点 (PointCut)：一个切点即一个表达式，用来匹配需要增强被切面增强的连接点。</li><li>切面(Aspect)：对横切关注点进行封装的类，一个切面是一个类。一个切面可以定义多个通知，实现具体的功能。</li><li>连接点(JoinPoint)：连接点是方法调用或方法执行的某个特定时刻(方法调用、异常抛出等)。</li><li>通知(Advice)：通知即切面在某个连接点要执行的操作。通知分为五种类型。分别是前置通知(Before)、后置通知(After)、返回通知(AfterReturning)、异常通知(AfterThrowing)和环绕通知(Around)。</li><li>织入(Weaving)：织入是将切面和目标对象连接起来的过程，即将通知应用到切点匹配的连接点上。常见的织入时期：编译器织入和运行期织入。</li></ul><h2 id="AOP常见的通知类型："><a href="#AOP常见的通知类型：" class="headerlink" title="AOP常见的通知类型："></a>AOP常见的通知类型：</h2><ul><li>Before（前置通知）：目标对象的方法调用在前触发。</li><li>After（后置通知）：目标对象的方法调用之后触发。</li><li>AfterReturning（返回通知）：目标对象的方法调用完成后触发，返回结果值之后触发。</li><li>AfterThrowing（异常通知）：目标对象的方法执行中抛出异常时触发。如果方法调用成功且无异常，则返回值不受影响。</li><li>Around（环绕通知）：可以在方法调用的前后执行自定义逻辑，甚至可以控制方法的执行，具有完全的控制权。</li></ul><h2 id="AOP解决了什么问题？"><a href="#AOP解决了什么问题？" class="headerlink" title="AOP解决了什么问题？"></a>AOP解决了什么问题？</h2><p>OOP不能很好的处理分散在多个类或对象中的公共行为，即横切关注点。而AOP可以将横切关注点从核心业务逻辑中分离出来，实现关注点的分离。</p><h2 id="AOP常见应用场景？"><a href="#AOP常见应用场景？" class="headerlink" title="AOP常见应用场景？"></a>AOP常见应用场景？</h2><ul><li>日志记录：自定义日志记录注解，利用 AOP，行代码即可实现日志记录。</li><li>性能统计：利用 AOP 在目标方法的执行前后进行统计，方便优化和分析。</li><li>事务管理：@Transactional 注解可以让 Spring 为我们进行事务管理，避免了重复的事务管理逻辑。@Transactional 注解是基于 AOP 实现的。</li><li>权限控制：利用 AOP 在目标方法执行前判断用户是否具备所需的权限，如果具备，就执行目标方法，否则就不执行。例如，SpringSecurity 利用 @PreAuthorize 注解一行代码即可自定义权限校验。</li><li>接入限制：利用 AOP 在目标方法执行前进行请求参数的校验和实现请求排队限流处理。</li><li>缓存管理：利用 AOP 在目标方法执行后进行缓存的读取和更新。</li></ul><h1 id="AOP实现方式有哪些？"><a href="#AOP实现方式有哪些？" class="headerlink" title="AOP实现方式有哪些？"></a>AOP实现方式有哪些？</h1><p>AOP常见实现方式有动态代理和字节码操作两种方式。</p><h2 id="Spring-AOP与AspectJ-AOP有什么区别？"><a href="#Spring-AOP与AspectJ-AOP有什么区别？" class="headerlink" title="Spring AOP与AspectJ AOP有什么区别？"></a>Spring AOP与AspectJ AOP有什么区别？</h2><p>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。Spring AOP 基于代理 (Proxy)，而 AspectJ 基于字节码操作（Bytecode Manipulation）。<br>Spring AOP 已经集成了 AspectJ，AspectJ 应该算的是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单。<br>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的时候，最好选择 AspectJ，它比 Spring AOP 快很多。</p>]]></content>
    
    
    <categories>
      
      <category>Spring框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo主题搭建</title>
    <link href="/2025/01/18/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
    <url>/2025/01/18/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1. 安装依赖包"></a>1. 安装依赖包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><h1 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br>npm install<br></code></pre></td></tr></table></figure><h1 id="3-关联Github"><a href="#3-关联Github" class="headerlink" title="3. 关联Github"></a>3. 关联Github</h1><h2 id="上传文章封面图不显示"><a href="#上传文章封面图不显示" class="headerlink" title="上传文章封面图不显示"></a>上传文章封面图不显示</h2><p>设置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">tags: [fluid, js, css,Hexo]<br>categories: [Hexo]<br>index_img: /source/img/cover/fluid.png<br></code></pre></td></tr></table></figure><p>问题：<br>设置路径错误，修正如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">categories: [Hexo]<br>index_img: /img/cover/fluid.png<br></code></pre></td></tr></table></figure><p>TODO：文章底部生成链接修正<br>TODO：头像旋转<br>TODO：引入一言<br>TODO：引入PV UV</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fluid</tag>
      
      <tag>js</tag>
      
      <tag>css</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>场景算法</title>
    <link href="/2025/01/18/%E5%9C%BA%E6%99%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/18/%E5%9C%BA%E6%99%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-面试题-16-25-LRU缓存"><a href="#LeetCode-面试题-16-25-LRU缓存" class="headerlink" title="LeetCode 面试题 16.25. LRU缓存"></a>LeetCode 面试题 16.25. LRU缓存</h2><p>设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。<br>它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p>示例：</p><p>LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );</p><p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       &#x2F;&#x2F; 返回  1<br>cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得密钥 2 作废<br>cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)<br>cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得密钥 1 作废<br>cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)<br>cache.get(3);       &#x2F;&#x2F; 返回  3<br>cache.get(4);       &#x2F;&#x2F; 返回  4</p><p>思路：使用双向链表实现，每个节点包括k，v数据以及前驱、后继节点。此外，链表中还有虚拟节点dummy，让每个节点的pre和next均不为空，简化操作。<br>为什么要保存key？<br>在删除链表末尾节点时，需要删除哈希表中的记录，需要查找末尾节点的key。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> key, value;<br>        Node pre, next;<br><br>        Node(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v) &#123;<br>            key = k;<br>            value = v;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer,Node&gt; keyToNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        dummy.pre = dummy;<br>        dummy.next = dummy;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNode(key);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> ? node.value : -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNode(key);<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            node.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value);<br>        keyToNode.put(key,node);<br>        pushFront(node);<br>        <span class="hljs-keyword">if</span> (keyToNode.size() &gt; capacity) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">backNode</span> <span class="hljs-operator">=</span> dummy.pre;<br>            keyToNode.remove(backNode.key);<br>            remove(backNode);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (! keyToNode.containsKey(key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> keyToNode.get(key);<br>        remove(node);<br>        pushFront(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Node x)</span> &#123;<br>        x.pre.next = x.next;<br>        x.next.pre = x.pre;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushFront</span><span class="hljs-params">(Node x)</span> &#123;<br>        x.pre = dummy;<br>        x.next = dummy.next;<br>        x.pre.next = x;<br>        x.next.pre = x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手写单例模式的实现"><a href="#手写单例模式的实现" class="headerlink" title="手写单例模式的实现"></a>手写单例模式的实现</h2><h3 id="1-懒汉式"><a href="#1-懒汉式" class="headerlink" title="1.懒汉式"></a>1.懒汉式</h3><p>懒汉式单例是在第一次使用时创建实例，但这种方式在多线程环境下不安全，可能导致多个实例的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态变量，保存唯一的实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <span class="hljs-comment">// 这里是懒加载</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1懒汉式的线程安全模式"><a href="#1-1懒汉式的线程安全模式" class="headerlink" title="1.1懒汉式的线程安全模式"></a>1.1懒汉式的线程安全模式</h4><p>通过在 getInstance() 方法加锁来实现线程安全，但由于每次都加锁，可能会影响性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态变量，保存唯一的实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2双重检查锁"><a href="#1-2双重检查锁" class="headerlink" title="1.2双重检查锁"></a>1.2双重检查锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 使用 volatile 确保可见性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3静态内部类"><a href="#1-3静态内部类" class="headerlink" title="1.3静态内部类"></a>1.3静态内部类</h4><p>这种方式是线程安全的，并且延迟加载，推荐使用。JVM 确保了静态内部类只会加载一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态内部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHelper</span> &#123;<br>        <span class="hljs-comment">// 静态变量，保存唯一的实例</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHelper.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-饿汉式"><a href="#2-饿汉式" class="headerlink" title="2.饿汉式"></a>2.饿汉式</h3><p>这种方式在类加载时就创建实例，不会等到需要的时候才创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态变量，保存唯一的实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">// 私有化构造函数，避免外部直接创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三个线程循环打印斐波那契数列"><a href="#三个线程循环打印斐波那契数列" class="headerlink" title="三个线程循环打印斐波那契数列"></a>三个线程循环打印斐波那契数列</h2><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FibonacciPrinter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <span class="hljs-comment">// 用于线程间同步</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">fib1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 斐波那契数列的第一个数字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">fib2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 斐波那契数列的第二个数字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 控制打印的次数</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建三个线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(<span class="hljs-number">2</span>));<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(<span class="hljs-number">3</span>));<br><br>        <span class="hljs-comment">// 启动线程</span><br>        thread1.start();<br>        thread2.start();<br>        thread3.start();<br>    &#125;<br><br>    <span class="hljs-comment">// 斐波那契数列打印任务</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FibonacciTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threadId;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">FibonacciTask</span><span class="hljs-params">(<span class="hljs-type">int</span> threadId)</span> &#123;<br>            <span class="hljs-built_in">this</span>.threadId = threadId;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">30</span>) &#123;  <span class="hljs-comment">// 打印30个斐波那契数列</span><br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    <span class="hljs-comment">// 判断当前线程是否轮到它打印</span><br>                    <span class="hljs-keyword">if</span> (count % <span class="hljs-number">3</span> == threadId - <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">nextFib</span> <span class="hljs-operator">=</span> fib1 + fib2;<br>                        System.out.println(<span class="hljs-string">&quot;Thread &quot;</span> + threadId + <span class="hljs-string">&quot; prints: &quot;</span> + fib1);<br>                        fib1 = fib2;<br>                        fib2 = nextFib;<br>                        count++;<br>                        lock.notifyAll();  <span class="hljs-comment">// 唤醒其他线程</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            lock.wait();  <span class="hljs-comment">// 当前线程等待</span><br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            Thread.currentThread().interrupt();<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script><div id="posts-chart"style="border-radius: 8px; height: 190px; padding: 10px;"></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>面经</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>lru</tag>
      
      <tag>JUC</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/01/18/hello-world/"/>
    <url>/2025/01/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script><div id="posts-chart"style="border-radius: 8px; height: 190px; padding: 10px;"></div>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
